/*

Copyright (C) 2017-2020 Ivan Kniazkov

This file is part of interpreter of programming language
codenamed "Goat" ("Goat interpreter").

Goat interpreter is free software: you can redistribute it and/or
modify it under the terms of the GNU General Public License as published
by the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Goat interpreter is distributed in the hope that it will be
useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with Goat interpreter.  If not, see <http://www.gnu.org/licenses/>.

*/

import "stepper_motor.goat";
import "interpolator.goat";

var Positioning =
# {
    init : $(axisX1, axisX2, axisY, axisZ, resolution)
    {
        if (!axisX1.instanceof(StepperMotor) || !(axisX2 == void || axisX2.instanceof(StepperMotor)) ||
                !axisY.instanceof(StepperMotor) || !axisZ.instanceof(StepperMotor))
            throw new Exception.IllegalArgument();

        this.axisX1 = axisX1;
        this.axisX2 = axisX2;
        this.axisY = axisY;
        this.axisZ = axisZ;
        this.minDistance = 1.0 / resolution / 1.5;
    },

    dir : $(n)
    {
        if (n == 0)
            return 0;
        else if (n < 0) return -1; else return 1;
    },

    move : $(p0, p1)
    {
        if (p1.V == 0)
            return;

        // time
        var l = Interpolator.Point.distance(p0, p1);
        var t = l / p1.V;
        if (t == 0)
            return;

        // current position
        var cX = axisX1.getPosition();
        var cY = axisY.getPosition();
        var cZ = axisZ.getPosition();

        // delta
        var dX = p1.X - cX;
        var dY = p1.Y - cY;
        var dZ = p1.Z - cZ;

        // speed for each axis
        var vX = dX / t;
        var vY = dY / t;
        var vZ = dZ / t;

        // set 
        if (axisX2)
        {
            axisX1.setTargetPosition(p1.X, vX);
            axisX2.setTargetPosition(-p1.X, -vX);
            axisY.setTargetPosition(p1.Y, vY);
            axisZ.setTargetPosition(p1.Z, vZ);

            while(!(axisX1.onPosition() && axisX2.onPosition() && axisY.onPosition() && axisZ.onPosition))
                ;
        }
        else
        {
            axisX1.setTargetPosition(p1.X, vX);
            axisY.setTargetPosition(p1.Y, vY);
            axisZ.setTargetPosition(p1.Z, vZ);

            while(!(axisX1.onPosition() && axisY.onPosition() && axisZ.onPosition))
                ;
        }
    },

    run : $(p0, trajectory, callback)
    {
        for (var k = 0, kl = trajectory.length(); k < kl; k++)
        {
            var p1 = trajectory[k];
            if (callback)
                callback(p1);
            positioning.move(p0, p1);
            p0 = p1;
        }
    }
};
