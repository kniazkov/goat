<goat>
    <v value="0.5 &quot;Overdrive&quot;"/>
    <s name="Introduction">
        <p><b>Goat</b> is a high-level, dynamic, weakly typed, prototype-based, multi-paradigm, and interpreted programming language, based mostly on JavaScript syntax. It supports the basic functionality of JavaScript, but besides, it adds support for multithreading, multiple inheritance, operator overloading (like in C ++), has simplified and expanded syntax and data model, and so on.</p>
        <p>Why "Goat"? I was bitten by a goat. Indeed. This is how it was: really, it’s very difficult to come up with a good language name. The name should be short and memorable, for example, "Go" (but "Go" is occupied). So, one spring morning I was lying in a hammock, programming on a laptop and eating an apple. It was a wonderful day, beautiful weather, birds were singing, and then suddenly <url title="my goat">this_one.jpg</url> bit me. "Oh, you sweet little prankster", I thought (no no, actually I said another thing). I dropped my laptop and at this time the goat stole my apple. Then I thought perhaps the name "Goat" is not bad too. So I renamed the project folder to this name and since then it has not changed.</p>
    </s>
    
    <s name="Where to download the latest release">
        <p>On GitHub: <url>https://github.com/kniazkov/goat/releases/latest</url>.</p>
    </s>
    
    <s name="How to launch Goat script">
        <s name="Quick start">
            <p>Just download the executable file, open console, type executable name and specify a script file name as a parameter:</p>
            <c>goat.exe program.goat</c>
            <p>For UNIX-like systems, executable name is <c>goat</c>, without <c>.exe</c> extension:</p>
            <c>./goat program.goat</c>
        </s>
        <s name="Command line options">
            <p>The Goat interpreter parses command line arguments as follows. All arguments started with two hyphens are internal parameters of the interpreter ("options"). The first argument which is not an option is the name of the script file. All next arguments are send to the script.</p>
            <p>For example,</p>
            <c>goat.exe --lib=../lib program.goat arg1 arg2</c>
            <p>or, the same thing:</p>
            <c>goat.exe program.goat --lib=../lib arg1 arg2</c>
            <p>or:</p>
            <c>goat.exe program.goat arg1 arg2 --lib=../lib</c>
            <p>where: <c>goat.exe</c> is Goat executable, <c>program.goat</c> is name of the script, <c>--lib=../lib</c> is option of the interpreter, <c>arg1</c> and <c>arg2</c> are arguments of the script.</p>
            <p>Here is a short list of interpreter options. All options are described in the <link title="Appendix">Full list of command line options</link> section.</p>
            <h name="--lib">
                <p>Path (paths) to external libraries (to importable files). For example, a path to the Goat standard library. Several paths can be separated by a semicolon.</p>
                <c>goat.exe program.goat --lib=c:\goat\lib;c:\project</c>
                <p>Note about path delimiting character, this is most commonly the slash ("/") or the backslash  ("\"). While the interpreter parsed paths, it changes delimiting characters to the character used in the current platform. Say, for Windows, all delimiter characters replaced to the backslash, and for Linux (Unix) - to slash. So path <c>--lib=..\folder\lib</c> interpreted as well as path <c>--lib=../folder/lib</c>, for all platforms.</p>
            </h>
            <h name="--language= or --lang=">
                <p>Set language for compiler output messages. Supported languages are:</p>
                <l>
                    <i>english (en) - default</i>
                    <i>russian (ru)</i>
                </l>
                <p>Example. If the interpreter finds an error in the script, the error message will be displayed in Russian:</p>
                <c><![CDATA[
                    program.goat (contains an error "Unknown character"):
                        
                        println(`Hello world`);
                        
                    Command line:
                        
                        ./goat program.goat --lang=ru
                        
                    Output:
                    
                        println(`Hello world`);
                                ^
                        program.goat, 1.9: неизвестный символ '`'
                    ]]>
                </c>
            </h>
            <h name="--debug">
                <p>After starting, you switch to debug mode, where you can add breakpoints and execute the program line by line. This mode is described in the <link>Step-by-step debugging</link> section.</p>
                <p>Example:</p>
                <c>goat.exe program.goat --debug</c>
            </h>
            <h name="--compile">
                <p>Compile the script into bytecode, but do not execute it.</p>
                <p>Example:</p>
                <c>goat.exe program.goat --compile</c>
                <p>As a result, a binary file <c>program.goat.bin</c> will be written.</p>
            </h>
            <h name="--bin">
                <p>Run a previously compiled script.</p>
                <p>Example:</p>
                <c>goat.exe --bin program.goat.bin</c>
                <p>Since the compilation procedure was performed earlier, loading prepared bytecode is faster. This will reduce the overall program execution time.</p>
            </h>
        </s>
    </s>
    
    <s name="Basics">
        <p><b>Important note. A significant part of this chapter is the redesigned tutorial from: <url>https://www.w3schools.com/js/default.asp</url>. Since the Goat language is the modified JavaScript language, so the description of the Goat language is the modified description of the  Javascript language. Any coincidences are NOT random.</b></p>
        <s name="Hello world">
            <p>Create a new file, say <c>hello_world.goat</c> (file extension does not matter) containing one line:</p>
            <c>print(&quot;Hello, world!&quot;);</c>
            <p>and then launch it:</p>
            <c>goat.exe hello_world.goat</c>
            <p>That's all. The interpreter will start the script and will print <c>Hello, world!</c> to the console.</p>
        </s>
        <s name="Internationalization and localization">
            <p>It is possible to use any Unicode characters in string literals. The Goat interpreter parses source files in UTF-8  format. The output stream also encoded to UTF-8. The previous example, but contains nonlatin characters:</p>
            <c>print(&quot;Привет, мир!&quot;);</c>
        </s>
        <s name="Program and statements">
            <s name="Program">
                <p>A computer program is a list of "instructions" to be "executed" by a computer. In a programming language, these programming instructions are called <b>statements.</b></p>
                <p>A <b>Goat program is a list of</b> programming <b>statements.</b></p>
                <c><![CDATA[
                    var x, a, b; // statement 1
                    a = 2; // statement 2
                    b = 3; //       ... 3
                    x = a + b; //       ... 4
                    print(x); //       ... 5]]>
                </c>
                <p>Goat programs are executed by the Goat interpreter.</p>
            </s>
            <s name="Statements">
                <p>Goat statements are composed of: <b>Values</b>, <b>Operators</b>, <b>Expressions</b>, <b>Keywords</b>, and <b>Comments</b>.</p>
                <p>The statements are executed, one by one, in the same order as they are written.</p>
            </s>
            <s name="Semicolons">
                <p>Semicolons <c>;</c> separate Goat statements. Add a semicolon at the end of each executable statement:</p>
                <c><![CDATA[
                    var x, a, b; // declare 3 variables
                    a = 2; // assign the value 2 to 'a'
                    b = 3; // assign the value 6 to 'b'
                    x = a + b; // assign the sum of 'a' and 'b' to 'x'
                    print(x); // print value of 'x']]>
                </c>
                <p>When separated by semicolons, multiple statements on one line are allowed:</p>
                <c>a = 2; b = 3; x = a + b;</c>
                <p>Though ending statements with a semicolon is not required, but highly recommended. This example is correct:</p>
                <c>print(2 + 3) // no semicolon at the end</c>
            </s>
            <s name="White space">
                <p>Goat parse tabulations and line breaks as white spaces. Goat ignores multiple spaces. You can add white space to your script to make it more readable. The following statements are equivalent:</p>
                <c><![CDATA[
                    var a, b = 0;
                    var a, b=0;
                    var a,
                        b = 0;]]>
                </c>
            </s>
            <s name="Code blocks">
                <p>Goat statements can be grouped together in code blocks, inside curly brackets <c>{...}</c>. The purpose of code blocks is to define statements to be executed together. One place you will find statements grouped together in blocks, is in Goat functions:</p>
                <c><![CDATA[
                    var f = $(a, b)
                    {
                        var x;
                        var y;
                        x = a + b;
                        y = a - b;
                        print("summ: " + x + ", diff: " + y);
                    };]]>
                </c>
            </s>
            <s name="Keywords and keyword sequences">
                <p>Goat statements often start with a keyword to identify the Goat action to be performed. Here is a list of the keywords (or keyword sequences):</p>
                <t>
                    <h>
                        <c width="180">Keyword</c>
                        <c>Description</c>
                    </h>
                    <r>
                        <c><c>var</c></c>
                        <c>Declares a variable</c>
                    </r>
                    <r>
                        <c><c>function</c> or <c>$</c></c>
                        <c>Declares a function (method)</c>
                    </r>
                    <r>
                        <c><c>thread</c></c>
                        <c>Declares a thread</c>
                    </r>
                    <r>
                        <c><c>lock</c></c>
                        <c>Declares a critical section</c>
                    </r>
                    <r>
                        <c><c>return</c></c>
                        <c>Exits a function (method)</c>
                    </r>
                    <r>
                        <c><c>if</c>..<c>else if</c>..<c>else</c></c>
                        <c>Marks a block of statements to be executed, depending on a condition</c>
                    </r>
                    <r>
                        <c><c>switch</c>(<c>case</c>, <c>default)</c></c>
                        <c>Marks a block of statements to be executed, depending on different cases</c>
                    </r>
                    <r>
                        <c><c>for</c>(<c>in</c>)</c>
                        <c>Marks a block of statements to be executed, as long as a condition is true</c>
                    </r>
                    <r>
                        <c><c>while</c>, <c>do</c>..<c>while</c></c>
                        <c>Executes a block of statements, and repeats the block, while a condition is true</c>
                    </r>
                    <r>
                        <c><c>break</c></c>
                        <c>Terminates a switch or a loop</c>
                    </r>
                    <r>
                        <c><c>continue</c></c>
                        <c>Jumps out of a loop and starts at the top</c>
                    </r>
                    <r>
                        <c><c>try</c>..<c>catch</c>..<c>finally</c></c>
                        <c>Implements error handling to a block of statements</c>
                    </r>
                    <r>
                        <c><c>throw</c></c>
                        <c>Throws an exception</c>
                    </r>
                    <r>
                        <c><c>new</c></c>
                        <c>Creates a new object</c>
                    </r>
                    <r>
                        <c><c>import</c></c>
                        <c>Imports a source file</c>
                    </r>
                    <r>
                        <c><c>debug</c></c>
                        <c>Stops the execution of Goat script, and switch the interpreter to debug (step-by-step) mode</c>
                    </r>
                </t>
                <p>Goat keywords are reserved words. Reserved words cannot be used as names for variables.</p>
            </s>
        </s>
        <s name="Syntax">
            <p>Goat syntax is the set of rules, how Goat programs are constructed:</p>
            <c><![CDATA[
                var a, b, x; // How to declare variables
                a = 2; // How to assign values
                b = 3;
                x = a + b; // How to compute values
                print(x); // How to call functions
            ]]>
            </c>
            <s name="Values">
                <p>The Goat syntax defines two types of values: fixed values and variable values. Fixed values are called <b>literals.</b> Variable values are called <b>variables.</b></p>
                <s name="Literals">
                    <p>The most important rules for writing fixed values are:</p>
                    <p><b>Integer numbers</b> are written without decimals:</p>
                    <c>123</c>
                    <p><b>Real numbers</b> are written with decimals, the decimal separator is a dot:</p>
                    <c>0.001</c>
                    <p><b>Strings</b> are text, written within double quotes:</p>
                    <c>"Hello"</c>
                    <p><b>Chars</b> are symbols written within single quotes:</p>
                    <c>'A'</c>
                </s>
                <s name="Variables">
                    <p>In a programming language, variables are used to store data values. Goat uses the <c>var</c> keyword to <b>declare</b> variables. An <b>equal sign</b> is used to <b>assign</b> values to variables.</p>
                    <p>In this example, <c>x</c> is defined as a variable. Then, <c>x</c> is assigned (given) the value 10:</p>
                    <c><![CDATA[
                        var x;
                        x = 10;]]>
                    </c>
                </s>
            </s>
            <s name="Operators">
                <p>Goat uses <b>arithmetic operators</b> ( <c>+ - *  /</c> ) to <b>compute</b> values:</p>
                <c>(5 + 6) * 10</c>
                <p>Goat uses an <b>assignment operator</b> ( = ) to <b>assign</b> values to variables:</p>
                <c><![CDATA[
                    var a, b;
                    a = 2;
                    b = 3;]]>
                </c>
            </s>
            <s name="Expressions">
                <p>An <b>expression</b> is a combination of literals, variables, function calls, other expression and operators, which computes to a value. The computation is called an evaluation. For example, 5 * 10 evaluates to 50:</p>
                <c>5 * 10</c>
                <p>Expressions can also contain variable values:</p>
                <c>x * 2</c>
                <p>...or function calls:</p>
                <c>x * sin(y)</c>
                <p>The values can be of various types, such as numbers and strings:</p>
                <c>"Hello" + ", " + "world"</c>
            </s>
            <s name="Identifiers">
                <p><b>Identifiers</b> are names.</p>
                <p>In Goat, identifiers are used to name variables. The rules for legal names are much the same in most programming languages. In Goat, the first character must be a letter or an underscore (<c>_</c>). Subsequent characters may be letters, digits or underscores. Numbers are not allowed as the first character.</p>
            </s>
            <s name="Case sensitive">
                <p>All Goat identifiers are case sensitive. The variables <c>maxValue</c> and <c>maxvalue</c>, are two different variables.</p>
                <c><![CDATA[
                    var maxValue, maxvalue;
                    maxValue = 10;
                    maxvalue = 0.1;]]>
                </c>
            </s>
        </s>
        <s name="Comments">
            <p>Goat comments can be used to explain Goat code, and to make it more readable. Goat comments can also be used to prevent execution when testing alternative code.</p>
            <s name="Single line comments">
                <p>Single line comments start with <c>//</c>. Any text between <c>//</c> and the end of the line will be ignored by Goat (will not be executed). This example uses a single-line comment before each code line:</p>
                <c><![CDATA[
                    // Create object:
                    var obj = {};
                    // Add a field to the object:
                    obj.value = 10; ]]>
                </c>
                <p>This example uses a single line comment at the end of each line to explain the code:</p>
                <c><![CDATA[
                    var x = 5; // Declare x, give it the value of 5
                    var y = x + 2;  // Declare y, give it the value of x + 2]]>
                </c>
            </s>
            <s name="Multi-line comments">
                <p>Multi-line comments start with <c>/*</c> and end with <c>*/</c>. Any text between <c>/*</c> and <c>*/</c> will be ignored by Goat. This example uses a multi-line comment (a comment block) to explain the code:</p>
                <c><![CDATA[
                    /*
                    The code below declares the function which calculates
                    and print sum and difference of two arguments
                    */
                    var f = $(a, b)
                    {
                        var x;
                        var y;
                        x = a + b;
                        y = a - b;
                        print("summ: " + x + ", diff: " + y);
                    };]]>
                </c>
            </s>
            <s name="Using comments to prevent execution">
                <p>Using comments to prevent execution of code is suitable for code testing. Adding <c>//</c> in front of a code line changes the code lines from an executable line to a comment. This example uses <c>//</c> to prevent execution of one of the code lines:</p>
                <c><![CDATA[
                    var person = {};
                    person.name = "Ivan";
                    //person.gender = "Male";
                    person.age = 33;]]>
                </c>
                <p>This example uses a comment block to prevent execution of multiple lines:</p>
                <c><![CDATA[
                    var person = {};
                    person.name = "Ivan";
                    /*
                    person.gender = "Male";
                    person.age = 33;
                    */]]>                    
                </c>
            </s>
        </s>
        <s name="Variables">
            <p>Goat <b>variables</b> are containers for storing data values. In this example, <c>x</c>, <c>y</c>, and <c>z</c>, are variables:</p>
            <c><![CDATA[
                var x = 5;
                var y = 6;
                var z = x + y;]]>                    
            </c>
            <s name="Identifiers">
                <p>All Goat variables must be identified with unique names. These unique names are called <b>identifiers.</b> Identifiers can be short names (like <c>x</c> and <c>y</c>) or more descriptive names (<c>age</c>, <c>sum</c>, <c>totalVolume</c>). The general rules for constructing names for variables (unique identifiers) are:</p>
                <l>
                    <i>names can contain letters, digits and underscores;</i>
                    <i>names must begin with a letter;</i>
                    <i>names can also begin with <c>_</c>;</i>
                    <i>names are case sensitive (<c>y</c> and <c>Y</c> are different variables);</i>
                    <i>reserved words (like Goat keywords) cannot be used as names.</i>
                </l>
            </s>
            <s name="Data types">
                <p>Goat can handle many types of data. Goat variables can hold numbers like 100 and text values like "Hello". Basic data types are:</p>
                <p><b>Integer</b> number (without decimal character):</p>
                <c>var i = 10;</c>
                <p><b>Real</b> (floating-point) number:</p>
                <c>var r = 0.01;</c>
                <p><b>String:</b></p>
                <c>var s = "Hello";</c>
                <p><b>Char</b>(single symbol):</p>
                <c>var c = 'A';</c>
                <p>And <b>Boolean:</b></p>
                <c>var b = true;</c>
            </s>
            <s name="Declaring (creating) Goat variables">
                <p>Creating a variable in Goat is called "declaring" a variable. You declare a JavaScript variable with the <c>var</c> keyword:</p>
                <c>var name;</c>
                <p>After the declaration, the variable has no value (technically it has the value of <c>undefined</c>). To assign a value to the variable, use the equal sign:</p>
                <c>name = "Ivan";</c>
                <p>You can also assign a value to the variable when you declare it:</p>
                <c>var name = "Ivan";</c>
            </s>
            <s name="One statement, many variables">
                <p>You can declare many variables in one statement. Start the statement with <c>var</c> and separate the variables by comma:</p>
                <c>var name = "Ivan", age = 33, gender = "male";</c>
                <p>A declaration can span multiple lines:</p>
                <c><![CDATA[
                    var name = "Ivan",
                        age = 33,
                        gender = "male";]]>
                </c>
            </s>
            <s name="Undefined">
                <p>Variables are often declared without a value. The value can be something that has to be calculated, or something that will be provided later, like user input. A variable declared without a value will have the value <c>undefined</c>.</p>
                <c>var name; // value of 'name' is undefined</c>
            </s>
            <s name="Re-declaring variables">
                <p>If you re-declare a Goat variable, it will lose old value.</p>
                <c><![CDATA[
                    var name = "Ivan";
                    // do something...
                    var name; // now, value of 'name' if undefined]]>
                </c>
            </s>
            <s name="Arithmetic">
                <p>As with algebra, you can do arithmetic with Goat variables, using operators like <c>=</c> and <c>+</c>:</p>
                <c>var x = 5 + 2 + 3;</c>
                <p>You can also add strings, but strings will be concatenated:</p>
                <c>var s = "Hello" + ", " + "world!"</c>
                <p>Also try this. The Goat language will convert second operator to string if the first operator is string:</p>
                <c>var s = "Value is" + ' ' + 5;</c>
            </s>
        </s>
        <s name="Operators">
            <s name="Examples">
                <p>The <b>assignment</b> operator (<c>=</c>) assigns a value to a variable.</p>
                <c>var x = 10;</c>
                <p>The <b>addition</b> operator (<c>+</c>) adds numbers:</p>
                <c><![CDATA[
                    var a = 2;
                    var b = 3;
                    var c = a + b;]]>
                </c>
                <p>The <b>multiplication</b> operator (<c>*</c>) multiplies numbers.</p>
                <c><![CDATA[
                    var a = 2;
                    var b = 3;
                    var c = a * b;]]>
                </c>
            </s>
            <s name="Arithmetic operators">
                <p>Arithmetic operators are used to perform arithmetic on numbers:</p>
                <t>
                    <h>
                        <c width="100">Operator</c>
                        <c>Description</c>
                    </h>
                    <r>
                        <c><c>+</c></c>
                        <c>Addition</c>
                    </r>
                    <r>
                        <c><c>-</c></c>
                        <c>Subtraction</c>
                    </r>
                    <r>
                        <c><c>*</c></c>
                        <c>Multiplication</c>
                    </r>
                    <r>
                        <c><c>/</c></c>
                        <c>Division</c>
                    </r>
                    <r>
                        <c><c>%</c></c>
                        <c>Modulus (remainder)</c>
                    </r>
                    <r>
                        <c><c>++</c></c>
                        <c>Increment</c>
                    </r>
                    <r>
                        <c><c>--</c></c>
                        <c>Decrement</c>
                    </r>
                </t>
            </s>
            <s name="Assignment operators">
                <p>Assignment operators assign values to Goat variables. </p>
                <t>
                    <h>
                        <c width="100">Operator</c>
                        <c width="100">Example</c>
                        <c>Same as</c>
                    </h>
                    <r>
                        <c><c>=</c></c>
                        <c><c>x = y</c></c>
                        <c></c>
                    </r>
                    <r>
                        <c><c>+=</c></c>
                        <c><c>x += y</c></c>
                        <c><c>x = x + y</c></c>
                    </r>
                    <r>
                        <c><c>-=</c></c>
                        <c><c>x -= y</c></c>
                        <c><c>x = x - y</c></c>
                    </r>
                    <r>
                        <c><c>*=</c></c>
                        <c><c>x *= y</c></c>
                        <c><c>x = x * y</c></c>
                    </r>
                    <r>
                        <c><c>/=</c></c>
                        <c><c>x /= y</c></c>
                        <c><c>x = x / y</c></c>
                    </r>
                    <r>
                        <c><c>%=</c></c>
                        <c><c>x %= y</c></c>
                        <c><c>x = x % y</c></c>
                    </r>
                </t>
                <p>The <b>addition assignment</b> operator (<c>+=</c>) adds a value to a variable.</p>
                <c><![CDATA[
                    var x = 10;
                    x += 5;]]>
                </c>
                <p>Value of <c>x</c> will be: <c>15</c></p>
            </s>
            <s name="String operators">
                <p>The <c>+</c> and <c>+=</c> operators can also be used to add (concatenate) strings.</p>
                <c><![CDATA[
                    var a = "Hello";
                    var b = "world";
                    var s = a + ", " + b;]]>
                </c>
                <p>Value of <c>s</c> will be: <c>Hello, world!</c></p>
            </s>
            <s name="Adding strings and not-strings">
                <p>Adding two numbers, will return the sum, but adding a string and a not-string (number, symbol etc) will return a string:</p>
                <c><![CDATA[
                    var x = 2 + 3;
                    var s = "result is: " + x;]]>
                </c>
                <p>Value of <c>s</c> will be: <c>result is: 5</c></p>
            </s>
            <s name="Comparison operators">
                <t>
                    <h>
                        <c width="100">Operator</c>
                        <c>Description</c>
                    </h>
                    <r>
                        <c><c>==</c></c>
                        <c>Equal to</c>
                    </r>
                    <r>
                        <c><c>!=</c></c>
                        <c>Not equal</c>
                    </r>
                    <r>
                        <c><c>&gt;</c></c>
                        <c>Greater than</c>
                    </r>
                    <r>
                        <c><c>&lt;</c></c>
                        <c>Less than</c>
                    </r>
                    <r>
                        <c><c>&gt;=</c></c>
                        <c>Greater than or equal to</c>
                    </r>
                    <r>
                        <c><c>&lt;=</c></c>
                        <c>Less than or equal to</c>
                    </r>
                    <r>
                        <c><c>?</c></c>
                        <c>Ternary operator</c>
                    </r>
                </t>
            </s>
            <s name="Logical operators">
                <p>These logical operators work only with binary (<c>Boolean</c>) type:</p>
                <t>
                    <h>
                        <c width="100">Operator</c>
                        <c>Description</c>
                    </h>
                    <r>
                        <c><c>&amp;&amp;</c></c>
                        <c>Logical and</c>
                    </r>
                    <r>
                        <c><c>||</c></c>
                        <c>Logical or</c>
                    </r>
                </t>
                <p>These logical operators work with all types:</p>
                <t>
                    <h>
                        <c width="100">Operator</c>
                        <c>Description</c>
                    </h>
                    <r>
                        <c><c>!</c></c>
                        <c>Logical not</c>
                    </r>
                    <r>
                        <c><c>!!</c></c>
                        <c>Logical double not</c>
                    </r>
                </t>
            </s>
            <s name="Bitwise operators">
                <p>Bitwise operators work with <c>Integer</c> type.</p>
                <t>
                    <h>
                        <c width="100">Operator</c>
                        <c>Description</c>
                        <c>Example</c>
                        <c>Same as</c>
                        <c>Result</c>
                        <c>Decimal</c>
                    </h>
                    <r>
                        <c><c>&amp;</c></c>
                        <c>And</c>
                        <c><c>5 &amp; 1</c></c>
                        <c><c>0101 &amp; 0001</c></c>
                        <c><c>0001</c></c>
                        <c><c>1</c></c>
                    </r>
                    <r>
                        <c><c>|</c></c>
                        <c>Or</c>
                        <c><c>5 | 1</c></c>
                        <c><c>0101 | 0001</c></c>
                        <c><c>0101</c></c>
                        <c><c>5</c></c>
                    </r>
                    <r>
                        <c><c>~</c></c>
                        <c>Not</c>
                        <c><c>~5</c></c>
                        <c><c>~0101</c></c>
                        <c><c>...111010</c></c>
                        <c><c>-6</c></c>
                    </r>
                    <r>
                        <c><c>^</c></c>
                        <c>Xor</c>
                        <c><c>5 ^ 1</c></c>
                        <c><c>0101 ^ 0001</c></c>
                        <c><c>0100</c></c>
                        <c><c>4</c></c>
                    </r>
                    <r>
                        <c><c>&lt;&lt;</c></c>
                        <c>Left shift</c>
                        <c><c>5 &lt;&lt; 1</c></c>
                        <c><c>0101 &lt;&lt; 1</c></c>
                        <c><c>1010</c></c>
                        <c><c>10</c></c>
                    </r>
                    <r>
                        <c><c>&gt;&gt;</c></c>
                        <c>Signed right shift</c>
                        <c><c>5 &gt;&gt; 1</c></c>
                        <c><c>0101 &gt;&gt; 1</c></c>
                        <c><c>0010</c></c>
                        <c><c>2</c></c>
                    </r>
                    <r>
                        <c><c>&gt;&gt;&gt;</c></c>
                        <c>Zero fill right shift</c>
                        <c><c>5 &gt;&gt;&gt; 1</c></c>
                        <c><c>0101 &gt;&gt;&gt; 1</c></c>
                        <c><c>0010</c></c>
                        <c><c>2</c></c>
                    </r>
                </t>
            </s>
            <s name="Special operators">
                <t>
                    <h>
                        <c width="100">Operator</c>
                        <c>Description</c>
                    </h>
                    <r>
                        <c><c>-&gt;</c></c>
                        <c>Inherit</c>
                    </r>
                    <r>
                        <c><c>#</c></c>
                        <c>Write protect</c>
                    </r>
                </t>
            </s>
            <s name="Common operators">
                <p>Each object supports these operators: <c>-&gt;</c> (inherit), <c>#</c> (write protect), <c>==</c> (equal), <c>!=</c> (not equal) and <c>!</c> (logical not).</p>
                <h name="-&gt; (inherit)">
                    <p>Each object can be a prototype for a new object. Below in this document, it will be explained what is prototyping.</p>
                </h>
                <h name="# (write protect)">
                    <p>Returns a write protected object, that is, an object whose properties can not be changed.</p>
                </h>
                <h name="== (equal) and != (not equal)">
                    <p>In common case, an object equals to another object, if these objects are the same object. For numbers, strings, other built-in types, an object is equal to another object if these objects have the same value, for example, <c>5 == 2 + 3</c>.</p>
                </h>
                <h name="! (not)">
                    <p>In common case, <c>not</c> object is <c>false</c>. The chapters about the comparison and conditions will describe how this is used.</p>
                </h>
                <h name="!! (double not)">
                    <p>Double negation is used to cast any object to <c>Boolean</c> type.</p>
                </h>
            </s>
        </s>
        <s name="Arithmetic">
            <s name="Arithmetic Operations">
                <p>A typical arithmetic operation operates on two numbers. The two numbers can be literals:</p>
                <c>var x = 100 + 50;</c>
                <p>or variables:</p>
                <c>var x = a + b;</c>
                <p>or expressions:</p>
                <c>var x = (100 + 50) * a;</c>
            </s>
            <s name="Operators and operands">
                <p>The numbers (in an arithmetic operation) are called <b>operands.</b></p>
                <p>The operation (to be performed between the two operands) is defined by an <b>operator.</b></p>
                <t>
                    <h>
                        <c width="100">Operand</c>
                        <c width="100">Operator</c>
                        <c>Operand</c>
                    </h>
                    <r>
                        <c>100</c>
                        <c>+</c>
                        <c>50</c>
                    </r>
                </t>
                <p>If at least one of the operators is a real number, the result will be a real number. If both operators are integers, the result will be an integer.</p>
                <p>The <b>addition</b> operator (<c>+</c>) adds numbers.</p>
                <c><![CDATA[
                    var a = 2;
                    var b = 3;
                    var c = a + b; // 5]]>
                </c>
                <p>The <b>subtraction </b> operator (<c>-</c>) subtracts  numbers.</p>
                <c><![CDATA[
                    var a = 2;
                    var b = 3;
                    var c = a - b; // -1]]>
                </c>
                <p>The <b>multiplication</b> operator (<c>*</c>) multiplies numbers.</p>
                <c><![CDATA[
                    var a = 2;
                    var b = 3;
                    var c = a * b; // 6]]>
                </c>
                <p>The <b>division</b> operator (<c>/</c>) divides  numbers.</p>
                <c><![CDATA[
                    var a = 6;
                    var b = 2;
                    var c = a / b; // 3]]>
                </c>
                <p>If at least one of operators is a real number, the Goat interpreter performs real division (for example, <c>6.0 / 4 = 1.5</c>). If both operators are integers, the interpreter performs integer division, i.e. the fractional part of the result will be lost (<c>6 / 4 = 1</c>).</p>
                <p>The <b>modular</b> operator (<c>%</c>) returns the division remainder.</p>
                <c><![CDATA[
                    var a = 17;
                    var b = 10;
                    var c = a % b; // 7]]>
                </c>
                <p>The <b>increment </b> operator (<c>++</c>) increments numbers.</p>
                <c><![CDATA[
                    var a = 2;
                    a++; // 3]]>
                </c>
                <p>The <b>decrement</b> operator (<c>--</c>) decrements numbers.</p>
                <c><![CDATA[
                    var a = 2;
                    a--; // 1]]>
                </c>
            </s>
            <s name="Operator precedence">
                <p>Operator precedence describes the order in which operations are performed in an arithmetic expression.</p>
                <c>var x = 100 + 50 * 3;</c>
                <p>As in traditional mathematics, the multiplication is done first. Multiplication (<c>*</c>) and division (<c>/</c>) have higher <b>precedence</b> than addition (<c>+</c>) and subtraction (<c>-</c>).</p>
                <p>The precedence can be changed by using parentheses:</p>
                <c>var x = (100 + 50) * 3;</c>
                <p>When using parentheses, the operations inside the parentheses are computed first.</p>
                <p>When many operations have the same precedence (like addition and subtraction), they are computed from left to right:</p>
                <c>var x = 100 + 50 - 3;</c>
            </s>
            <s name="Operator precedence values">
                <t>
                    <h>
                        <c width="100">Value</c>
                        <c width="100">Operator</c>
                        <c>Description</c>
                        <c>Example</c>
                    </h>
                    <r>
                        <c>21</c>
                        <c><c>()</c></c>
                        <c>Expression grouping</c>
                        <c><c>(3 + 4)</c></c>
                    </r>
                    <r>
                        <c>20</c>
                        <c><c>.</c></c>
                        <c>Member</c>
                        <c><c>person.name</c></c>
                    </r>
                    <r>
                        <c>20</c>
                        <c><c>[]</c></c>
                        <c>Member</c>
                        <c><c>person["name"]</c></c>
                    </r>
                    <r>
                        <c>20</c>
                        <c><c>?.</c></c>
                        <c>Member with void guard</c>
                        <c><c>person?.name</c></c>
                    </r>
                    <r>
                        <c>19</c>
                        <c><c>()</c></c>
                        <c>Function call</c>
                        <c><c>func()</c></c>
                    </r>
                    <r>
                        <c>19</c>
                        <c><c>new</c></c>
                        <c>Create</c>
                        <c><c>new StringBuilder()</c></c>
                    </r>
                    <r>
                        <c>18</c>
                        <c><c>++</c></c>
                        <c>Prefix increment</c>
                        <c><c>++x</c></c>
                    </r>
                    <r>
                        <c>18</c>
                        <c><c>--</c></c>
                        <c>Prefix decrement</c>
                        <c><c>--x</c></c>
                    </r>
                    <r>
                        <c>17</c>
                        <c><c>++</c></c>
                        <c>Postfix increment</c>
                        <c><c>x++</c></c>
                    </r>
                    <r>
                        <c>17</c>
                        <c><c>--</c></c>
                        <c>Postfix decrement</c>
                        <c><c>x--</c></c>
                    </r>
                    <r>
                        <c>16</c>
                        <c><c>!</c></c>
                        <c>Logical not</c>
                        <c><c>!x</c></c>
                    </r>
                    <r>
                        <c>16</c>
                        <c><c>!!</c></c>
                        <c>Logical double not</c>
                        <c><c>!!x</c></c>
                    </r>
                    <r>
                        <c>16</c>
                        <c><c>~</c></c>
                        <c>Bitwise not</c>
                        <c><c>~x</c></c>
                    </r>
                    <r>
                        <c>15</c>
                        <c><c>+</c></c>
                        <c>Unary plus</c>
                        <c><c>+x</c></c>
                    </r>
                    <r>
                        <c>15</c>
                        <c><c>-</c></c>
                        <c>Unary minus</c>
                        <c><c>-x</c></c>
                    </r>
                    <r>
                        <c>14</c>
                        <c><c>-&gt;</c></c>
                        <c>Inherit</c>
                        <c><c>A -&gt; { }</c></c>
                    </r>
                    <r>
                        <c>13</c>
                        <c><c>#</c></c>
                        <c>Write protect</c>
                        <c><c># { }</c></c>
                    </r>
                    <r>
                        <c>12</c>
                        <c><c>*</c></c>
                        <c>Multiplication</c>
                        <c><c>10 * 5</c></c>
                    </r>
                    <r>
                        <c>12</c>
                        <c><c>/</c></c>
                        <c>Division</c>
                        <c><c>10 / 5</c></c>
                    </r>
                    <r>
                        <c>12</c>
                        <c><c>%</c></c>
                        <c>Modulo (remainder)</c>
                        <c><c>17 % 10</c></c>
                    </r>
                    <r>
                        <c>11</c>
                        <c><c>+</c></c>
                        <c>Addition</c>
                        <c><c>2 + 3</c></c>
                    </r>
                    <r>
                        <c>11</c>
                        <c><c>-</c></c>
                        <c>Subtraction</c>
                        <c><c>5 - 2</c></c>
                    </r>
                    <r>
                        <c>10</c>
                        <c><c>&lt;&lt;</c></c>
                        <c>Shift left</c>
                        <c><c>x &lt;&lt; 2</c></c>
                    </r>
                    <r>
                        <c>10</c>
                        <c><c>&gt;&gt;</c></c>
                        <c>Shift right</c>
                        <c><c>x &gt;&gt; 2</c></c>
                    </r>
                    <r>
                        <c>10</c>
                        <c><c>&gt;&gt;&gt;</c></c>
                        <c>Shift right (unsigned)</c>
                        <c><c>x &gt;&gt;&gt; 2</c></c>
                    </r>
                    <r>
                        <c>9</c>
                        <c><c>&amp;</c></c>
                        <c>Bitwise and</c>
                        <c><c>x &amp; y</c></c>
                    </r>
                    <r>
                        <c>8</c>
                        <c><c>^</c></c>
                        <c>Bitwise xor</c>
                        <c><c>x ^ y</c></c>
                    </r>
                    <r>
                        <c>7</c>
                        <c><c>|</c></c>
                        <c>Bitwise or</c>
                        <c><c>x | y</c></c>
                    </r>
                    <r>
                        <c>6</c>
                        <c><c>&lt;</c></c>
                        <c>Less than</c>
                        <c><c>x &lt; y</c></c>
                    </r>
                    <r>
                        <c>6</c>
                        <c><c>&lt;=</c></c>
                        <c>Less than or equal</c>
                        <c><c>x &lt;= y</c></c>
                    </r>
                    <r>
                        <c>6</c>
                        <c><c>&gt;</c></c>
                        <c>Greater than</c>
                        <c><c>x &gt; y</c></c>
                    </r>
                    <r>
                        <c>6</c>
                        <c><c>&gt;=</c></c>
                        <c>Greater than or equal</c>
                        <c><c>x &gt;= y</c></c>
                    </r>
                    <r>
                        <c>5</c>
                        <c><c>==</c></c>
                        <c>Equal</c>
                        <c><c>x == y</c></c>
                    </r>
                    <r>
                        <c>5</c>
                        <c><c>!=</c></c>
                        <c>Not equal</c>
                        <c><c>x != y</c></c>
                    </r>
                    <r>
                        <c>4</c>
                        <c><c>&amp;&amp;</c></c>
                        <c>Logical and</c>
                        <c><c>x &amp;&amp; y</c></c>
                    </r>
                    <r>
                        <c>3</c>
                        <c><c>||</c></c>
                        <c>Logical or</c>
                        <c><c>x || y</c></c>
                    </r>
                    <r>
                        <c>2</c>
                        <c><c>?</c></c>
                        <c>Ternary operator</c>
                        <c><c>a ? b : c</c></c>
                    </r>
                    <r>
                        <c>1</c>
                        <c><c>=</c></c>
                        <c>Assign</c>
                        <c><c>x = y</c></c>
                    </r>
                    <r>
                        <c>1</c>
                        <c><c>+=</c></c>
                        <c>Assign by</c>
                        <c><c>x += y</c></c>
                    </r>
                    <r>
                        <c>1</c>
                        <c><c>-=</c></c>
                        <c>Assign by</c>
                        <c><c>x -= y</c></c>
                    </r>
                    <r>
                        <c>1</c>
                        <c><c>*=</c></c>
                        <c>Assign by</c>
                        <c><c>x *= y</c></c>
                    </r>
                    <r>
                        <c>1</c>
                        <c><c>/=</c></c>
                        <c>Assign by</c>
                        <c><c>x *= y</c></c>
                    </r>
                    <r>
                        <c>1</c>
                        <c><c>%=</c></c>
                        <c>Assign by</c>
                        <c><c>x %= y</c></c>
                    </r>
                    <r>
                        <c>1</c>
                        <c><c>&lt;&lt;=</c></c>
                        <c>Assign by</c>
                        <c><c>x &lt;&lt;= y</c></c>
                    </r>
                    <r>
                        <c>1</c>
                        <c><c>&gt;&gt;=</c></c>
                        <c>Assign by</c>
                        <c><c>x &gt;&gt;= y</c></c>
                    </r>
                    <r>
                        <c>1</c>
                        <c><c>&gt;&gt;&gt;=</c></c>
                        <c>Assign by</c>
                        <c><c>x &gt;&gt;&gt;= y</c></c>
                    </r>
                    <r>
                        <c>1</c>
                        <c><c>&amp;=</c></c>
                        <c>Assign by</c>
                        <c><c>x &amp;= y</c></c>
                    </r>
                    <r>
                        <c>1</c>
                        <c><c>^=</c></c>
                        <c>Assign by</c>
                        <c><c>x ^= y</c></c>
                    </r>
                    <r>
                        <c>1</c>
                        <c><c>|=</c></c>
                        <c>Assign by</c>
                        <c><c>x |= y</c></c>
                    </r>
                </t>
            </s>
        </s>
        <s name="Assignment">
            <p>The <c>=</c> assignment operator assigns a value to a variable.</p>
            <c>var x = 10; // 10</c>
            <p>The <c>+=</c> assignment operator adds a value to a variable.</p>
            <c><![CDATA[
                var x = 10;
                x += 5; // 15 ]]>
            </c>
            <p>The <c>-=</c> assignment operator subtracts a value from a variable.</p>
            <c><![CDATA[
                var x = 10;
                x -= 5; // 5 ]]>
            </c>
            <p>The <c>*=</c> assignment operator multiplies a variable.</p>
            <c><![CDATA[
                var x = 10;
                x *= 5; // 50 ]]>
            </c>
            <p>The <c>/=</c> assignment operator divides a variable.</p>
            <c><![CDATA[
                var x = 10;
                x /= 5; // 2 ]]>
            </c>
            <p>The <c>%=</c> assignment operator assigns a remainder to a variable.</p>
            <c><![CDATA[
                var x = 17;
                x %= 10; // 7 ]]>
            </c>
        </s>
        <s name="Data types">
            <p>Goat variables can hold many data types: numbers, strings, objects and more:</p>
            <c>    <![CDATA[
                var length = 16; // Integer
                var price = 11.99; // Real
                var name = "Ivan"; // String
                var obj = {name: "Ivan", age: 33}; // Object ]]>
            </c>
            <s name="Concept">
                <p>In programming, data types is an important concept. To be able to operate on variables, it is important to know something about the type.</p>
                <p>For example, when adding a number and a something, the Goat interpreter will treat the second operator as a number:</p>
                <c>var x = 2 + 3; // result is: 5</c>
                <p>But, when adding a string and a something, the Goat interpreter will treat the second operator as a string. If the second operator is not a string, the interpreter will convert it to the string:</p>
                <c>var s = "text" + 123; // result is: "text123"</c>
                <p>The Goat interpreter evaluates expressions from left to right (but according to precedence).  Different sequences can produce different results:</p>
                <c><![CDATA[
                    var s1 = "text" + 2 + 3; // result is: "text23"
                    var s2 = "text" + (2 + 3); // result is: "text5"]]>
                </c>
            </s>
            <s name="Goat types are dynamic">
                <p>The Goat language has dynamic types. This means that the same variable can be used to hold different data types:</p>
                <c><![CDATA[
                    var x; // 'x' is undefined
                    x = 5; // now 'x' is a integer
                    x = "Ivan"; // now 'x' is a string]]>
                </c>
            </s>
            <s name="Strings">
                <p>A string (or a text string) is a series of characters like "Abracadabra". Strings are written with double quotes:</p>
                <c>var name="Ivan";</c>
            </s>
            <s name="Chars">
                <p>Char is a single symbol. Chars are written with single quotes:</p>
                <c>var c = 'A';</c>
            </s>
            <s name="Integers">
                <p>A number without decimal point:</p>
                <c>var i = 10;</c>
            </s>
            <s name="Real numbers">
                <p>A number with decimal point (also, it called "floating-point number"):</p>
                <c>var r = 0.01;</c>
            </s>
            <s name="Booleans">
                <p>Booleans can only have two values: <c>true</c> or <c>false</c>:</p>
                <c><![CDATA[
                    var t = true;
                    var f = false;]]>
                </c>
                <p>Booleans are often used in conditional testing:</p>
                <c><![CDATA[
                    var x = 5;
                    var y = 5;
                    var z = 6;
                    var t = (x == y); // true
                    var f = (x == z); // false]]>
                </c>
            </s>
            <s name="Arrays">
                <p>Goat arrays are written with square brackets. Array items are separated by commas. The following code declares (creates) an array called <c>herd</c>, containing three items (goats nicknames):</p>
                <c>var herd = ["Dirty", "Stinky", "Crazy"];</c>
                <p>Array indexes are zero-based, which means the first item is <c>[0]</c>, second is <c>[1]</c>, and so on.</p>
            </s>
            <s name="Objects">
                <p>Goat objects are written with curly braces. Object properties are written as <c>name: value</c> pairs, separated by commas.</p>
                <c>var goat = { name: "Stinky", wool: Color.WHITE, age: 3}; </c>
            </s>
            <s name="Undefined">
                <p>In the Goat language, a variable without a value, has the value <c>undefined</c>.</p>
                <c>var name; // value is undefined</c>
                <p>Any variable can be emptied, by setting the value to <c>undefined</c>.</p>
                <c>name = undefined;</c>
            </s>
            <s name="Null">
                <p>In the Goat language, <c>null</c> is "nothing". It is supposed to be something that doesn't exist. Any variable can be emptied, by setting the value to <c>null</c>.</p>
                <c>name = null;</c>
            </s>
            <p><c>null</c> is not <c>undefined</c>! <c>null</c> means: it defined, but the value of it is "nothing".</p>
        </s>
        <s name="Functions">
            <p>A Goat function is a block of code designed to perform a particular task. A Goat function is executed when "something" invokes it (calls it).</p>
            <c><![CDATA[
                var myFunction = function(a, b)
                {
                    return a * b; // the function returns the product of 'a' and 'b'
                };]]>
            </c>
            <p>Why Functions? You can reuse code: Define the code once, and use it many times. You can use the same code many times with different arguments, to produce different results.</p>
            <s name="Syntax">
                <p>A Goat function is defined with the <c>function</c> keyword, followed by parentheses (). The parentheses may include parameter names separated by commas: <c>(parameter_1, parameter_2, ...)</c>. The code to be executed, by the function, is placed inside curly brackets: <c>{}</c>. To name a function (for the ability of invocation), the function object needs to be written to a variable:</p>
                <c><![CDATA[
                    var name = function(parameter_1, parameter_2, parameter_3)
                    {
                        //code to be executed
                    };]]>
                </c>
                <p>In the Goat language, the <c>function</c> keyword (it is long and is used very often ) can be changed to a dollar sign <c>$</c>:</p>
                <c><![CDATA[
                    var name = $(parameter_1, parameter_2, parameter_3)
                    {
                        //code to be executed
                    };]]>
                </c>
                <p>Function <b>parameters</b> are listed inside the parentheses <c>()</c> in the function definition. Function <b>arguments</b> are the <b>values</b> received by the function when it is invoked. Inside the function, the arguments (the parameters) behave as local variables.</p>
            </s>
            <s name="Return">
                <p>When the Goat interpreter reaches a <b>return statement</b>, the function will stop executing, then the interpreter will "return" to execute the code after the invoking statement. Functions often compute a return value. The return value is "returned" back to the "caller":</p>
                <c><![CDATA[
                    var myFunction = function(a, b)
                    {
                        return a * b; // the function returns the product of 'a' and 'b'
                    };
                    
                    var x = myFunction(4, 3);]]>
                </c>
                <p>The result in <c>x</c> will be <c>12</c>.</p>
            </s>
            <s name="Invocation">
                <p>The <c>()</c> operator invokes the function.</p>
                <p>To invoke a function without arguments, use empty operator:</p>
                <c><![CDATA[
                    var doSomething = function()
                    {
                        //...
                    };
                    
                    //...
                    
                    doSomething();]]>
                </c>
                <p>To invoke a function with arguments, place arguments, separated by comma, inside the <c>()</c> operator: </p>
                <c><![CDATA[
                    var doSomething = function(a, b, c)
                    {
                        //...
                    };
                    
                    //...
                    
                    doSomething("test", 3.14, false);]]>
                </c>
                <p>An argument can be any expression - string, number, another function call, etc.</p>
            </s>
            <s name="Built-in functions">
                <p>The Goat language has a lot of built-in functions (so-called built-in library). This library provides type definitions and functions for tasks such as string handling, mathematical computations, input/output processing and several other operating system services.</p>
                <p>For example, the <c>print</c> function converts the first argument to a string and outputs it to a console:</p>
                <c>print(2 + 3); // outputs: 5</c>
                <p>Built-in functions are fully described in the <link title="appropriate">Built-in functions</link> chapter.</p>
            </s>
        </s>
        <s name="Objects">
            <s name="Real life objects, properties and methods">
                <p>In real life, a car is an <b>object</b>. A car has <b>properties</b> like weight and color, and <b>methods</b> like start and stop.</p>
                <p>Object:</p>
                <c>var car = {};</c>
                <p>Properties:</p>
                <c><![CDATA[
                    car.name = "Fiat";
                    car.model = 500;
                    car.weight = "850kg";
                    car.color = "white";]]>
                </c>
                <p>Methods:</p>
                <c><![CDATA[
                    car.start();
                    car.drive();
                    car.brake();
                    car.stop();]]>
                </c>
                <p>All cars have the same <b>properties</b>, but the property values differ from car to car.</p>
                <p>All cars have the same <b>methods</b>, but the methods are performed at different times.</p>
            </s>
            <s name="Goat objects">
                <p>Recall that Goat variables are containers for data values. This code assigns a simple value ("Fiat") to a variable named <c>car</c>:</p>
                <c>var car = "Fiat";</c>
                <p>Objects are variables too. But objects can contain many values. This code assigns <b>many values</b> ("Fiat", 500, "white") to a <b>variable</b> named car:</p>
                <c>var car = {type: "Fiat", model: 500, color:"white"};</c>
                <p>The values are written as <c>name:value</c> pairs (name and value separated by a colon).</p>
            </s>
            <s name="Properties">
                <p>The <c>name:values</c> pairs (in Goat objects) are called properties.</p>
                <c>var goat = { name: "Stinky", wool: Color.WHITE, age: 3 };</c>
                <t>
                    <h>
                        <c width="100">Property</c>
                        <c>Value</c>
                    </h>
                    <r>
                        <c>name</c>
                        <c>"Stinky"</c>
                    </r>
                    <r>
                        <c>wool</c>
                        <c>Color.WHITE</c>
                    </r>
                    <r>
                        <c>age</c>
                        <c>3</c>
                    </r>
                </t>
            </s>
            <s name="Methods">
                <p>Methods are <b>actions</b> that can be performed on objects. Methods are stored in properties as <b>function definitions.</b> In other words, methods are functions that are performed on an object.</p>
                <c><![CDATA[
                    var person = 
                    {
                        firstName : "Scott",
                        lastName : "Cameron",
                        age : 45,
                        
                        fullName : function()
                        {
                            return firstName + ' ' + lastName;
                        }
                    };
                    
                    var name = person.fullName(); // result is: "Scott Cameron"]]>
                </c>
            </s>
            <s name="Definition">
                <p>You define (and create) a Goat object with an object literal:</p>
                <c>var person = { firstName : "Scott", lastName : "Cameron", age : 45 };</c>
                <p>Spaces and line breaks are not important. An object definition can span multiple lines:</p>
                <c><![CDATA[
                    var person =
                    {
                        firstName : "Scott",
                        lastName : "Cameron",
                        age : 45
                    };]]>
                </c>
            </s>
            <s name="Accessing object properties">
                <p>You can access object properties in two ways:</p>
                <c>objectName.propertyName</c>
                <p>or</p>
                <c>objectName["propertyName"]</c>
                <p>For example,</p>
                <c>person.lastName</c>
                <p>or</p>
                <c>person["lastName"];</c>
            </s>
            <s name="Accessing object methods">
                <p>You access an object method with the following syntax:</p>
                <c>objectName.methodName()</c>
                <p>For example,</p>
                <c>name = person.fullName();</c>
            </s>
            <s name="Nested objects">
                <p>Properties can be not only strings and numbers, but also arrays and objects:</p>
                <c><![CDATA[
                    var person = {
                        firstName : "Scott",
                        lastName : "Cameron",
                        age : 45,
                        children: [
                            { firstName: "Ann", lastName: "Cameron", age: 10 },
                            { firstName: "Dave", lastName: "Cameron", age: 14 }
                        ]
                    };]]>
                </c>
                <p>Thus, objects can be unlimitedly nested within each other.</p>
            </s>
            <s name="Objects, variables and references">
                <p>Let's create a new object and assign it to a variable:</p>
                <c>var a = { name: "Ivan", age: 33 };</c>
                <p>Then, let's assign this variable to another variable:</p>
                <c>var b = a;</c>
                <p>Okay. Now, we try to look what the second variable contains:</p>
                <c>print(b); // output: &quot;{&quot;name&quot;:&quot;Ivan&quot;,&quot;age&quot;:33}&quot;</c>
                <p>Right, it contains the same that contains the first variable. Now, we change one property of the second variable:</p>
                <c>b.name = "John";</c>
                <p>Now let's look at the result:</p>
                <c>print(b); // output: &quot;{&quot;name&quot;:&quot;John&quot;,&quot;age&quot;:33}&quot;</c>
                <p>And now let's see what the first variable contains:</p>
                <c>print(a); // output: &quot;{&quot;name&quot;:&quot;John&quot;,&quot;age&quot;:33}&quot;</c>
                <p>Thus, we changed the property of the second variable, but the first one also changed. Why? The Goat programming language does not store whole objects in variables. <b>The Goat programming language stores in the variables only references to objects, but not the objects themselves.</b> If you copy one variable to another, only the reference is copied.</p>
                <p>What can you do if you need to make a real copy of the object? Use special method <c>clone</c>:</p>    
                <c><![CDATA[
                    var a = { name: "Ivan", age: 33 };
                    var b = a.clone();
                    b.name = "Jonh";
                    print(b); // output: "{"name":"John","age":33}"
                    print(a); // output: "{"name":"Ivan","age":33}"]]>
                </c>
            </s>
        </s>
        <s name="Scope">
            <p>Scope determines the accessibility (visibility) of variables.</p>
            <p>Variables declared within a Goat block (function, etc), become <b>local</b> to this block. Local variables have local scope: they can only be accessed within the block.</p>
            <c><![CDATA[
                // code here can not use 'nickname'
                
                var myFunction = function()
                {
                    var nickname = "Stinky";
                    
                    // code here can use 'nickname'
                };
                
                // code here can not use 'nickname']]>
            </c>
            <p>However, local variables can be accessed from inner blocks:</p>
            <c><![CDATA[
                var myFunction = function()
                {
                    var nickname = "Stinky";
                    
                    //...
                    if (expression)
                    {
                        // code here can use 'nickname'
                    }
                    
                    // code here can use 'nickname'
                };]]>
            </c>
            <p>Functions are inner blocks also. So, each function can access variables, declared outside this function:</p>
            <c><![CDATA[
                var myFunction = function()
                {
                    var nickname = "Stinky";
                    
                    //...
                    var innerFunction = function()
                    {
                        // code here can use 'nickname'
                    };
                    
                    // code here can use 'nickname'
                };]]>
            </c>
            <p>Variables declared within a block, redefines variables with the same names, declared outside a block. New variable uses only in this block:</p>
            <c><![CDATA[
                var myFunction = function()
                {
                    var nickname = "Stinky";
                    //...
                    print(nickname); // output: "Stinky"
                    //...
                    var innerFunction = function()
                    {
                        var nickname = "Dirty"; // redefine 'nickname' variable
                        //...
                        print(nickname); // output: "Dirty"
                    };
                    //...
                    innerFunction();
                    //...
                    print(nickname); // output: "Stinky"
                };]]>
            </c>
        </s>
        <s name="Strings">
            <p>Goat strings are used for storing and manipulating text.</p>
            <s name="Definition">
                <p>A Goat string is zero or more characters written inside double quotes.</p>
                <c>var s = "Have a nice day";</c>
            </s>
            <s name="Special characters">
                <p>Because strings must be written within quotes, Goat will misunderstand this string:</p>
                <c>var s = "The line "No, I am your father" is often misquoted as "Luke, I am your father."";</c>
                <p>The string will be chopped to <c>"The line "</c>.</p>
                <p>The solution to avoid this problem, is to use the <b>backslash escape character.</b> The backslash (<c>\</c>) escape character turns special characters into string characters:</p>
                <t>
                    <h>
                        <c width="120">Code</c>
                        <c width="120">Result</c>
                        <c>Description</c>
                    </h>
                    <r>
                        <c><c>\n</c></c>
                        <c></c>
                        <c>New line</c>
                    </r>
                    <r>
                        <c><c>\r</c></c>
                        <c></c>
                        <c>Carriage return</c>
                    </r>
                    <r>
                        <c><c>\t</c></c>
                        <c></c>
                        <c>Tabulation</c>
                    </r>
                    <r>
                        <c><c>\&apos;</c></c>
                        <c><c>&apos;</c></c>
                        <c>Apostrophe (single quote)</c>
                    </r>
                    <r>
                        <c><c>\&quot;</c></c>
                        <c><c>&quot;</c></c>
                        <c>Double quote</c>
                    </r>
                    <r>
                        <c><c>\\</c></c>
                        <c><c>\</c></c>
                        <c>Backslash</c>
                    </r>
                </t>
                <p>The sequence <c>\"</c> inserts a double quote in a string:</p>
                <c>var s = "The line \"No, I am your father\" is often misquoted as \"Luke, I am your father.\"";</c>
                <p>The sequence <c>\\</c> inserts a backslash in a string:</p>
                <c>var s = "The character \\ is called backslash.";</c>
            </s>
            <s name="Strings are objects">
                <p>The Goat language has no primitive types. All data represented as objects, including strings. For example, 
                another way to define string is the explicit definition (as an object) by operator <c>new</c>:</p>
                <c>var s = new String("My name is Ivan");</c>
                <p>Don't create strings using operator new. This makes no sense. This example is needed to show that in principle, the string does not differ from other objects (it has a prototype, it can be created by the <c>new</c> operator, and so on).</p>
                <p>Since a string is an object, it has properties, including methods. For example, the <c>length</c> method returns the length of a string:</p>
                <c><![CDATA[
                    var s = "Test";
                    var n = s.length(); // value of 'n' will be 4]]>
                </c>
            </s>
            <s name="String methods">
                <m name="length" descr="Returns the length of a string."/>
                <m name="substr" descr="Extracts a part of a string and returns the extracted part in a new string.">
                    <a name="start" type="Integer" descr="the starting index (position). 0 is the first symbol"/>
                    <a name="count" type="Integer" descr="optional; count of characters. If not specified, the substring begins with the character at the specified index and extends to the end of this string. If specified, anyway, the method returns not more symbols than it possible"/>
                    <e><![CDATA[
                        var a = "This is an example.";
                        var b = a.subString(5, 2); // "is"
                        var c = a.subString(11); // "example."]]>
                    </e>
                </m>
                <m name="split" descr="Splits a string into an array of substrings using a separator.">
                    <a name="separator" type="Char | String" descr="a separator"/>
                    <e><![CDATA[
                        var s = "My name is James Bond";
                        var a = s.split(' '); // ["My","name","is","James","Bond"] ]]>
                    </e>
                </m>
                <m name="encode">
                    <d>Encodes a string into an array of bytes. Returns instance of <c>ByteArray</c> object.</d>
                    <a name="encoding" type="String" descr="encoding; now only &quot;utf8&quot; is supported"/>
                    <e><![CDATA[
                        var s = "abcd 123 Тест";
                        var a = s.encode("utf8"); // 61 62 63 64 20 31 32 33 20 d0 a2 d0 b5 d1 81 d1 82]]>
                    </e>
                </m>
                <m name="valueof" descr="Converts any object to a string.">
                    <a name="object" type="any type" descr="an object"/>
                    <e><![CDATA[
                        var i = 256 * 256;
                        var s = String.valueof(i); // "65536" ]]>
                    </e>
                    <n>This is the static method, i.e. meant to be relevant to all the instances of a class rather than to any specific instance.</n>
                </m>
            </s>
            <s name="String operators">
                <p>Remind that each object (include strings) supports these operators: <c>-&gt;</c> (inherit), <c>==</c> (equal), <c>!=</c> (not equal) and <c>!</c> (logical not). Other operators are:</p>
                <o name="+, +=" descr="Converts the second operand to a string and then concatenates strings.">
                    <e><![CDATA[
                        var s0 = "hello" + ", " + "world!"; // "hello, world!";
                        var s1 = "test" + 123; // "test123"
                        var s2 = "value";
                        s2 += 3.14; // "value3.14" ]]>
                    </e>
                </o>
                <p>One of the simplest methods to convert anything to a string is adding this object to an empty string:</p>
                <c>var s = "" + 3.14; // "3.14"</c>
                <o name="&lt;, &lt;=, &gt;, &gt;=">
                    <d>Lexicographical comparison of strings. If the second operator is not a string, returns <c>false</c>.</d>
                    <e><![CDATA[
                        print("hello" &gt;= "hell"); // outputs: true ]]>
                    </e>
                </o>
            </s>
        </s>
        <s name="Characters">
            <p>A character (<c>Char</c>) is a type that corresponds to a symbol or grapheme: letter, digit etc.</p>
            <s name="Definition">
                <p>A Goat char is one character written inside single quotes.</p>
                <c>var c = 'A';</c>
            </s>
            <s name="Special characters">
                <p>As in strings, special characters after a backslash can be used here:</p>
                <t>
                    <h>
                        <c width="120">Code</c>
                        <c width="120">Result</c>
                        <c>Description</c>
                    </h>
                    <r>
                        <c><c>\n</c></c>
                        <c></c>
                        <c>New line</c>
                    </r>
                    <r>
                        <c><c>\r</c></c>
                        <c></c>
                        <c>Carriage return</c>
                    </r>
                    <r>
                        <c><c>\t</c></c>
                        <c></c>
                        <c>Tabulation</c>
                    </r>
                    <r>
                        <c><c>\&apos;</c></c>
                        <c><c>&apos;</c></c>
                        <c>Apostrophe (single quote)</c>
                    </r>
                    <r>
                        <c><c>\&quot;</c></c>
                        <c><c>&quot;</c></c>
                        <c>Double quote</c>
                    </r>
                    <r>
                        <c><c>\\</c></c>
                        <c><c>\</c></c>
                        <c>Backslash</c>
                    </r>
                </t>
                <p>The sequence <c>\'</c> means a single quote:</p>
                <c>var c = '\'';</c>
            </s>
            <s name="Char methods">
                <m name="valueof" descr="Static method. Converts object to a char.">
                    <a name="object" type="any type" descr="an object"/>
                    <e><![CDATA[
                        var i = 65;
                        var c = Char.valueof(i); // 'A' ]]>
                    </e>
                    <n>If the object is an integer, returns a Char containing the character associated with the specified character code. Else, if the object is a char, just returns this object. Else, if the object is a string and this string contains only one symbol, returns this symbol. In all other cases, returns <c>null</c>.</n>
                </m>
            </s>
            <s name="Char operators">
                <o name="++, --">
                    <d>Increments or decrements of a <c>Char</c> variable (or a field) by 1.</d>
                    <e><![CDATA[
                        var c = 'A'; // 'A';
                        c++; // 'B'
                        c++; // 'C'
                        c--; // 'B' ]]>
                    </e>
                </o>
                <o name="&lt;, &lt;=, &gt;, &gt;=">
                    <d>Comparison of two <c>Char</c> objects. If the second parameter is not a char, returns <c>false</c>.</d>
                    <e><![CDATA[
                        print('A' < 'B'); // outputs: true]]>
                    </e>
                </o>
            </s>
        </s>
        <s name="Numbers">
            <p>The Goat interpreter operates two type of numbers: integers and real numbers.</p>
            <s name="Integers">
                <s name="Definition">
                    <p>Integer numbers are written without decimal point:</p>
                    <c>var i = 3;</c>
                    <p>Also, Goat interprets numerical constants as hexadecimal if they are preceded by <c>0x</c>:</p>
                    <c><![CDATA[
                        var i = 0x12ab34; // lower case symbols
                        var j = 0x56CD78; // upper case symbols]]>
                    </c>
                    <p>and interprets numerical constants as binary if they are preceded by <c>0b</c>:</p>
                    <c>var i = 0b1011;</c>
                </s>
                <s name="Methods">
                    <m name="string" descr="Converts integer to a string.">
                        <a name="radix" type="Integer" descr="optional, radix, one of: 2, 10 or 16, default 10"/>
                        <e><![CDATA[
                            var i = 254;
                            var s = i.string(); // "254"
                            var h = "0x" + i.string(16); // "0xfe"]]>
                        </e>
                    </m>
                    <m name="valueof" descr="Static method. Converts object to an integer.">
                        <a name="object" type="any type" descr="an object"/>
                        <a name="radix" type="Integer" descr="optional, radix, one of: 2, 10 or 16, default 10"/>
                        <e><![CDATA[
                            var s = "  fffe ";
                            var i = Integer.valueof(s, 16); // 65534 ]]>
                        </e>
                        <n>Attempts to convert a value to an integer, returns <c>null</c> if failed.</n>
                    </m>
                    <t>
                        <h>
                            <c width="200">Object type</c>
                            <c>Conversion result</c>
                        </h>
                        <r>
                            <c><c>Integer</c></c>
                            <c>Returns unchanged</c>
                        </r>
                        <r>
                            <c><c>Real</c></c>
                            <c>Returns the integer part of a real number</c>
                        </r>
                        <r>
                            <c><c>Boolean</c></c>
                            <c>Returns <c>1</c> if <c>true</c>, <c>0</c> if <c>false</c></c>
                        </r>
                        <r>
                            <c><c>Char</c></c>
                            <c>Returns the character code as a number</c>
                        </r>
                        <r>
                            <c><c>String</c></c>
                            <c>Attempts to recognize a string as a number. Ignores whitespace before and after. Returns <c>null</c> if failed</c>
                        </r>
                        <r>
                            <c>Other type</c>
                            <c><c>null</c></c>
                        </r>
                    </t>
                </s>
                <s name="Operators">
                    <p>The Integer type has more operators than the other types.</p>
                    <o name="+, +=, -, -=, *, *=, /, /=">
                        <d>Addition, subtraction, multiplication and division. Note that multiplication and division have a higher precedence than addition and subtraction, just as in algebra. If the second operand is a real number, then the result will also be a real number. If the second operand is an integer, the result will integer. Else if the second operand is not a number, returns <c>false</c>.</d>
                        <e><![CDATA[
                            var a = 2;
                            var b = 3;
                            var c = 5;
                            var x = a + b * c; // 17 ]]>
                        </e>
                    </o>
                    <o name="%, %=">
                        <d>Modulo (remainder). Returns the remainder of an integer divided by an integer.</d>
                        <e><![CDATA[
                            var x = 17 % 10 // 7]]>
                        </e>
                    </o>
                    <o name="&lt;, &lt;=, &gt;, &gt;=">
                        <d>Comparison of two numbers (integer or real number). If the second parameter is not a number, returns <c>false</c>.</d>
                        <e><![CDATA[
                            print(4 > 3); // outputs: false]]>
                        </e>
                    </o>
                    <o name="++, --">
                        <d>Increments or decrements of an <c>Integer</c> variable (or a field) by 1.</d>
                        <e><![CDATA[
                            var x = 1; // 1;
                            x++; // 2
                            x++; // 3
                            x--; // 2 ]]>
                        </e>
                    </o>
                    <o name="~">
                        <d>The bitwise <b>not</b>, or complement, is a unary operation that performs logical negation on each bit, forming the ones complement of the given binary value. Bits that are 0 become 1, and those that are 1 become 0:</d>
                        <e><![CDATA[
                            var x = 0b1011;
                            var n = ~x; // ...1110100 ]]>
                        </e>
                        <n>The Integer is 64-bit data type, all these bits change their values. So in this example, all first bits became 1.</n>
                    </o>
                    <o name="&lt;&lt;, &lt;&lt;=">
                        <d>Left shift, i.e.  bitwise operation that shifts all the bits of its operand. Shifts left by pushing zeros in from the right and let the leftmost bits fall off.</d>
                        <e><![CDATA[
                            var x = 0b1011;
                            var s = x << 2; // 101100 ]]>
                        </e>
                    </o>
                    <p>Left shifts can be useful as an efficient way to perform multiplication of unsigned integers by powers of 2. Shifting left by <c>n</c> bits on unsigned binary number has the effect of multiplying it by 2 to the power of <c>n</c>:</p>
                    <c><![CDATA[
                        var x = 5;
                        var s = x << 3; // 5 * 8 = 40 ]]>
                    </c>
                    <o name="&gt;&gt;, &gt;&gt;=">
                        <d>Signed right shift, shifts right by pushing copies of the leftmost bit in from the left, and let the rightmost bits fall off.</d>
                        <e><![CDATA[
                            var x = -5 // ...111011;
                            var s = x > 1; // ...111101 (-3) ]]>
                        </e>
                    </o>
                    <o name="&gt;&gt;&gt;, &gt;&gt;&gt;=">
                        <d>Unsigned (zero fill) right shift, one or more zero bits are pushed in from the left, and the rightmost bits fall off.</d>
                        <e><![CDATA[
                            var x = 5 // 101;
                            var s = x >>> 1; // 010 (2) ]]>
                        </e>
                    </o>
                    <o name="&amp;, &amp;=">
                        <d>Bitwise <b>and</b> returns 1 only if both bits are 1.</d>
                        <e><![CDATA[
                            var x = 5 // 101;
                            var y = 1 // 001;
                            var b = x & y; // 001 (1) ]]>
                        </e>
                    </o>
                    <o name="|, |=">
                        <d>Bitwise <b>or</b> returns 1 if one of the bits are 1.</d>
                        <e><![CDATA[
                            var x = 5 // 101;
                            var y = 1 // 001;
                            var b = x | y; // 101 (5) ]]>
                        </e>
                    </o>
                    <o name="^, ^=">
                        <d>Bitwise <b>xor</b> (exclusive <b>or</b>) returns 1 if the bits are different.</d>
                        <e><![CDATA[
                            var x = 5 // 101;
                            var y = 1 // 001;
                            var b = x ^ y; // 100 (4) ]]>
                        </e>
                    </o>
                </s>
            </s>
            <s name="Real numbers">
                <s name="Definition">
                    <p>Real numbers are written with the decimal point (dot):</p>
                    <c>var i = 3.14;</c>
                </s>
                <s name="Methods">
                    <m name="valueof" descr="Static method. Converts object to a real number.">
                        <a name="object" type="any type" descr="an object"/>
                        <e><![CDATA[
                            var s = "  65,535 ";
                            var r = Real.valueof(s); // 65.535 ]]>
                        </e>
                        <n>Attempts to convert a value to a real number, returns <c>null</c> if failed.</n>
                    </m>
                    <t>
                        <h>
                            <c width="200">Object type</c>
                            <c>Conversion result</c>
                        </h>
                        <r>
                            <c><c>Real</c></c>
                            <c>Returns unchanged</c>
                        </r>
                        <r>
                            <c><c>Integer</c></c>
                            <c>Returns the integer as a real number</c>
                        </r>
                        <r>
                            <c><c>Boolean</c></c>
                            <c>Returns <c>1.0</c> if <c>true</c>, <c>0.0</c> if <c>false</c></c>
                        </r>
                        <r>
                            <c><c>Char</c></c>
                            <c>Returns the character code as a number</c>
                        </r>
                        <r>
                            <c><c>String</c></c>
                            <c>Attempts to recognize a string as a real number. Ignores whitespace before and after. Recognizes a comma <c>,</c> as well as a dot <c>.</c> as a decimal separator. Returns <c>null</c> if failed</c>
                        </r>
                        <r>
                            <c>Other type</c>
                            <c><c>null</c></c>
                        </r>
                    </t>
                </s>
                <s name="Operators">
                    <p>Real type supports only these operators: <c>+</c>, <c>+=</c>, <c>-</c>, <c>-=</c>, <c>*</c>, <c>*=</c>, <c>/</c>, <c>/=</c>, <c>&lt;</c>, <c>&lt;=</c>, <c>&gt;</c>, <c>&gt;=</c>, <c>++</c>, <c>--</c>. Bitwise operators are not supported.</p>
                </s>
            </s>
        </s>
        <s name="Arrays">
            <p>Goat arrays are used to store multiple values in a single variable.</p>
            <s name="Creating an array">
                <p>Using an array literal <c>[ ]</c>:</p>
                <c>var array_name = [item1, item2, ...];</c>
                <p>For example:</p>
                <c>var herd = ["Dirty", "Stinky", "Crazy"];</c>
                <p>Spaces and line breaks are not important. A declaration can span multiple lines:</p>
                <c><![CDATA[
                    var herd = [
                        "Dirty",
                        "Stinky",
                        "Crazy"
                    ];]]>
                </c>
                <p>Array elements can be objects, arrays, numbers, strings... (remind that numbers, strings etc - all are objects). Arrays are special kinds of objects. You can have functions in an array. You can have even arrays in an array.</p> 
            </s>
            <s name="Access the elements of an array">
                <p>You refer to an array element by referring to the <b>index number.</b> <c>[0]</c> is the first element in an array. <c>[1]</c> is the second. Array indexes start with 0.</p>
                <p>This statement accesses the value of the first element in <c>herd</c> array:</p>
                <c>var name = herd[0];</c>
                <p>This statement modifies the first element in <c>herd</c> array:</p>
                <c>herd[0] = "Nasty";</c>
            </s>
            <s name="Adding array elements">
                <p>The way to add a new element to an array is using the <c>push</c> method:</p>
                <c><![CDATA[
                    var fruits = ["Banana", "Orange", "Apple", "Mango"];
                    fruits.push("Lemon"); // adds a new element ("Lemon") to fruits ]]>
                </c>
            </s>
            <s name="The difference between arrays and objects">
                <p>Arrays use <b>numbered indexes.</b></p>
                <p>Objects use <b>named indexes.</b></p>
                <p>Arrays are a special kind of objects, with numbered indexes.</p>
            </s>
            <s name="Array methods">
                <m name="length" descr="Returns the length (count of items) of an array."/>
                <m name="push" descr="Adds a new item to the end of an array.">
                    <a name="object" type="any type" descr="an item"/>
                </m>
            </s>
            <s name="Array operators">
                <o name="+">
                    <d>If the second operand is array, returns a new array that is a concatenation of two operands, i.e. contains all items from the left operand and then all items from the right operand. Otherwise, if the second operand is not an array (so it is another object), returns a new array contains all items from the left operand plus one additional item (right operand).</d>
                    <e><![CDATA[
                        var a = [1,2,3];
                        var b = [4,5];
                        var x = a + b; // [1,2,3,4,5]
                        var y = x + 6; // [1,2,3,4,5,6] ]]>
                    </e>
                </o>
            </s>
            <s name="Looping array elements">
                <p>The best way to loop through an array, is using a <c>for</c> loop:</p>
                <c><![CDATA[
                    var fruits = ["Banana", "Orange", "Apple", "Mango"];
                    var i, count = fruits.length();
                    for (i = 0; i < count; i++)
                    {
                        println(fruits[i]);
                    } ]]>
                </c>
                <p>Output:</p>
                <c><![CDATA[
                    Banana
                    Orange
                    Apple
                    Mango ]]>
                </c>
                <p>The same result with <c>for..in</c> loop:</p>
                <c><![CDATA[
                    var fruits = ["Banana", "Orange", "Apple", "Mango"];
                    var fruit;
                    for (fruit in fruits)
                    {
                        println(fruit);
                    } ]]>
                </c>
            </s>
        </s>
        <s name="Booleans">
            <p>A Goat <c>Boolean</c> represents one of two values: <c>true</c> or <c>false</c>.</p>
            <s name="Boolean values">
                <p>Very often, in programming, you will need a data type that can only have one of two values, like</p>
                <l>
                    <i><b>Yes</b> or <b>No</b></i>
                    <i><b>On</b> or <b>Off</b></i>
                    <i><b>Light Side</b> or <b>Dark Side</b></i>
                </l>
                <p>For this, The Goat programming language has a <c>Boolean</c> data type. It can only take the values <c>true</c> or <c>false</c>.</p>
                <c><![CDATA[
                    var t = true;
                    var f = false; ]]>
                </c>
            </s>
            <s name="Comparisons and conditions">
                <p>The chapter <link>Comparisons</link> gives a full overview of comparison operators.</p>
                <p>The chapter <link>Conditions</link> gives a full overview of conditional statements.</p>
                <p>Here are some examples:</p>
                <t>
                    <h>
                        <c width="100">Operator</c>
                        <c>Description</c>
                        <c>Example</c>
                    </h>
                    <r>
                        <c><c>==</c></c>
                        <c>Equal to</c>
                        <c><c>if (day == "Monday")</c></c>
                    </r>
                    <r>
                        <c><c>&gt;</c></c>
                        <c>Greater than</c>
                        <c><c>if (salary &gt; 9000)</c></c>
                    </r>
                    <r>
                        <c><c>&lt;</c></c>
                        <c>Less than</c>
                        <c><c>if (age &lt; 18)</c></c>
                    </r>
                </t>
                <p>The Boolean value of an expression is the basis for all Goat comparisons and conditions.</p>
            </s>
        </s>
        <s name="Comparison and logical operators" anchor="Comparisons">
            <p>Comparison and logical operators are used to test for <c>true</c> or <c>false</c>.</p>
            <s name="Comparison operators">
                <p>Comparison operators are used in logical statements to determine equality or difference between variables or values.</p>
                <p>Given that <c>x = 5</c>, the table below explains the comparison operators:</p>
                <t>
                    <h>
                        <c width="100">Operator</c>
                        <c>Description</c>
                        <c>Comparing</c>
                        <c>Returns</c>
                    </h>
                    <r>
                        <c><c>==</c></c>
                        <c>Equal to</c>
                        <c><c>x == 8</c></c>
                        <c><c>false</c></c>
                    </r>
                    <r>
                        <c/>
                        <c/>
                        <c><c>x == 5</c></c>
                        <c><c>true</c></c>
                    </r>
                    <r>
                        <c/>
                        <c/>
                        <c><c>x == "5"</c></c>
                        <c><c>false</c></c>
                    </r>
                    <r>
                        <c><c>!=</c></c>
                        <c>Not equal</c>
                        <c><c>x != 8</c></c>
                        <c><c>true</c></c>
                    </r>
                    <r>
                        <c><c>&gt;</c></c>
                        <c>Greater than</c>
                        <c><c>x &gt; 8</c></c>
                        <c><c>false</c></c>
                    </r>
                    <r>
                        <c><c>&lt;</c></c>
                        <c>Less than</c>
                        <c><c>x &lt; 8</c></c>
                        <c><c>true</c></c>
                    </r>
                    <r>
                        <c><c>&gt;=</c></c>
                        <c>Greater than or equal to</c>
                        <c><c>x &gt;= 8</c></c>
                        <c><c>false</c></c>
                    </r>
                    <r>
                        <c><c>&lt;=</c></c>
                        <c>Less than or equal to</c>
                        <c><c>x &lt;= 5</c></c>
                        <c><c>true</c></c>
                    </r>
                </t>
                <p>Comparison operators can be used in conditional statements to compare values and take action depending on the result:</p>
                <c>if (age &lt; 18) print("Too young");</c>
            </s>
            <s name="Logical operators">
                <p>Logical operators are used to determine the logic between variables or values.</p>
                <p>Given that <c>x = 6</c> and <c>y = 3</c>, the table below explains the logical operators:</p>
                <t>
                    <h>
                        <c width="100">Operator</c>
                        <c>Description</c>
                        <c>Example</c>
                        <c>Returns</c>
                    </h>
                    <r>
                        <c><c>&amp;&amp;</c></c>
                        <c>Logical <b>and</b></c>
                        <c><c>(x &lt; 10 &amp;&amp; y &gt; 1)</c></c>
                        <c><c>true</c></c>
                    </r>
                    <r>
                        <c><c>||</c></c>
                        <c>Logical <b>or</b></c>
                        <c><c>(x == 5 || y == 5)</c></c>
                        <c><c>false</c></c>
                    </r>
                    <r>
                        <c><c>!</c></c>
                        <c>Logical <b>not</b></c>
                        <c><c>!(x == y)</c></c>
                        <c><c>true</c></c>
                    </r>
                </t>
                <h name="Logical and (&amp;&amp;)">
                    <p>The expression <c>A &amp;&amp; B</c> is <c>true</c> if <c>A</c> and <c>B</c> are both <c>true</c>; else it is <c>false</c>.</p>
                </h>
                <h name="Logical or (||)">
                    <p>The expression <c>A || B</c> is <c>true</c> if <c>A</c> or <c>B</c> (or both) are <c>true</c>; if both are <c>false</c>, the expression is <c>false</c>.</p>
                </h>
                <h name="Logical not (!)">
                    <p>The expression <c>!A</c> is <c>true</c> if <c>A</c> is <c>false</c>.</p>
                </h>
            </s>
            <s name="Conditional (ternary) operator">
                <p>Goat also contains a conditional operator that assigns a value to a variable based on some condition:</p>
                <c>variablename = (condition) ? value1 : value2</c>
                <p>For example,</p>
                <c>var voteable = (age &lt; 18) ? "Too young" : "Old enough";</c>
                <p>If the variable <c>age</c> is a value below 18, the value of the variable voteable will be <c>"Too young"</c>, otherwise the value of voteable will be <c>"Old enough"</c>.</p>
            </s>
            <s name="Comparing different types">
                <p>Comparing data of different types may give unexpected results. As a rule, the operators <c>==</c> and <c>!=</c> check that the types of the two variables match, otherwise will be returned default value (<c>false</c> in case of <c>==</c>). For example, you can compare numbers but you can not compare a number and a string. If you need to compare, just explicit convert an operand to another type to match the second operand:</p>
                <c><![CDATA[
                    var s = "1024";    // String
                    var i = 256 * 4;   // Integer
                    if (String.valueof(i) == s)
                    {
                        // do something
                    }]]>
                </c>
                <p>There is one exclusion. You can compare integer numbers and real numbers although they are different types. An integer operand will be converted to a real before comparison.</p>
                <p>If you really not sure that operands have the same type, but you extremely need to compare it, cast both operands to the same type:</p>
                <c><![CDATA[
                    var s = "1024";
                    var i = 256 * 4;
                    if (Real.valueof(i) == Real.valueOf(s)) // convert both to Real
                    {
                        // do something
                    }]]>
                </c>
            </s>
        </s>
        <s name="Conditions" anchor="Conditions">
            <s name="Conditional statements">
                <p>Conditional statements are used to perform different actions based on different conditions.</p>
                <p>Very often when you write code, you want to perform different actions for different decisions. You can use conditional statements in your code to do this. In Goat we have the following conditional statements:</p>
                <l>
                    <i>Use <c>if</c> to specify a block of code to be executed, if a specified condition is true</i>
                    <i>Use <c>else</c> to specify a block of code to be executed, if the same condition is false</i>
                    <i>Use <c>else if</c> to specify a new condition to test, if the first condition is false</i>
                    <i>Use <c>switch</c> to specify many alternative blocks of code to be executed</i>
                </l>
            </s>
            <s name="The 'if' statement">
                <p>Use the <c>if</c> statement to specify a block of Goat code to be executed if a condition is true. Syntax:</p>
                <c><![CDATA[
                    if (condition)
                    {
                        block of code to be executed if the condition is true
                    }]]>
                </c>
                <p>Example (outputs <c>"Okay"</c>):</p>
                <c><![CDATA[
                    var testscore = 70;
                    //...
                    if (testscore > 60)
                    {
                        print("Okay");
                    }]]>
                </c>
                <p>Note that <c>if</c> is in lowercase letters. Uppercase letters (<c>If</c> or <c>IF</c>) will generate a Goat error.</p>
            </s>
            <s name="The 'else' statement">
                <p>Use the <c>else</c> statement to specify a block of code to be executed if the condition is false. Syntax:</p>
                <c><![CDATA[
                    if (condition)
                    {
                        block of code to be executed if the condition is true
                    }
                    else
                    {
                        block of code to be executed if the condition is false
                    }]]>
                </c>
                <p>Example (outputs <c>"Excellent result"</c>):</p>
                <c><![CDATA[
                    var testscore = 95;
                    //...
                    if (testscore < 90)
                    {
                        print("Okay");
                    }
                    else
                    {
                        print("Excellent result");
                    }]]>
                </c>
            </s>
            <s name="The 'else if' statement">
                <p>Use the <c>else if</c> statement to specify a new condition if the first condition is false. Syntax:</p>
                <c><![CDATA[
                    if (condition1)
                    {
                        block of code to be executed if condition1 is true
                    }
                    else if (condition2)
                    {
                        block of code to be executed if the condition1 is false and condition2 is true
                    }
                    else
                    {
                        block of code to be executed if the condition1 is false and condition2 is false
                    }]]>
                </c>
                <p>Example:</p>
                <c><![CDATA[
                    if (testscore < 50)
                    {
                        print("Bad result");
                    }
                    else if (testscore < 90)
                    {
                        print("Okay");
                    }
                    else
                    {
                        print("Excellent result");
                    }]]>
                </c>
            </s>
            <s name="Single statements instead of blocks">
                <p>If a block contains only one statement, you can use this statement without parentheses. The previous example, but with single statements instead of blocks:</p>
                <c><![CDATA[
                    if (testscore < 50)
                        print("Bad result");
                    else if (testscore < 90)
                        print("Okay");
                    else
                        print("Excellent result");]]>
                </c>
                <p>It's a little shorter, isn't it? You can even write the whole 'if' statement to one line:</p>
                <c>if (obj == null) return;</c>
                <p>It's the same to:</p>
                <c><![CDATA[
                    if (obj == null)
                        return;]]>
                </c>
                <p>Or</p>
                <c><![CDATA[
                    if (obj == null)
                    {
                        return;
                    }]]>
                </c>
                <p>Of course, the same rules apply to other constructions described below.</p>
            </s>
        </s>
        <s name="Switch statement">
            <p>The switch statement is used to perform different actions based on different conditions. Use the switch statement to select one of many blocks of code to be executed.</p>
            <s name="Syntax">
                <c><![CDATA[
                    switch(expression)
                    {
                        case n:
                            code block
                            break;
                        case n:
                            code block
                            break;
                        default:
                            code block
                    }]]>
                </c>
                <p>This is how it works:</p>
                <l>
                    <i>The switch expression is evaluated once.</i>
                    <i>The value of the expression is compared with the values of each case.</i>
                    <i>If there is a match, the associated block of code is executed.</i>
                </l>
                <p>Example. This function converts weekday (as a number between 0 and 6) to a string:</p>
                <c><![CDATA[
                    var weekday = function(number)
                    {
                        var day;
                        switch (number)
                        {
                            case 0:
                                day = "Sunday";
                                break;
                            case 1:
                                day = "Monday";
                                break;
                            case 2:
                                day = "Tuesday";
                                break;
                            case 3:
                                day = "Wednesday";
                                break;
                            case 4:
                                day = "Thursday";
                                break;
                            case 5:
                                day = "Friday";
                                break;
                            case 6:
                                day = "Saturday";
                        }
                        return day;
                    }; ]]>
                </c>
            </s>
            <s name="The 'break' keyword">
                <p>When Goat reaches a <c>break</c> keyword, it breaks out of the switch block. This will stop the execution of more code and case testing inside the block. When a match is found, and the job is done, it's time for a break. There is no need for more testing.</p>
                <p>It is not necessary to break the last case in a switch block. The block breaks (ends) there anyway.</p>
            </s>
            <s name="The 'default' keyword">
                <p>The <c>default</c> keyword specifies the code to run if there is no case match.</p>
                <p>Example. This function converts weekday (as a number between 0 and 6) to a string, but if a weekday is neither Saturday (6) nor Sunday (0), returns a default message:</p>
                <c><![CDATA[
                    var weekday = function(number)
                    {
                        var day;
                        switch (number)
                        {
                            case 0:
                                day = "Sunday";
                                break;
                            case 6:
                                day = "Saturday";
                                break;
                            default:
                                day = "Working day";
                        }
                        return day;
                    }; ]]>
                </c>
                <p>The default case (if exists) does not necessarily have to be the last one. However, it will always be executed only if all other conditions have not been executed. This block is recommended to be the last block for good visibility.</p>
            </s>
            <s name="Common code blocks">
                <p>Sometimes you will want different switch cases to use the same code:</p>
                <c><![CDATA[
                    var weekday = function(number)
                    {
                        var day;
                        switch (number)
                        {
                            case 0:
                                day = "Sunday";
                                break;
                            case 6:
                                day = "Saturday";
                                break;
                            case 4:
                            case 5:
                                day = "Soon it is Weekend";
                                break;
                            default:
                                day = "Working day";
                        }
                        return day;
                    }; ]]>
                </c>
            </s>
        </s>
        <s name="Loops">
            <s name="What are loops">
                <p>Loops can execute a block of code a number of times.</p>
                <p>Loops are handy, if you want to run the same code over and over again, each time with a different value. Often this is the case when working with arrays.</p>
                <p>For example, we have an array:</p>
                <c>var herd = ["Dirty", "Stinky", "Crazy", "Nasty", "Dumb", "Dumber"];</c>
                <p>Instead of writing:</p>
                <c><![CDATA[
                    print(herd[0] + "\n");
                    print(herd[1] + "\n");
                    print(herd[2] + "\n");
                    print(herd[3] + "\n");
                    print(herd[4] + "\n");
                    print(herd[5] + "\n");]]>
                </c>
                <p>You can write:</p>
                <c><![CDATA[
                    var i, l = herd.length();
                    for (i = 0; i < l; i++)
                    {
                        println(herd[i]);
                    }]]>
                </c>
            </s>
            <s name="Different kinds of loops">
                <p>Goat supports different kinds of loops:</p>
                <l>
                    <i><c>for</c> - loops through a block of code a number of times;</i>
                    <i><c>for..in</c> - loops through the properties of an object or through all items of an array;</i>
                    <i><c>while</c> - loops through a block of code while a specified condition is true;</i>
                    <i><c>do..while</c> - also loops through a block of code while a specified condition is true.</i>
                </l>
            </s>
            <s name="The 'for' loop">
                <p>The <c>for</c> loop is often the tool you will use when you want to create a loop. The <c>for</c> loop has the following syntax:</p>
                <c><![CDATA[
                    for (statement 1; statement 2; statement 3)
                    {
                        code block to be executed
                    }]]>
                </c>
                <p><b>Statement 1</b> is executed before the loop (the code block) starts.</p>
                <p><b>Statement 2</b> defines the condition for running the loop (the code block).</p>
                <p><b>Statement 3</b> is executed each time after the loop (the code block) has been executed.</p>
                <p>Example (outputs <c>"0123456789"</c>):</p>
                <c><![CDATA[
                    var i;
                    for (i = 0; i < 10; i++)
                    {
                        print(i);
                    }]]>
                </c>
                <p>From the example above, you can read:</p>
                <p>Statement 1 sets a variable before the loop starts (<c>i = 0</c>).</p>
                <p>Statement 2 defines the condition for the loop to run (<c>i</c> must be less than 10).</p>
                <p>Statement 3 increases a value (<c>i++</c>) each time the code block in the loop has been executed.</p>
                <s name="Statement 1">
                    <p>Normally you will use statement 1 to initialize the variable used in the loop (<c>i = 0</c>). This is not always the case, Goat doesn't care. Statement 1 is optional. You can omit statement 1 (like when your values are set before the loop starts):</p>
                    <c><![CDATA[
                        var i = 0;
                        for (; i < 10; i++)
                        {
                            print(i);
                        }]]>
                    </c>
                    <p>Also, you can declare a variable in statement 1 using <c>var</c> keyword:</p>
                    <c><![CDATA[
                        for (var i = 0; i < 10; i++)
                        {
                            print(i);
                        }]]>
                    </c>
                    <p>This variable will be visible only inside the 'for' loop.</p>
                </s>
                <s name="Statement 2">
                    <p>Often statement 2 is used to evaluate the condition of the initial variable. This is not always the case, Goat doesn't care. Statement 2 is also optional. If statement 2 returns <c>true</c>, the loop will start over again, if it returns <c>false</c>, the loop will end.</p>
                    <p>If you omit statement 2, you must provide a <c>break</c> or a <c>return</c> inside the loop. Otherwise, the loop will never end.</p>
                </s>
                <s name="Statement 3">
                    <p>Often statement 3 increments the value of the initial variable. This is not always the case, Goat doesn't care, and statement 3 is optional. Statement 3 can do anything like negative increment (<c>i--</c>), positive increment (<c>i = i + 15</c>), or anything else. Statement 3 can also be omitted (like when you increment your values inside the loop):</p>
                    <c><![CDATA[
                        for (i = 0; i < 10; )
                        {
                            print(i);
                            i++;
                        }]]>
                    </c>
                </s>
            </s>
            <s name="The 'for..in' loop">
                <p>The Goat <c>for..in</c> statement loops through the properties of an object:</p>
                <c><![CDATA[
                    var person = {name: "Ivan", age: 33, gender: "male"};
                    var x;
                    for (x in person)
                    {
                        if (person.contains(x))
                            println(x + ": " + person[x]);
                    }]]>
                </c>
                <p>Output:</p>
                <c><![CDATA[
                    name: Ivan
                    age: 33
                    gender: male]]>
                </c>
                <p>Some notes. First, objects store unordered pairs <c>key:value</c>. The order of traversal of object properties may not match with the order of the properties at object creation. In the example above, the output can be:</p>
                <c><![CDATA[
                    age: 33
                    name: Ivan
                    gender: male]]>
                </c>
                <p>Second, you must have noticed that this is an additional <c>contains</c> method call. Why? In fact, any object contains references to additional auxiliary methods, so without calling <c>contains</c> method, the output will be similar to something like:</p>
                <c><![CDATA[
                    gender: male
                    age: 33
                    name: Ivan
                    clone: function
                    instanceof: function
                    flat: function
                    get: function
                    set: function
                    iterator: function
                    ...]]>
                </c>
                <p>The <c>contains</c> method returns <c>true</c> if object itself contains property with given name. So, we can exclude all auxiliary properties (methods and fields).</p>
                <p>The Goat <c>for..in</c> statement can also loop through all items of an array:</p>
                <c><![CDATA[
                    var herd = ["Dirty", "Stinky", "Crazy", "Nasty", "Dumb", "Dumber"];
                    var goat;
                    for (goat in herd)
                    {
                        println(goat);
                    }]]>
                </c>
            </s>
            <s name="The 'while' loop">
                <p>The <c>while</c> loop loops through a block of code as long as a specified condition is <c>true</c>. Syntax:</p>
                <c><![CDATA[
                    while (condition)
                    {
                        code block to be executed
                    }]]>
                </c>
                <p>Example  (outputs <c>"0123456789"</c>):</p>
                <c><![CDATA[
                    var i = 0;
                    while (i < 10)
                    {
                        print(i);
                        i++;
                    }]]>
                </c>
                <p>Note: if you forget to increase the variable used in the condition, the loop will never end.</p>
            </s>
            <s name="The 'do..while' loop">
                <p>The <c>do..while</c> loop is a variant of the while loop. This loop will execute the code block once, before checking if the condition is <c>true</c>, then it will repeat the loop as long as the condition is <c>true</c>. Syntax:</p>
                <c><![CDATA[
                    do 
                    {
                        code block to be executed
                    }
                    while (condition);]]>
                </c>
                <p>Example. The loop will always be executed at least once, even if the condition is <c>false</c>, because the code block is executed before the condition is tested:</p>
                <c><![CDATA[
                    var i = 0;
                    do 
                    {
                        print(i);
                        i++;
                    } while (i < 10);]]>
                </c>
            </s>
            <s name="The 'break' statement">
                <p>You have already seen the <c>break</c> statement used in an earlier chapter of this tutorial. It was used to "jump out" of a <c>switch</c> statement. The <c>break</c> statement can also be used to "jump out" of a loop. The <c>break</c> statement breaks the loop and continues executing the code after the loop (if any):</p>
                <c><![CDATA[
                    var i;
                    for (i = 0; i < 10; i++)
                    {
                        if (i == 6)
                            break;
                        print(i);
                    }]]>
                </c>
                <p>Output: <c>012345</c>.</p>
            </s>
            <s name="The 'continue' statement">
                <p>The <c>continue</c> statement breaks one iteration (in the loop), if a specified condition occurs, and continues with the next iteration in the loop.</p>
                <p>This example skips the value of 3:</p>
                <c><![CDATA[
                    var i;
                    for (i = 0; i < 10; i++)
                    {
                        if (i == 3)
                            continue;
                        print(i);
                    }]]>
                </c>
                <p>Output: <c>012456789</c>.</p>
            </s>
        </s>
        <s name="Exceptions">
            <s name="Errors will happen!">
                <p>When executing Goat code, different errors can occur. For example, division by zero:</p>
                <c>print(1 / 0); // oops</c>
            </s>
            <p>The <c>try</c> statement lets you test a block of code for errors.</p>
            <p>The <c>catch</c> statement lets you handle the error.</p>
            <p>The <c>throw</c> statement lets you create custom errors.</p>
            <p>The <c>finally</c> statement lets you execute code, after try and catch, regardless of the result.</p>
            <s name="Try and catch">
                <p>The <c>try</c> statement allows you to define a block of code to be tested for errors while it is being executed.</p>
                <p>The <c>catch</c> statement allows you to define a block of code to be executed, if an error occurs in the try block.</p>
                <p>The Goat statements <c>try</c> and <c>catch</c> come in pairs:</p>
                <c><![CDATA[
                    try 
                    {
                        Block of code to try
                    }
                    catch(err) 
                    {
                        Block of code to handle errors
                    }]]>
                </c>
                <p>Example:</p>
                <c><![CDATA[
                    try 
                    {
                        print(4 / 4);
                        print(4 / 2);
                        print(4 / 1);
                        print(4 / 0);
                    }
                    catch(err)
                    {
                        print("Error");
                    }]]>
                </c>
                <p>Output:</p>
                <c>124Error</c>
                <p>When an error occurs, Goat will normally stop and generate an error object. The technical term for this is: Goat will <b>throw an exception</b> (throw an error).</p>
            </s>
            <s name="The 'throw' statement">
                <p>The <c>throw</c> statement allows you to create a custom error.</p>
                <p>Technically you can <b>throw an exception</b> (throw an error). The exception can be any object:</p>
                <c>throw "Oops!"; // throw a string</c>
                <p>The thrown object passes as a parameter of the <c>catch</c> statement.</p>
                <p>If you use <c>throw</c> together with <c>try</c> and <c>catch</c>, you can control program flow and generate custom error messages.</p>
                <c><![CDATA[
                    var kelvin2Celsius = function(value)
                    {
                        if (value < 0)
                            throw "Wrong parameter: " + value;
                        
                        return value - 273.15;
                    };
                    
                    try 
                    {
                        print("\n" + kelvin2Celsius(300));
                        print("\n" + kelvin2Celsius(0));
                        print("\n" + kelvin2Celsius(-10));
                    }
                    catch(err)
                    {
                        print("\n" + err);
                    }]]>
                </c>
                <p>Output:</p>
                <c><![CDATA[
                    26.85
                    -273.15
                    Wrong parameter: -10]]>
                </c>
            </s>
            <s name="The 'finally' statement">
                <p>The finally statement lets you execute code, after try and catch, regardless of the result:</p>
                <c><![CDATA[
                    try
                    {
                        Block of code to try
                    }
                    catch(err)
                    {
                        Block of code to handle errors
                    } 
                    finally
                    {
                        Block of code to be executed regardless of the try / catch result
                    }]]>
                </c>
            </s>
            <s name="The error object">
                <p>The exception can be any object. For some situations, the interpreter throws predefined exception objects, such as:</p>
                <t>
                    <h>
                        <c>Exception</c>
                        <c>Situation</c>
                    </h>
                    <r>
                        <c><c>Exception</c></c>
                        <c>Common type for all exceptions</c>
                    </r>
                    <r>
                        <c><c>Exception.IllegalArgument</c></c>
                        <c>Illegal argument of a function or an operator</c>
                    </r>
                    <r>
                        <c><c>Exception.IllegalContext</c></c>
                        <c>Incorrect execution context, usually this occurs if you try to apply the methods of one object to another object</c>
                    </r>
                    <r>
                        <c><c>Exception.IllegalOperation</c></c>
                        <c>This operation cannot be executed</c>
                    </r>
                    <r>
                        <c><c>Exception.IllegalOperation.DivisionByZero</c></c>
                        <c>Division by zero, <c>print(1 / 0);</c></c>
                    </r>
                    <r>
                        <c><c>Exception.IllegalOperation.UndeclaredVariable</c></c>
                        <c>Attempt to assign a value to an undeclared variable</c>
                    </r>
                    <r>
                        <c><c>Exception.IllegalReference</c></c>
                        <c>Attempt to write or read a non-existent object (<c>undefined</c> or <c>null</c>)</c>
                    </r>
                    <r>
                        <c><c>Exception.IllegalType</c></c>
                        <c>Object has a type that was not expected</c>
                    </r>
                    <r>
                        <c><c>Exception.IllegalType.IsNotAFunction</c></c>
                        <c>Attempt to call an object as a function (but it is not a function)</c>
                    </r>
                    <r>
                        <c><c>Exception.IllegalType.IsNotAMethod</c></c>
                        <c>Attempt to call an object as a method (but it is not a method)</c>
                    </r>
                    <r>
                        <c><c>Exception.IllegalType.OperatorNotFound</c></c>
                        <c>This operator does not apply to the object, <c>print("abc" - "def");</c></c>
                    </r>
                </t>
                <p>Each object (include error objects) has the <c>instanceof</c> method. You can use this method to determine the type of exception:</p>
                <c><![CDATA[
                    try 
                    {
                        // do something
                    }
                    catch(err)
                    {
                        if (err.instanceof(Exception.IllegalOperation))
                        {
                            // do domething if operation is illegal
                        }
                    }]]>
                </c>
            </s>
        </s>
        <s name="Import">
            <s name="Overview">
            <p>Sometimes the program becomes so large that it is more reasonable to separate it into several files. In addition, you can use pre-designed libraries - say, to recognize XML files. Goat provides a way to include files to a program using an <c>import</c> keyword.</p>
            <c><![CDATA[
                import "xml.goat";
                
                // now, you can use functions from XML library:
                var root = Xml.parse("<root></root>");]]>
            </c>
            <p>No file will be imported twice. For example, your program uses library <c>A</c> and library <c>B</c>. But library <c>B</c> uses (imports) library <c>A</c> too. So, library <c>A</c> will be imported only once, for the whole project.</p>
            <p>Where the interpreter finds files to import? </p>
            <l>
                <i>first, in the current folder, where was started Goat script;</i>
                <i>second, in the list of folders specified in the <c>--lib</c> option of the interpreter.</i>
            </l>
            </s>
            <s name="--lib option">
                <p>Path (paths) to importable files. For example, folder <c>c:\goat\lib</c> contains Goat standard library; so, to use it, launch the interpreter with <c>--lib</c> option:</p>
                <c>goat.exe program.goat --lib=c:\goat\lib</c>
                <p>Several paths can be separated by a semicolon. The interpreter for each imported file first searches the first path in the list, then the second one, and so on.</p>
            </s>
        </s>
        <s name="Debugging">
            <s name="Interactive mode">
                <p>Goat has two basic modes: script and interactive. The script mode is the mode where the script files are run in the Goat interpreter. Interactive mode is a command line shell that gives immediate feedback for each statement while running in shared memory. As new lines are fed into the interpreter, each new line is executed.</p>
                <p>To start interactive mode, launch the Goat interpreter without script file (in common cases without any parameters):</p>
                <c>goat.exe</c>
                <p>Will open a console:</p>
                <c><![CDATA[
                    Ok.
                    >]]>
                </c>
                <p>Enter any correct statement and press Enter:</p>
                <c><![CDATA[
                    > var i = 0;
                    
                    >]]>
                </c>
                <p>In the example above, the interpreter will create a variable <c>i</c> and wait for the new statement to be entered. So, now you can print the value of the variable:</p>
                <c><![CDATA[
                    > print(i);
                    0
                    >]]>
                </c>
                <p>You can use any statements you want:</p>
                <c><![CDATA[
                    > for (var k = 0; k < 10; k++) print(k);
                    0123456789
                    >]]>
                </c>
                <p>If statement takes more than one line, add a backslash to go a new line:</p>
                <c><![CDATA[
                    > for (var k = 0; k < 10; k++) \
                    { \
                        if (k == 3) continue; \
                        print(k); \
                    }
                    012456789
                    >]]>
                </c>
                <p>The values of all variables are saved:</p>
                <c><![CDATA[
                    > var obj = {};
                    
                    > obj.field = 1;
                    
                    > print(obj);
                    {field:1};
                    >]]>
                </c>
                <p>To print the value of an expression, add a question mark before the expression:</p>
                <c><![CDATA[
                    > ? 2 + 3
                    5
                    >]]>
                </c>
                <p>Any expressions are applicable:</p>
                <c><![CDATA[
                    > ? "test".instanceof(String)
                    true
                    >]]>
                </c>
                <p>The special statement <c>quit</c> (or <c>q</c>) exits interactive mode.</p>
                <c>quit</c>
            </s>
            <s name="Step-by-step debugging" anchor="Step-by-step debugging">
                <s name="The '--debug' command line parameter">
                    <p>If to add this parameter to the command line, the interpreter will be started in step-by-step mode. The program will be compiled, but will not be run. Will open a console instead:</p>
                    <c><![CDATA[
                        C:\>goat.exe program.goat --debug
                        ?]]>
                    </c>
                </s>
                <s name="Commands in debugging mode">
                    <p>The interpreter is waiting for the command to be entered after the question mark. A command is one letter and possibly some auxiliary parameters, for example:</p>
                    <c><![CDATA[
                        ? b program.goat : 1
                        setting breakpoint at program.goat, 1
                        ?]]>
                    </c>
                    <p>After the question mark in square brackets, the default command can be displayed. It will be executed if do not enter any command (that is, just press Enter). Most of all cases, this is the previous command:</p>
                    <c>? [c]</c>
                    <p>Additional information can be displayed before prompt, such as the current line being executed.</p>
                    <c><![CDATA[
                        40 -> program.goat, 4.5
                        var j = i * i
                        ? [n] ]]>
                    </c>
                    <p>Where,</p>
                    <c><![CDATA[
                        ticks -> filename, position
                        statement
                        ? [cmd] ]]>
                    </c>
                    <l>
                        <i><c>ticks</c> - count of ticks (instructions) executed by the Goat virtual machine;</i>
                        <i><c>filename</c> - current file name;</i>
                        <i><c>position</c> - current position (line and symbol in this line);</i>
                        <i><c>statement</c> - statement that will be executed;</i>
                        <i><c>cmd</c> - default command.</i>
                    </l>
                    <p>Here is list of commands:</p>
                    <t>
                        <h>
                            <c>Command</c>
                            <c>Mnemonic</c>
                            <c>Example</c>
                            <c>Description</c>
                        </h>
                        <r>
                            <c><c>b filename : line</c></c>
                            <c>breakpoint</c>
                            <c><c>b program.goat : 10</c></c>
                            <c>Inserts a <b>breakpoint</b>. The program will stop on position, specified by this command</c>
                        </r>
                        <r>
                            <c><c>r</c></c>
                            <c>run</c>
                            <c></c>
                            <c><b>Runs</b> the program. This command can be done only once in a debugging session</c>
                        </r>
                        <r>
                            <c><c>c</c></c>
                            <c>continue</c>
                            <c></c>
                            <c><b>Continue</b> executing of the program. This command can be entered only if the program is was run</c>
                        </r>
                        <r>
                            <c><c>n</c></c>
                            <c>next</c>
                            <c></c>
                            <c>Execute the <b>next</b> statement and then stop (wait for next command)</c>
                        </r>
                        <r>
                            <c><c>e</c></c>
                            <c>enter</c>
                            <c></c>
                            <c>Execute the next statement, but, if it is a function call, <b>enter</b> to function and then stop on the first statement</c>
                        </r>
                        <r>
                            <c><c>l</c></c>
                            <c>leave</c>
                            <c></c>
                            <c><b>Leave</b> current function, i.e. execute all statements, and stop on the next statement after the function call</c>
                        </r>
                        <r>
                            <c><c>p variable</c></c>
                            <c>print</c>
                            <c><c>p obj.value</c></c>
                            <c><b>Prints</b> the value of the variable</c>
                        </r>
                    </t>
                </s>
                <s name="The 'debug' keyword">
                    <p>The <c>debug</c> keyword stops the execution of Goat, and switch the interpreter to step-by-step mode. It like breakpoint, but in program source code. In other words, it is &quot;constant breakpoint&quot;. If no debugging is available, the <c>debug</c> statement has no effect.</p>
                    <p>Example, <c>square_numbers.goat</c>:</p>
                    <c><![CDATA[
                        var i, j;
                        for (i = 0; i < 10; i++)
                        {
                            debug;
                            j = i * i;
                            println(j);
                        }]]>
                    </c>
                    <p>Then launch the interpreter with <c>--debug</c> option:</p>
                    <c>goat.exe square_numbers.goat --debug</c>
                    <p>The program will start and then stop on <c>debug</c> keyword:</p>
                    <c><![CDATA[
                        > square_numbers.goat, 3.4: debug;
                        [c] ?]]>
                    </c>
                </s>
            </s>
        </s>
    </s>
    
    <s name="Advanced programming">
        <p>Forget everything you learned in school.</p>
        <s name="The new look at objects">
            <s name="Keys and values">
                <p>Objects are containers for pairs <c>key:value</c>:</p>
                <c>var person = { firstName : "Scott", lastName : "Cameron", age : 45 };</c>
                <p>The <c>key:value</c> pairs (in Goat objects) are called <b>properties.</b></p>
                <p>Values can be any objects: strings, numbers etc. What about keys? In the example above, keys are identifiers (such as names of variables).In common cases, using identifiers as keys is enough: it is convenient. You always can add a new property using the dot operator <c>.</c>:</p>
                <c>person.profession = "Programmer";</c>
                <p>But, keys can be not only identifiers. <b>You can use any object as a key.</b> For example, integers:</p>
                <c>person[3] = "value";</c>
                <p>...or booleans:</p>
                <c>person[true] = false;</c>
                <p>...and, of course, strings:</p>
                <c>person["profession"] = "Programmer";</c>
                <p>If you use a string as a key, and this string can be an identifier (the first character must be a letter or an underscore (<c>_</c>), subsequent characters may be letters, digits or underscores), Goat transforms this string to an identifier. Later you can access to this field using identifier:</p>
                <c><![CDATA[
                    person["weight"] = 80;
                    //...
                    print(person.weight); // output: "80"]]>
                </c>
                <p>And vice versa, any property declared using an identifier, can be accessed using a string:</p>
                <c><![CDATA[
                    person.weight = 80;
                    //...
                    print(person["weight"]); // output: "80"]]>
                </c>
                <p>So, objects are containers for pairs <c>key:value</c>, where the key can be an identifier or any object, and the value can be any object. However, the Goat program works a little faster if you use identifiers as keys, so this is the preferred method.</p>
            </s>
            <s name="Everything is an object">
                <p>All data (strings, numbers, booleans) represented as objects. These are "special" objects that have special behavior. But beyond this, these objects do everything the same as other, "ordinary" objects.</p>
                <p>For example, you can add a property for a string:</p>
                <c><![CDATA[
                    var str = "hello!";
                    str.somePropertyName = 123;]]>
                </c>
            </s>
        </s>
        <s name="Methods">
            <s name="Difference between method and function">
                <p>A <b>method</b> in object-oriented programming is a function associated with an object.</p>
                <p>In other words, functions work only with parameters, but methods also "see" all the properties (fields and other methods) of their own object and can modify these.</p>
                <p>Example. Declare an object <c>obj</c> that contains one field <c>x</c> and one method <c>getX</c>. The method has access to the field:</p>
                <c><![CDATA[
                    var obj = 
                    {
                        x: 10;
                        
                        getX : $()
                        {
                            return x;
                        }
                    };
                    
                    var n = obj.getX(); // 10]]>
                </c>
                <p>A method call is differs from a function call by writing a point after an associated object whose method is called:</p>
                <c><![CDATA[
                    // function call:
                    ret_val = function_name(arg_1, arg_2, arg_3);
                    
                    // method call:
                    ret_val = object.method_name(arg_1, arg_2, arg_3);]]>
                </c>
            </s>
            <s name="Search order">
                <p>Since a property (or variable) with the same name can be defined in many places, the programming language specifies a clear order of searching for the value by name.</p>
                <p>Suppose we want to read a variable named <c>x</c>. The highest priority has local variables:</p>
                <c><![CDATA[
                    var obj = 
                    {
                        x: 10; // property 'x'
                        
                        getX : $() 
                        {
                            var x = 2 + 3; // local variable 'x'
                            return x;
                        }
                    };
                    
                    var n = obj.getX(); // 5 ]]>
                </c>
                <p>If a local variable with this name is not found, the Goat programming language tries to find this name in the list of arguments of the method:</p>
                <c><![CDATA[
                    var obj = 
                    {
                        x: 10; // property 'x'
                        
                        getX : $(x) // method with argument named 'x'
                        { 
                            return x;
                        }
                    };
                    
                    var n = obj.getX(7); // 7 ]]>
                </c>
                <p>Then the search is performed in the object properties:</p>
                <c><![CDATA[
                    var x = 777; // external variable 'x'
                    
                    var obj = {
                        x: 10; // property 'x'
                        
                        getX : $()
                        {
                            return x;
                        }
                    };
                    
                    var n = obj.getX(); // 10 ]]>
                </c>
                <p>The last thing to do is look for variables outside the object:</p>
                <c><![CDATA[
                    var x = 777; // external variable 'x'
                    
                    var obj = 
                    {
                        getX : $() 
                        {
                            return x;
                        }
                    };
                    
                    var n = obj.getX(); // 777 ]]>
                </c>
            </s>
            <s name="The 'this' keyword">
                <p>When a method is called, a special variable named <c>this</c> is always defined. This variable refers to the object whose method was called. You can not overwrite the value of this variable. This variable is used to explicitly access the properties of the "own" object.</p>
                <c><![CDATA[
                    var obj = 
                    {
                        x: 10; // property 'x'
                        
                        getX : $() 
                        {
                            return this.x;
                        }
                    };
                    
                    var n = obj.getX(); // 10 ]]>
                </c>
                <p>In fact, the example above is completely analogous to this example:</p>
                <c><![CDATA[
                    var obj = {
                        x: 10; // property 'x'
                        
                        getX : $() 
                        {
                            return x; // without 'this' keyword
                        }
                    };
                    
                    var n = obj.getX(); // 10 ]]>
                </c>
                <p>That is, in most cases, we can do without using <c>this</c> keyword. But in some cases, <c>this</c> keyword cannot be avoided. For example, if you already have a local variable or an argument with that name, but you want to explicit read or write the property of the object:</p>
                <c><![CDATA[
                    var obj = {
                        x: 10; // property 'x'
                        
                        getX : $() 
                        {
                            return x;
                        }
                        
                        setX " $(x)
                        {
                            this.x = x; // read the argument 'x' and write the property 'x' 
                        }
                    };
                    
                    obj.setX(777);
                    var n = obj.getX(); // 777 ]]>
                </c>
                <p>Or, you can add new properties to own object (which are not yet there):</p>
                <c><![CDATA[
                    var obj = 
                    {
                        x: 10; // property 'x'
                        
                        init : $() // constructor
                        { 
                            this.y = 20; // add a new property 'y'
                        }
                    };]]>
                </c>
            </s>
            <s name="Changing the context">
                <p>Summing up the above, it can be said that the function differs from the method only by the process of calling. Any method can be "transformed" to a function:</p>
                <c><![CDATA[
                    // an object that contains a method:
                    var obj = 
                    {
                        doSomething : $()
                        {
                            println("hello!");
                        }
                    };
                    
                    var func = obj.doSomething; // copying the property pointed to the method to a variable
                    func(); // function call, prints: "hello!" ]]>
                </c>
                <p>However, in this case, the context is changed: the reference to <c>this</c> became <c>undefined</c>:</p>
                <c><![CDATA[
                    // an object that contains a method and a value:
                    var obj = 
                    {
                        value : 3,
                        
                        doSomething : $()
                        {
                            println(this?.value);
                        }
                    };
                    
                    // do call as a method 
                    obj.doSomething();
                    
                    // do call as a function 
                    var func = obj.doSomething;
                    func(); ]]>
                </c>
                <p>Output:</p>
                <c><![CDATA[
                    3
                    undefined ]]>
                </c>
                <p>In some cases, when the context is not important, a method is named a "static method". In other cases, calling a method as a function will throw an <c>IllegalContext</c> exception.</p>
                <p>If needed, we can change the context of a method called, i.e. replace <c>this</c> to &quot;another <c>this</c>&quot;. There are two methods: <c>call</c> and <c>apply</c>.</p>
                <m name="call">
                    <d>Calls a function with a given <c>this</c> value and arguments provided individually.</d>
                    <a name="thisArg" type="any type" descr="A new context"/>
                    <a name="arg1" type="any type" descr="First argument"/>
                    <a name="arg2, ..." type="any type" descr="other arguments"/>
                    <e><![CDATA[
                        // an object that contains a method and a value:
                        var obj = 
                        {
                            value : 3,
                            
                            doSomething : $(x, y)
                            {
                                println(this?.value);
                                println(x);
                                println(y);
                            }
                        };
                        
                        // do call as a method 
                        obj.doSomething(7, "test");
                        
                        // do call as a method with another context
                        var context =
                        {
                            value : 555
                        };
                        
                        var func = obj.doSomething;
                        func.call(context, 7, "test"); ]]> 
                    </e>
                </m>
                <p>Output:</p>
                <c><![CDATA[
                    3
                    7
                    test
                    555
                    7
                    test]]>
                </c>
                <m name="apply">
                    <d>Calls a function with a given <c>this</c> value and arguments provided as an array.</d>
                    <a name="thisArg" type="any type" descr="A new context"/>
                    <a name="argsArray" type="Array" descr="An array object, specifying the arguments"/>
                    <e><![CDATA[
                        // the previous example, but the 'apply' method is used:
                        func.apply(context, [7, "test"]); ]]> 
                    </e>
                </m>
            </s>
        </s>
        <s name="Prototypes">
            <s name="Prototype and inheritance">
                <p>Goat is prototype-oriented language. What is "prototype" means?</p>
                <p>A <b>prototype</b> is an object from which other objects <b>inherit</b> properties and methods. Any object can be a prototype for another object.</p>
                <p><b>Inheritance</b> is when an object is based on another object.</p>
                <p>How does it work? When accessing an object (method call or field reading), the Goat programming language first looks for this property in the object itself. If Goat does not find it, it tries to look for this property in the prototype object. If still not found, then Goat is searching in a prototype of the prototype, and so on. Consider an example of simple inheritance:</p>
                <pic title="Simple inheritance">graph/simple_inheritance.svg</pic>
                <c><![CDATA[
                    // declare an object:
                    var parent = { x: 1 };
                    
                    // inherit another object:
                    var child = parent -> { y: 2, z: 3 }; 
                    
                    // now you have access to properties in the parent object:
                    println(child.x); // output: "1"]]>
                </c>
                <p>Here, the <c>child</c> is the heir to the <c>parent</c>. Access of any parent's property by name has no different from that of the child's property. And it can be said that a child has the same properties as a parent. However, the child itself does not copy these properties, it only refers to them.</p>
                <p>Inheritance nesting is not limited, any object can have a prototype, and a prototype can have its pro-prototype, and so on:</p>
                <pic title="Inheritance nesting">graph/simple_inheritance_nesting.svg</pic>
                <c><![CDATA[
                    // declare an object:
                    var grandpa = { a: 1, b: 2 };
                    
                    // inherit another object:
                    var dad = grandpa -> { x: 3 }; 
                    
                    // inherit from heir:
                    var son = dad -> { y: 4, z: 5 }; 

                    // now you have access to properties of the pro-prototype:
                    println(son.a); // output: "1"

                    // and to properties of the prototype:
                    println(son.x); // output: "3"

                    // as well as to object's own properties:
                    println(son.z); // output: "5"]]>
                </c>
            </s>
            <s name="Operator -&gt;">
                <p>Operator <c>-&gt;</c> builds a new object from the <b>prototype</b> and <b>description:</b></p>
                <c>var obj = prototype -&gt; description;</c>
                <p>A <b>prototype</b> is an object from which properties (fields and methods) will be used if properties with such names are not found in the child object.</p>
                <p>A <b>description</b> is an object that will be cloned before a prototype is attached to it. The description thus <b>extends</b> the prototype, and as a result, a new object is created that contains both its own properties and the properties of all its parents.</p>
                <p>Example:</p>
                <c><![CDATA[
                    // declare an object:
                    var A = { x: 1 };
                    
                    // inherit:
                    var B = A -> { y: 2, z: 3 }; // 'B' contains 'x', 'y' and 'z' ]]>
                </c>
                <p>Of course, you can declare a description elsewhere:</p>
                <c><![CDATA[
                    // declare an object:
                    var A = { x: 1 };
                    
                    // declare a description:
                    var D = { y: 2, z: 3 };
                    
                    // inherit:
                    var B = A -> D; // 'B' still contains 'x', 'y' and 'z' ]]>
                </c>
            </s>
            <s name="Order of searching in a prototype chain">
                <p>If you created a new object using an operator <c>-&gt;</c>, then this object, in turn, can also be a prototype of some other object:</p>
                <c><![CDATA[
                    // declare an object:
                    var A = { x: 1 };
                    
                    // inherit first time:
                    var B = A -> { y: 2 }; // 'B' contains 'x' and 'y' 
                    
                    // inherit second time:
                    var C = B -> { z: 3 }; // 'C' contains 'x', 'y' and 'z' ]]>
                </c>
                <p>The Goat programming language looks for the property by its name along the whole prototype chain, from the last to the first prototype. For example,</p>
                <c>print(C.x);</c>
                <p>The order of search is:</p>
                <l>
                    <i>first, a property named <c>x</c> will be searched in the <c>C</c> object and will not be found;</i>
                    <i>second, a property will be searched in the <c>B</c> object and will not be found;</i>
                    <i>finally, a property will be searched in the <c>A</c> object and will be found.</i>
                </l>
                <p>Another example, attempt to read an undefined property:</p>
                <c>print(C.w);</c>
                <p>In this case, the Goat programming language will scan the whole prototype chain (first <c>C</c>, then <c>B</c>, then <c>A</c>), but will not find the properties and return <c>undefined</c> result.</p>
            </s>
            <s name="Changing the prototype">
                <p>You can not change the prototype of the object. Instead, you can change some properties of the prototype itself. In this case, these properties will immediately change in all children:</p>
                <c><![CDATA[
                    // declare an object:
                    var A = { x: 1 };
                    
                    // inherit:
                    var B = A -> { y: 2, z: 3 }; 
                    
                    // read the value of 'x' property (of the child object):
                    print(B.x); // output: "1"
                    
                    // change the value of 'x' property (in the parent object):
                    A.x = 777;
                    
                    // read the value of 'x' property again:
                    print(B.x); // output: "777"]]>
                </c>
            </s>
            <s name="The 'new' operator">
                <p>The <c>new</c> operator creates a new object from the prototype and then calls a special method - constructor to initialize the object.</p>
                <c><![CDATA[
                    // declare the class:
                    var Vector =
                    { 
                        x : 0,
                        y : 0
                    };
                    
                    // create the object using the 'new' operator
                    var v = new Vector();]]>
                </c>
                <p>In the simplest case, as in the example above, this operation is completely analogous to the inheritance from the prototype:</p>
                <c>var v = Vector -&gt; { };</c>
                <p>But, in addition to inheritance, the <c>new</c> operator calls a chain of constructors.</p>
                <s name="Constructor">
                    <p>A constructor is a method named <c>init</c>.</p>
                    <c><![CDATA[
                        // declare the class:
                        var Vector = 
                        { 
                            init : $() 
                            {
                                this.x = 0;
                                this.y = 0;
                            }
                        };
                        
                        // create the object using the 'new' operator
                        var v = new Vector();]]>
                    </c>
                    <p>Output:</p>
                    <c>{x:0,y:0}</c>
                    <p>Note that in the first example (without the constructor), the <c>x</c> and <c>y</c> variables are not owned by the new object, but by the prototype. In the new example, the variables are created each time the object is created by the <c>new</c> operator, and these variables are owned by the object.</p>
                    <p>Where can this be useful? This is necessary in cases where each object must have its own independent data set.</p>
                    <p>Let's consider another example. Say there is some "Dictionary" class that stores values in an associative array:</p>
                    <c><![CDATA[
                        var Dictionary = 
                        { 
                            data : {},
                            
                            add : $(english, french) 
                            {
                                data[english] = french;
                            }
                        };
                        
                        // create the first dictionary
                        var d1 = new Dictionary();
                        d1.add("red", "rouge");
                        d1.add("green", "vert");
                        
                        // create the second dicrionary
                        var d2 = new Dictionary();
                        d2.add("blue", "bleu");
                        d2.add("black", "noir");
                        
                        // read the data from the first dictionary:
                        print(d1.data);]]>
                    </c>
                    <p>Will this work? No. The output is:</p>
                    <c>{"red":"rouge","green":"vert","blue":"bleu","black":"noir"}</c>
                    <p>But should be:</p>
                    <c>{"red":"rouge","green":"vert"}</c>
                    <p>The resulting object contains data from both the first and second dictionary. Why? Because the <c>d.data</c> object is not owned by <c>d1</c> object but owned by its prototype, that is, both objects <c>d1</c> and <c>d2</c> have access to it. But this is wrong. Each dictionary instance must have its own object for data storage. To solve the issue, you can create this object in the constructor:</p>
                    <c><![CDATA[
                        var Dictionary = 
                        { 
                            init : $() 
                            {
                                this.data = {};
                            },
                            
                            add : $(english, french) 
                            {
                                data[english] = french;
                            }
                        };
                        
                        // create the first dictionary
                        var d1 = new Dictionary();
                        d1.add("red", "rouge");
                        d1.add("green", "vert");
                        
                        // create the second dicrionary
                        var d2 = new Dictionary();
                        d2.add("blue", "bleu");
                        d2.add("black", "noir");
                        
                        // read the data from the first dictionary:
                        print(d1.data);]]>
                    </c>
                    <p>Now it's right:</p>
                    <c>{"red":"rouge","green":"vert"}</c>
                    <p>So, constructors are needed to initialize objects, so that each instance of a class, created using the <c>new</c> operator, contains its unique data.</p>
                </s>
                <s name="Constructor with parameters">
                    <p>An <c>init</c> method can have parameters that are passed to it as arguments of the <c>new</c> operator:</p>
                    <c><![CDATA[
                        var Vector = 
                        {
                            init : $(x, y) 
                            {
                                this.x = x;
                                this.y = y;
                            }
                        };

                        var v = new Vector(10, 20);

                        print(v);
                        ]]>
                    </c>
                    <p>Output:</p>
                    <c>{x:10,y:20}</c>
                    <p>So, the parameterized constructor allows initializing an object using the data passed as parameters.</p>
                </s>
                <s name="Constructors chain">
                    <p>Consider a chain of prototypes, with each prototype containing an <c>init</c> method:</p>
                    <c><![CDATA[
                        var A = 
                        {
                            init : $() 
                            {
                                this.x = 1;
                            }
                        };

                        var B = A -> 
                        {
                            init : $() 
                            {
                                this.y = 2;
                            }
                        };

                        var C = B -> 
                        {
                            init : $() 
                            {
                                this.z = 3;
                            }
                        };

                        var obj = new C();

                        print(obj);]]>
                    </c>
                    <p>Output:</p>
                    <c>{x:1,y:2,z:3}</c>
                    <p>As you can see, all three constructors were called, because the resulting object contains all three variables.</p>
                    <p>How it works. If the prototype chain contains prototypes that have an <c>init</c> method, then the <c>new</c>operator calls these methods one by one, starting from the "deepest" prototype.</p>
                    <p>In the example above, the <c>init</c> method of object <c>A</c> will be called first, then the <c>init</c> method of object <c>B</c>, then the <c>init</c> method of object <c>C</c>.</p>
                    <p>This order of calling constructors allows you to correctly initialize the object. Let's try to change the value of the variable in the last constructor:</p>
                    <c><![CDATA[
                        var A = 
                        {
                            init : $() 
                            {
                                this.x = 1;
                            }
                        };

                        var B = A -> 
                        {
                            init : $() 
                            {
                                this.y = 2;
                            }
                        };

                        var C = B -> 
                        {
                            init : $() 
                            {
                                x = 7;
                                this.z = 3;
                            }
                        };

                        var a = new A();
                        var b = new B();
                        var c = new C();

                        print("" + a + "\n" + b + "\n" + c);
                        ]]>
                    </c>
                    <p>Output:</p>
                    <c><![CDATA[
                        {x:1}
                        {x:1,y:2}
                        {x:7,y:2,z:3}]]>
                    </c>
                    <p>You see? Each subsequent constructor in the chain complements the object's initialization. During this, of course, the results of the work of the previous constructor can be changed.</p>
                </s>
                <s name="Passing parameters to the constructors chain">
                    <p>When passing parameters through the <c>new</c> operator, all parameters are passed only to the first constructor:</p>
                    <c><![CDATA[
                        var A =
                        {
                            init : $() 
                            {
                                this.x = 10;
                            }
                        };

                        var B = A -> 
                        {
                            init : $(y, z) 
                            {
                                this.y = y;
                                this.z = z;
                            }
                        };

                        var obj = new B(20, 30);

                        print(obj);
                        ]]>
                    </c>
                    <p>Output:</p>
                    <c>{x:10,y:20,z:30}</c>
                    <p>All others (not first) constructors in the chain are called without parameters.</p>
                </s>
            </s>
            <s name="Overriding">
                <p>You can override properties (fields and methods) in children's objects.</p>
                <p>Method overriding, in Goat programming language, is a language feature that allows a subobject to provide a specific implementation of a method that is already provided by one of its prototypes. The implementation in the subobject overrides (replaces) the implementation in the prototype by providing a method that has the same name as the method in the prototype. The version of a method that is executed will be determined by the object that is used to invoke it.</p>
                <c><![CDATA[
                    // the object with the method which will be overridden:
                    var Animal = 
                    {
                        talk : $() 
                        {
                            print("This animal can not speak.\n");
                        }
                    };
                    
                    // inherit the first object and override the method:
                    var Goat = Animal -> 
                    {
                        talk : $() 
                        {
                            print("Baa!\n");
                        }
                    }; 
                    
                    // inherit the second object and override the method again:
                    var Cow = Animal -> 
                    {
                        talk : $() 
                        {
                            print("Moo!\n");
                        }
                    }; 

                    // inherit the third object but does not override the method:
                    var Fish = Animal -> 
                    {
                    };
                    
                    // create three objects and call the methods:
                    var g = new Goat();
                    var c = new Cow();
                    var f = new Fish();
                    
                    g.talk();
                    c.talk();
                    f.talk();]]>
                </c>
                <p>Output:</p>
                <c><![CDATA[
                    Baa!
                    Moo!
                    This animal can not speak.]]>
                </c>
                <p>The same rule for fields. Field with the same name as in prototype overrides the previous field:</p>
                <c><![CDATA[
                    // the object with the field which will be overridden:
                    var Programmer = 
                    {
                        salary : 1000
                    };
                    
                    // inherit the first object and override the field:
                    var Senior = Programmer -> 
                    {
                        salary : 1500
                    }; 
                    
                    // inherit the second object but does not override the field:
                    var UnitTester = Programmer -> 
                    {
                    };
                    
                    // create two objects and read the fields:
                    var s = new Senior();
                    var ut = new UnitTester();
                    
                    print(s.salary);
                    print("\n");
                    print(ut.salary);]]>
                </c>
                <p>Output:</p>
                <c><![CDATA[
                    1500
                    1000]]>
                </c>
            </s>
            <s name="Operator overloading">
                <p>Operators can be redefined. From the point of view of the interpreter, the operator is no different from the usual method. The method that defines the operator has the same name as the operator itself. Let's consider an example:</p>
                <c><![CDATA[
                    var Vector = 
                    {
                        init : $(x, y) 
                        {
                            this.x = x; this.y = y
                        },
                        
                        toString : $() 
                        {
                            return "X: " + x + ", Y: " + y;
                        },
                        
                        "+" : $(vec) 
                        {
                            return new Vector(x + vec.x, y + vec.y);
                        },
                        
                        "*" : $(val) 
                        {
                            return new Vector(x * val, y * val);
                        }
                    };

                    var v1 = new Vector(100, 200);
                    var v2 = new Vector(200, 400);

                    var v3 = v1 + v2;
                    print(v3.toString() + "\n");

                    var v4 = v1 * 5;
                    print(v4.toString() + "\n");
                    ]]>
                </c>
                <p>Output:</p>
                <c><![CDATA[
                    X: 300, Y: 600
                    X: 500, Y: 1000]]>
                </c>
                <p>In the example above, the class "Vector" is described. A vector is a complex data structure. Vectors can be summed, a vector can be multiplied by a number. Therefore, for this structure, two operators are defined: <c>+</c> and <c>*</c>. Each operator returns a new vector as the result of an operation of addition or multiplication.</p>
                <p>How it works. When the interpreter processes a binary operator, it finds the corresponding method at the <b>left</b> operand and calls this method, passing the <b>right</b> operand as the parameter. The result of the operation is the return value of the method. In the case of a unary operator, the method is called without parameters.</p>
                <p>Unary operators: <c>++</c>, <c>--</c>, <c>!</c>, <c>~</c>, <c>+</c>, <c>-</c>, and binary operators <c>+</c>, <c>-</c>, <c>*</c>, <c>/</c>, <c>%</c>, <c>&lt;&lt;</c>, <c>&gt;&gt;</c>, <c>&gt;&gt;&gt;</c>, <c>&amp;</c>, <c>^</c>, <c>|</c>, <c>&lt;</c>, <c>&lt;=</c>, <c>&gt;</c>, <c>&gt;=</c>, <c>&amp;&amp;</c>, <c>||</c> can be overloaded.</p>
                <p>Operators "Assign by" (<c>+=</c>, <c>*=</c>, etc.) can be overloaded also.</p>
                <p><b>Operators overloading is a powerful tool that greatly simplifies code writing and improves code readability.</b></p>
            </s>
            <s name="Multiple inheritance">
                <s name="Definition">
                    <p>Multiple inheritance is a feature of some object-oriented, including prototype-oriented  programming languages in which an object or class can inherit characteristics and features from more than one parent object or parent class.</p>
                    <p>In the example below, the "Brick" object is the "Building Material", but it is made from the "Clay" object. Clay plates and clay mugs are also made from "Clay", and consequently they inherit all clay properties, but they cannot be used as building material (I hope).</p>
                    <pic title="Multiple inheritance">graph/multiple_inheritance.svg</pic>
                    <p>Objects in the Goat programming language can have more than one prototype. In this case, the resulting object will contain all the properties and methods of all parents. Consider another example:</p>
                    <pic title="Multiple inheritance (another example)">graph/multiple_inheritance_2.svg</pic>
                    <c><![CDATA[
                        var mom = { a: 1 };

                        var dad = { b: 2, c: 3 }; 

                        var son = [mom, dad] -> { d: 4, e: 5 }; 

                        println(son.a); // output: "1"
                        println(son.b); // output: "2"
                        println(son.e); // output: "5"]]>
                    </c>
                    <p>If the array is specified as a parameter to the <c>-&gt;</c>operator, the resulting object will be formed from all objects in that array.</p>
                </s>
                <s name="Diamond inheritance">
                    <p>Let's look at one more example: </p>
                    <c><![CDATA[
                        var Animal = 
                        {
                            eat : $() 
                            {
                                println("'eat' method is called");
                            }
                        };

                        var Mammal = Animal -> 
                        {
                            drinkMilk : $()
                            {
                                println("'drinkMilk' method is called");
                            }
                        };

                        var WingedAnimal = Animal -> 
                        {
                            flap : $() 
                            {
                                println("'flap' method is called");
                            }
                        };

                        // A bat is a winged mammal
                        var Bat = [Mammal, WingedAnimal] -> 
                        {
                        };

                        var bat = new Bat();
                        bat.flap();
                        bat.drinkMilk();
                        bat.eat();]]>
                    </c>
                    <p>Output:</p>
                    <c><![CDATA[
                        'flap' method is called
                        'drinkMilk' method is called
                        'eat' method is called]]>
                    </c>
                    <p>The graph for it:</p>
                    <pic title="Diamond inheritance">graph/diamond_inheritance.svg</pic>
                    <p>Here, the links between the four objects form a rhomb (a "diamond"), and this situation is called "diamond inheritance". This situation is not a bug, on the contrary, it happens everywhere. However, there may be a problem, which is called...</p>
                </s>
                <s name="The diamond problem">
                    <p>Let's add a method <c>getOffspring()</c> to two classes:</p>
                    <c><![CDATA[
                        var Animal = 
                        {
                            eat : $() 
                            {
                                println("'eat' method is called");
                            }
                        };

                        var Mammal = Animal -> 
                        {
                            drinkMilk : $()
                            {
                                println("'drinkMilk' method is called");
                            },

                            getOffspring : $()
                            {
                                println("a new pet was born");
                            }
                        };

                        var WingedAnimal = Animal -> 
                        {
                            flap : $() 
                            {
                                println("'flap' method is called");
                            },

                            getOffspring : $()
                            {
                                println("we successfully laid an egg");
                            }
                        };

                        // A bat is a winged mammal
                        var Bat = [Mammal, WingedAnimal] -> 
                        {
                        };

                        var bat = new Bat();
                        bat.getOffstring();]]>
                    </c>
                    <p>The new graph for this structure is:</p>
                    <pic title="Diamond problem">graph/diamond_problem.svg</pic>
                    <p>Specifically, now we have two different methods with the same name (<c>getOffspring</c>) in the <c>Bat</c> object prototypes. The problem is: which one of these methods will be called if you call it from the object? The answer is: it depends on the order of search, which is determined by the results of the topological sorting of the prototypes graph.</p>
                </s>
                <s name="Topological sorting">
                    <p>The topological sorting of a graph is sorting in which all nodes of the graph are arranged in a linear order in which the node positioned not after all its ancestors. Consider some graph:</p>
                    <pic title="A graph">graph/topological_sorting_1.svg</pic>
                    <p>Result of topological sorting for this graph:</p>
                    <pic title="Topological sorting result">graph/topological_sorting_2.svg</pic>
                    <p>Thus, after topological sorting, <b>all nodes</b> (in our case, prototypes) <b>form a linear list, from left to right,</b> and:</p>
                    <l>
                        <i><b>Each prototype is always on the right of all its children;</b></i> 
                        <i>In multiple inheritance, <b>the first prototype is to the left of the next one,</b> so the order of prototypes is important.</i>
                    </l>
                </s>
                <s name="Dealing with the diamond problem">
                    <p><b>The Goat programming language determines the order of prototypes traversal as a result of the topological sorting of prototypes graph.</b> This defines behavior in two cases:</p>
                    <l>
                        <i>Property searching: the sorted list of prototypes is viewed <b>from left to right,</b> and the search ends as soon as the property is found;</i>
                        <i>Calling <c>init</c> methods when creating an object: the sorted list of prototypes is viewed <b>from right to left,</b> and each prototype is searched for an <c>init</c> method.</i>
                    </l>
                    <pic title="Solving diamond problem">graph/solving_diamond_problem.svg</pic>
                    <p>So, for the example above, calling the <c>getOffspring()</c> method from the <c>Bat</c> object will found this method in the <c>Mammal</c> object, because the <c>Mammal</c> object is to the left of the <c>WindedAnimal</c> object in the prototype list:</p>
                    <c><![CDATA[
                        var bat = new Bat();
                        bat.getOffstring(); //output: "a new pet was born"]]>
                    </c>
                </s>
                <s name="Constructor chain for the multiple inheritance">
                    <p>Now, based on the previous chapter, consider the example that contains constructor chain for the multiple inheritance with the diamond problem:</p>
                    <c><![CDATA[
                        var A =
                        {
                            init : $()
                            {
                                println('A');
                            }
                        };

                        var B  = A ->
                        {
                            init : $()
                            {
                                println('B');
                            }
                        };

                        var C = A ->
                        {
                            init : $()
                            {
                                println('C');
                            }
                        };

                        var D = C ->
                        {
                            init : $()
                            {
                                println('D');
                            }
                        };

                        var E = [B, D] ->
                        {
                            init : $()
                            {
                                println('E');
                            }
                        };

                        var F = E ->
                        {
                            init : $()
                            {
                                println('F');
                            }
                        };

                        var obj = new F();]]>
                    </c>
                    <p>Output:</p>
                    <c><![CDATA[
                        A
                        C
                        D
                        B
                        E
                        F]]>
                    </c>
                    <p>As discussed earlier, the calling order determined by topological sorting, starting from the deepest (right) prototype. For this case, the sorted prototype chain is: <c>F, E, B, D, C, A,</c> so initialization methods are called in the reversed order.</p>
                </s>
            </s>
            <s name="The main object">
                <p>All objects in the Goat programming language are derived from the base prototype, named <c>Object</c>. This prototype has some predefined useful methods, so, any Goat object has access to these methods. Consider all these methods below.</p>
                <s name="The 'instanceof' method">
                    <p>The method checks whether there is an object passed as an argument in the prototype chain. This is a way to determine if an object is instantiated from a specific prototype.</p>
                    <p>Consider this code:</p>
                    <c><![CDATA[
                        var A = { };
                        var B = A -> { };
                        var C = A -> { };

                        var X = new A();
                        var Y = new B();
                        var Z = new C();]]>
                    </c>
                    <p>Here,</p>
                    <l>
                        <i><c>X.instanceof(A)</c> returns <c>true</c> because object <c>A</c> is a prototype of object <c>X</c>;</i>
                        <i>but <c>X.instanceof(B)</c> and <c>X.instanceof(C)</c> returns <c>false</c> because objects <c>B</c> and <c>C</c> are not prototypes of object <c>X</c>;</i>
                        <i><c>Y.instanceof(B)</c> returns <c>true</c> because object <c>B</c> is a prototype of object <c>Y</c>;</i>
                        <i><c>Y.instanceof(A)</c> returns <c>true</c> because object <c>A</c> is a prototype of object <c>B</c> and object <c>B</c> is a prototype of object <c>Y</c>;</i>
                        <i><c>Y.instanceof(C)</c> returns <c>false</c> because object <c>C</c> is not a prototype of object <c>Y</c>;</i>
                        <i><c>Z.instanceof(C)</c> returns <c>true</c> because object <c>C</c> is a prototype of object <c>Z</c>;</i>
                        <i><c>Z.instanceof(A)</c> returns <c>true</c> because object <c>A</c> is a prototype of object <c>C</c> and object <c>C</c> is a prototype of object <c>Z</c>;</i>
                        <i><c>Z.instanceof(B)</c> returns <c>false</c> because object <c>B</c> is not a prototype of object <c>Z</c>.</i>
                    </l>
                    <p>Obviously, an <c>instanceof(Object)</c> call for <b>any</b> object will return <c>true</c>, because any object derived from <c>Object</c>:</p>
                    <c>undefined.instanceof(Object) // even that's true</c>
                </s>
                <s name="The 'clone' method">
                    <p>Returns a clone of the object, that is, a new object in which all properties are the same as in the source object.</p>
                    <p>The method creates a new object and then copies all the properties and methods from the original object to the new one. Now, if you change the copy, the original object will unchanged:</p>
                    <c><![CDATA[
                        var original = 
                        {
                            x : 10,
                            y : 20,
                            z : 30
                        };

                        var copy = original.clone();

                        copy.y = 40;

                        print(original);
                        print(copy);]]>
                    </c>
                    <p>Output:</p>
                    <c>{&quot;x&quot;:10,&quot;y&quot;:20,&quot;z&quot;:30}{&quot;x&quot;:10,&quot;y&quot;:40,&quot;z&quot;:30}</c>
                    <p><b>If possible, do not use <c>clone</c> method, inherit an object instead!</b> Cloning is an expensive operation, due to the need to copy each field.</p>
                    <p>However, note that this method clones only object, i.e. copies (does not clone) each property. It is not "deep cloning". That means that properties of properties will point to the same objects. Consider an example:</p>
                    <c><![CDATA[
                        var data =
                        {
                            x : 10,
                            y : 20,
                            z : 30
                        };
                    
                        var original = 
                        {
                            obj : data
                        };

                        var copy = original.clone();

                        copy.obj.y = 40;

                        print(original.obj.y); // 40]]>
                    </c>
                    <p>In this example, after cloning, the following object graph will be constructed:</p>
                    <pic title="Cloning">graph\cloning.svg</pic>
                    <p>The <c>clone</c> method is implicitly called in some other operations. For example, operators <c>-&gt;</c> (inherit) and <c>#</c> (write protect, see below) call this method. This method (however, like all the others) can be redefined. And then the operators will call the overridden method.</p>
                    <p>For example, you can prevent cloning an object, and instead of a clone, return the object itself:</p>
                    <c><![CDATA[
                        var original = 
                        {
                            x : 10,
                            y : 20,
                            z : 30,
                            
                            clone : $() 
                            {
                                return this;
                            }
                        };

                        var copy = original.clone(); // copy is the same object as the original ]]>
                    </c>
                </s>
                <s name="The 'flat' method">
                    <p>Returns a flat object, that is, an object that contains all the properties of the source object, as well as all properties of all prototypes of the source object.</p>
                    <p>The method creates a new object and then copies all the properties and methods from the original object and from all prototypes of the original object. Thus, a new object has no prototypes (that is, the prototype will be <c>Object</c>) but has all data from the original object:</p>
                    <c><![CDATA[
                        var A = 
                        {
                            x : 10
                        };

                        var B = A -> 
                        {
                            y : 20
                        };

                        var C = B-> 
                        {
                            z : 30
                        };

                        var F = C.flat();

                        print(F);]]>
                    </c>
                    <p>Output:</p>
                    <c>{&quot;x&quot;:10,&quot;y&quot;:20,&quot;z&quot;:30}</c>
                    <p>The new object is, as it were, "flat", the same as if it were declared thus:</p>
                    <c><![CDATA[
                        var F = 
                        {
                            x : 10,
                            y : 20,
                            z : 30
                        };]]>
                    </c>
                    <pic title="Original object before calling the 'flat' method">graph\before_flat.svg</pic>
                    <pic title="The result of calling the 'flat' method">graph\after_flat.svg</pic>
                    <p>Note that the copying is done starting from the most "deepest" prototype. Thus, if somewhere in the chain of prototypes some property was redefined, then the "flat" object will contain an overridden property:</p>
                    <c><![CDATA[
                        var A = 
                        {
                            x : 10
                        };

                        var B = A -> 
                        {
                            x : 15, // overrided
                            y : 20
                        };

                        var C = B-> 
                        {
                            z : 30
                        };

                        var F = C.flat();

                        print(F);]]>
                    </c>
                    <p>Output:</p>
                    <c>{&quot;x&quot;:15,&quot;y&quot;:20,&quot;z&quot;:30}</c>
                </s>
                <s name="The 'get' and 'set' methods">
                    <p>The <c>get</c> method returns the value of a property, for example:</p>
                    <c><![CDATA[
                        var obj = 
                        {
                            value : 7
                        };


                        var x = obj.get("value");
                        print(x); // output: "7"]]>
                    </c>
                    <p>It is the same as:</p>
                    <c>var x = obj[&quot;value&quot;];</c>
                    <p>The <c>set</c> method sets (changes) the value of a property:</p>
                    <c><![CDATA[
                        var obj = 
                        {
                            value : 7
                        };

                        obj.set("value", 11);
                        print(obj); // output: "{"value":11}"]]>
                    </c>
                    <p>It is the same as:</p>
                    <c>obj[&quot;value&quot;] = 11;</c>
                    <p>What's the point? <b>By overriding the <c>get</c> and <c>set</c> methods, you can change the operator <c>[ ]</c> behavior,</b> because using the operator <c>[ ]</c>:</p>
                    <l>
                        <i>for reading, implicitly calls the <c>get</c> method;</i>
                        <i>for writing, implicitly calls <c>set</c> method.</i>
                    </l>
                    <p>In fact, as a rule, the 'get' method returns the value of a property. But for some types it is redefined, for example, for arrays, it returns an item of an array, for strings, it returns a character. </p>
                    <p>So, you able to create own collection.</p>
                    <p>Example 1. Redefining a getter :</p>
                    <c><![CDATA[
                        var obj =
                        {
                            get : $(index)
                            {
                                switch(index)
                                {
                                    case 0:
                                        return "zero";
                                    case 1:
                                        return "one";
                                    case 2:
                                        return "two";
                                }
                                return "other";
                            }
                        };

                        var i;
                        for (i = 0; i < 5; ++i)
                        {
                            println(obj[i]);
                        }]]>
                    </c>
                    <p>Output:</p>
                    <c><![CDATA[
                        zero
                        one
                        two
                        other
                        other]]>
                    </c>
                    <p>Example 2. Multidimensional array (matrix) implementation. In this case, the <c>get</c> method has two arguments and the <c>set</c> method has three:</p>
                    <c><![CDATA[
                        var Matrix =
                        {
                            init : $(w, h)
                            {
                                this.w = w;
                                this.h = h;
                                this.data = [];
                                for (var i = 0; i < w * h; i++)
                                    data.push(0);

                            },
                            
                            get : $(x, y)
                            {
                                return data[y * w + x];
                            },
                            
                            set : $(x, y, value)
                            {
                                data[y * w + x] = value;
                            },
                        };

                        var m = new Matrix(5, 5);
                        m[1, 2] = 7;
                        m[3, 3] = 5;
                        for (var y = 0; y < m.h; y++)
                        {
                            for (var x = 0; x < m.w; x++)
                                print(" " + m[x, y]);
                            print('\n');
                        }]]>
                    </c>
                    <p>Output:</p>
                    <c><![CDATA[
                         0 0 0 0 0
                         0 0 0 0 0
                         0 7 0 0 0
                         0 0 0 5 0
                         0 0 0 0 0]]>
                    </c>
                </s>
                <s name="The 'contains' method">
                    <p>The method checks whether the object contains a property with the specified name.</p>
                    <c><![CDATA[
                        var obj = {value: 0};
                        println(obj.contains("value"); // true
                        println(obj.contains("abc"); // false]]>
                    </c>
                    <p>The second parameter of the method (it is optional) determines whether the property should be searched not only in the object but also in its prototypes:</p>
                    <c><![CDATA[
                        var proto = {value: 0};
                        var obj = proto -> { };
                        println(obj.contains("value"); // false
                        println(obj.contains("value", true); // true]]>
                    </c>
                    <p>This function has two main applications. First one - excluding unnecessary properties when enumerating all properties:</p>
                    <c><![CDATA[
                        var obj = {x: 10, y: 20, z: 30 };
                        for (var prop in obj)
                        {
                            if (obj.contains(prop))
                                println(prop + ": " + obj[prop]);
                        }]]>
                    </c>
                    <p>Output:</p>
                    <c><![CDATA[
                        x: 10
                        y: 20
                        z: 30]]>
                    </c>
                    <p>Without using this method, the <c>for..in</c> statement enumerates all properties, including inherited, including even inherited from the <c>Object</c> prototype, and output will be like:</p>
                    <c><![CDATA[
                        z: 30
                        y: 20
                        x: 10
                        clone: function
                        instanceof: function
                        flat: function
                        get: function
                        set: function
                        iterator: function
                        contains: function
                        !: function
                        !!: function
                        &&: function
                        ||: function
                        #: function]]>
                    </c>
                    <p>The second application is to determine the presence of a property with the <c>undefined</c> value. For example, if you read an unknown object property, the <c>[ ]</c> operator returns the <c>undefined</c> value:</p>
                    <c><![CDATA[
                        var obj = {};
                        println(obj["abc"]); // "undefined"]]>
                    </c>
                    <p>Suppose we added a property with the <c>undefined</c> value:</p>
                    <c><![CDATA[
                        var obj = {};
                        obj.abc = undefined;
                        println(obj["abc"]); // "undefined"]]>
                    </c>
                    <p>The result has not changed (obviously). However, the object now contains a property, i.e. the fact that this property was once added or changed to <c>undefined</c>. If this fact is important for your algorithm, you can use the <c>contains</c> method:</p>
                    <c><![CDATA[
                        var obj = {};
                        obj.abc = undefined;
                        println(obj.contains("abc")); // "true"]]>
                    </c>
                </s>
                <s name="The 'iterator' method">
                    <p>Returns an instance of an iterator object. Iterators are used to enumerate values in a sequence. See the <link>Iterators</link> chapter for more info.</p>
                </s>
            </s>
            <s name="Prototypes of built-in types" anchor="Prototypes of built-in types">
                <p>Each object of built-in type (string, integer, etc) has own built-in prototype:</p>
                <l>
                    <i><c>String</c> is the prototype for strings. Every time you define a string, for example, <c>var s = "hello, world"</c> you create a new object that has the <c>String</c> prototype;</i>
                    <i><c>Integer</c> is the prototype for integers;</i>
                    <i><c>Real</c> is the prototype for floating-point numbers;</i>
                    <i><c>Char</c> is the prototype for characters;</i>
                    <i><c>Boolean</c> is the prototype for booleans;</i>
                    <i><c>Null</c> is the prototype for <c>null</c> constant;</i>
                    <i><c>Array</c> is the prototype for all arrays;</i>
                    <i>functions are also objects! Each time you declare a function, for example, <c>var f=$(){ }</c> an object is created, the prototype of which is <c>Function</c>.</i>
                </l>
                <p>Other prototypes of built-in classes are: <c>Thread</c>, <c>Exception</c>, <c>File</c>, <c>StringBuilder</c>, <c>ByteArray</c>.</p>
                <p>Each prototype has, respectively, its properties, methods, and operators. For example, strings have a predefined <c>+</c> operator, which concatenating strings.</p>
                <p>Using a prototype, you can check whether the object is the right data type. Here is an example of a function, at the beginning of which it is checked whether the argument is an integer:</p>
                <c><![CDATA[
                    var f = $(value) 
                    {
                        if (value.instanceof(Integer)) 
                        {
                            //...
                        }
                    };]]>
                </c>
                <p>This is a graph that shows the relations between built-in prototypes. Here is not all, but most of built-in objects inherit the <c>Object</c>:</p>
                <pic title="Inheritance of some built-in types ">graph\built-in_types.svg</pic>
                <p>Some of these prototypes have their heirs, say, the <c>Exception</c> object:</p>
                <pic title="Inheritance of exceptions">graph\built-in_exception.svg</pic>
                <p>You can create a built-in object using the <c>new</c> operator, just like any other object:</p>
                <c>var b = new StringBuilder();</c>
                <p>However, the <c>new</c> operator works also for "primitive" objects, like integers and strings:</p>
                <c>var s = new String(&quot;hello&quot;);</c>
                <p>It is the same as:</p>
                <c>var s = &quot;hello!&quot;;</c>
                <p>What's the point? First, it is done for compatibility (all objects work same, as much as possible), and second, the <c>new</c> operator tries to convert the argument to its "own" type, and it can be used to convert types:</p>
                <c>var i = new Integer(&quot;1024&quot;); // 1024</c>
                <p>If the conversion fails, returns an object by default (0 for <c>Integer</c>, <c>Real</c> and <c>Number</c>), an empty string for <c>String</c>, <c>false</c> for <c>Boolean</c>), contrary with <c>valueof</c>' method (it returns <c>null</c>).</p>
                <p>Note, you can't call the <c>new</c> operator for some abstract prototypes (such <c>Iterator</c> or <c>File</c>), this will throw an <c>IlegalOperation</c> exception. To create an object of such type, you should call the appropriate method (in these cases <c>iterator()</c> and <c>open()</c>).</p>
            </s>
        </s>
        <s name="All about nothing">
            <p>There are special objects in the Goat programming language that means "nothing": <c>undefined</c>, <c>null</c> and <c>void</c>.</p>
            <s name="undefined">
                <p>As previously described, <c>undefined</c> means that no value has been assigned. Any variable defined using "var" keyword without an initial value has the value of <c>undefined</c>:</p>
                <c><![CDATA[
                    var v;
                    print(v); // output: "undefined"]]>
                </c>
                <p>Moreover, if you try to read the value of an undeclared variable, this value will also be <c>undefined</c>:</p>
                <c>print(n3j9v0kXXq);  // output: "undefined"</c>
                <p>The same is true if you read a non-existent property of an object:</p>
                <c><![CDATA[
                    var obj = { x: 10, y: 20 };
                    print(obj.z); // output: "undefined"]]>
                </c>
                <p>Is <c>undefined</c> an object? Yes. This is an object, and it even has its own prototype: <c>Undefined</c>. But you can not do anything with this object. You cannot change the properties of <c>undefined</c>, you can not call methods (except derived from the <c>Object</c>, say, <c>instanceof</c>). All you can is compare this object to <c>undefined</c>:</p>
                <c><![CDATA[
                    if (obj == undefined) 
                    {
                        //...
                    }]]>
                </c>
            </s>
            <s name="null">
                <p>The second special object. It means that the value was defined, that is, it is not equal to <c>undefined</c>, but it is empty. Null is not numeric, is not a string. This is "nothing".</p>
                <p>Unlike <c>undefined</c>, the <c>null</c> object is not created implicitly anywhere. It can be explicitly assigned to a variable or returned from a method:</p>
                <c><![CDATA[
                    var n = null;
                    
                    var f = $() 
                    {
                        //...
                        return null;
                    };]]>
                </c>
                <p><c>null</c> is not equal to <c>undefined</c>:</p>
                <c><![CDATA[
                    var u; // undefined
                    
                    if (u == null) // false!
                    {
                        //...
                    }
                    ]]>
                </c>
                <p>Is <c>null</c> an object? Yes. This is an object, like <c>undefined</c>, and it has its own prototype: <c>Null</c>. You can not add prototypes to <c>null</c>, but you can call methods, derived from the <c>Object</c>:</p>
                <c>print(null.instanceof(Null)); // "true"</c>
            </s>
            <s name="void">
                <p>The third data type, which combines the two previous ones.</p>
                <p>The <c>void</c> object has prototype <c>Void</c>", and both <c>Undefined</c> and <c>Null</c> inherits from <c>Void</c>. So, in other words, <b><c>undefined</c> is <c>void</c> and <c>null</c> is <c>void</c>.</b> This is used if you need to check with one operation whether the object is <c>null</c> or <c>undefined</c>:</p>
                <c><![CDATA[
                    var f = $(value) 
                    {
                        if (value == void) 
                        {
                            throw new Exception.IllegalArgument();
                        }
                        
                        //...
                    };]]>
                </c>
                <p>This is the same as:</p>
                <c><![CDATA[
                    var f = $(value) 
                    {
                        if (value == undefined || value == null) 
                        {
                            throw new Exception.IllegalArgument();
                        }
                        
                        //...
                    };]]>
                </c>
            </s>
            <s name="Operator ?. (void guard)">
                <p>You can not read a property from <c>undefined</c> or <c>null</c>. If you try to read a property from <c>void</c>, this will throw an exception <c>Exception.IllegalReference</c>. Thus, sometimes it is necessary to check whether a variable (most often an argument of a method) is a void. This avoids unintended consequences like exceptions. For example:</p>
                <c><![CDATA[
                    // safe 'exist' field reading from 'some.object.that.might.not.exist': 
                    if (some != void) 
                    {
                        if (some.object != void) 
                        {
                            if (some.object.that != void) 
                            {
                                if (some.object.that.might != void) 
                                {
                                    if (some.object.that.might.not != void) 
                                    {
                                        return some.object.that.might.not.exist;
                                    }
                                }
                            }
                        }
                    }
                    return 0;]]>
                </c>
                <p>This, probably, is not the shortest solution.</p>
                <p>Operator <c>?.</c> read a property (calls a method) only if a left object is not void, otherwise returns <c>undefined:</c></p>
                <c><![CDATA[
                    /* if object is void (null or undefined) then val = undefined,
                      else val = property: */
                    val = object?.property;
                    
                    /* if object is void (null or undefined) then val = undefined,
                      else val is result of method call: */
                    val = object?.method();]]>
                </c>
                <p>The result can be supplemented by the <b>or</b> (<c>||</c>) operator to change <c>undefined</c> to alternate value:</p>
                <c><![CDATA[
                    /* if object is void (null or undefined) then val = alternate,
                      else val = property: */
                    val = object?.property || alternate;
                    
                    /* if object is void (null or undefined) then val = alternate,
                      else val is result of method call: */
                    val = object?.method() || alternate;]]>
                </c>
                <p>Okay, let's rewrite the first example. Is not it, much shorter:</p>
                <c>return some?.object?.that?.might?.not?.exist || 0;</c>
            </s>
        </s>
        <s name="Objects write protection">
            <p>Objects can be write protected. After protecting, nothing can change (or add) properties or methods of the object.</p>
            <s name="Operator #">
                <p>This is a unary operator. It clones an object passed as a parameter (to the right of the operator) and then write protect the result of cloning. The object returned by the operator cannot be changed:</p>
                <c><![CDATA[
                    var obj = # 
                    {
                        x : 10,
                        y : 20
                    };
                    
                    obj.z = 30; // illegal operation!
                    ]]>
                </c>
                <p>The operator does not change the original object. Only its copy is protected:</p>
                <c><![CDATA[
                    var A = 
                    {
                        x : 10,
                        y : 20
                    };
                    
                    var B = #A;
                    
                    A.z = 30; // allowed
                    B.z = 30; // is not allowed
                    ]]>
                </c>
            </s>
            <s name="What happens when writing to a write protected object?">
                <p>The interpreter will immediately throw an exception <c>Exception.IllegalOperation</c>:</p>
                <c><![CDATA[
                    var A = # 
                    {
                        x: 10,
                        y: 20
                    };

                    try 
                    {
                        A.z = 0;
                    }
                    catch(e) 
                    {
                        if (e.instanceof(Exception.IllegalOperation))
                            print("oops!");
                    }]]>
                </c>
            </s>
            <s name="Why is it necessary to protect objects from writing?">
                <p>Obviously, to prevent changes that will lead to an error. A classic example is the creation of enumerations. The standard library contains many such enumerations. For example, file mode for i/o operations:</p>
                <c><![CDATA[
                    File.Mode = 
                    {
                        READ : "READ",
                        WRITE : "WRITE",
                        APPEND : "APPEND",
                        FULL : "FULL"
                    };]]>
                </c>
                <p>This enumeration is used when opening a file:</p>
                <c>var file = open(file_name, File.Mode.WRITE);</c>
                <p>However, if it were possible, intentionally or accidentally, to change the values of this enumeration, for example, like this:</p>
                <c>File.Mode.WRITE = &quot;READ&quot;;</c>
                <p>...continued use of this enumeration would result in an error. Therefore, such an object must be immutable. To protect object, just add operator <c>#</c> before object declaration.</p>
                <p>All objects of the standard library - classes, functions, enums, including built-in, i.e. Object, String, Integer, etc. - are write protected.</p>
            </s>
        </s>
        <s name="Iterators" anchor="Iterators">
            <p>An iterator is a special type that allows getting (enumerate) some objects in sequence, one after another. Based on iterators, some algorithms and language structures are work.</p>
            <s name="The 'Iterator' object">
                <p>The <c>Iterator</c> object is abstract, it means, it contains some stub methods that must be overridden in derived objects. It defines two methods:</p>
                <m name="valid" descr="Returns true if the iterator is valid, i.e. can return the next object."></m>
                <m name="next" descr="Returns the next object.">
                    <e><![CDATA[
                        var iter = collection.iterator();
                        while (iter.valid())
                        {
                            var obj = iter.next();
                            // do something with the object
                        }]]>
                    </e>
                </m>
            </s>
            <s name="The 'iterator' method">
                <p>The instance of the <c>Iterator</c> object returns by the <c>iterator</c> method. This method is defined in the <c>Object</c>, so, each object inherits it and can override it. The default implementation returns an iterator that enumerates names of all properties:</p>
                <c><![CDATA[
                    var obj =
                    {
                        x : 7,
                        y : 11,
                        z : "test"
                    };

                    var iter = obj.iterator();

                    while(iter.valid())
                    {
                        var key = iter.next();
                        if (obj.contains(key))
                            println("" + key + " = " + obj[key]);
                    }]]>
                </c>
                <p>Output:</p>
                <c><![CDATA[
                    x = 7
                    y = 11
                    z = test]]>
                </c>
                <p>This behavior is redefined for some objects. For example, for strings, the <c>iterator</c> method returns an iterator that enumerates all characters of this string:</p>
                <c><![CDATA[
                    var s = "test";
                    var i = s.iterator();

                    while(i.valid())
                    {
                        println(i.next());
                    }]]>
                </c>
                <p>Output:</p>
                <c><![CDATA[
                    t
                    e
                    s
                    t]]>
                </c>
            </s>
            <s name="The 'for..in' loop">
                <p>In fact, this statement implicitly calls the <c>iterator</c> method from an object and then does the <c>while</c> loop, calling the <c>valid</c> and the <c>next</c> methods from a returned iterator.</p>
                <p>The previous example can be rewritten as:</p>
                <c><![CDATA[
                    var obj =
                    {
                        x : 7,
                        y : 11,
                        z : "test"
                    };

                    for (var key in obj)
                    {
                        if (obj.contains(key))
                            println("" + key + " = " + obj[key]);
                    }]]>
                </c>
                <p>So, any object can be transformed into an enumerable collection or generator, all you need is to define your own iterator and override the <c>iterator</c> method.</p>
            </s>
            <s name="Generators">
                <p>A generator is an iterator that does not enumerate items of a collection (object, array, etc) but generates values itself.</p>
                <p>The built-in <c>range</c> method is a generator: it returns values from some range:</p>
                <c><![CDATA[
                    for (var v in range(10))
                    {
                        print(v);
                    }]]>
                </c>
                <p>Output:</p>
                <c>0123456789</c>
                <p>As an example of a custom generator, let's write a generator that returns squares of numbers from 0 to 10:</p>
                <c><![CDATA[
                    // Iterator
                    var SquareIterator =
                    {
                        init : $()
                        {
                            this.value = -1;
                        },
                        
                        valid : $()
                        {
                            return value < 10;
                        },
                        
                        next : $()
                        {
                            value++;
                            return value * value;
                        }
                    };

                    // Generator
                    var SquareNumbers =
                    {
                        iterator : $()
                        {
                            return new SquareIterator();
                        }
                    };

                    // Loop
                    for (var num in SquareNumbers)
                    {
                        println(num);
                    }]]>
                </c>
                <p>Output:</p>
                <c><![CDATA[
                    0
                    1
                    4
                    9
                    16
                    25
                    36
                    49
                    64
                    81
                    100]]>
                </c>
            </s>
        </s>
        <s name="Threads">
            <p>The Goat programming language supports threads. A thread of execution is the sequence of programmed instructions that managed independently by a scheduler. In other words, threads are the ability to execute two or more sections of code at the same time.</p>
            <p>Each running program contains at least one thread. Goat does not separate the "main" and "non-main" threads - each thread can initiate a new thread, and each thread can stop the execution of another thread (if it has a reference to this). The program ends only when all threads are completed.</p>
            <s name="Threads declaration">
                <p>Threads are declared in the same way as functions, but the <c>thread</c> keyword is used instead of the <c>function</c> keyword:</p>
                <c><![CDATA[
                    var a = thread() 
                    {
                        for (var i = 0; i < 10; i++)
                            print('A');
                    };]]>
                </c>
                <p>The <c>thread</c> keyword can be changed to two dollar signs <c>$$</c> (for shortness):</p>
                <c><![CDATA[
                    var a = $$() 
                    {
                        for (var i = 0; i < 10; i++)
                            print('A');
                    };]]>
                </c>
            </s>
            <s name="Starting">
                <p>To start a thread, need to call the <c>run()</c> method:</p>
                <c><![CDATA[
                    var a = thread() 
                    {
                        for (var i = 0; i < 10; i++)
                            print('A');
                    };
                    
                    a.run();]]>
                </c>
                <p>Output:</p>
                <c>AAAAAAAAAA</c>
                <p>You can re-run a thread that is already in progress. The second instance of a thread will be created and started.</p>
                <c><![CDATA[
                    var a = thread() 
                    {
                        for (var i = 0; i < 10; i++)
                            print('A');
                    };
                    
                    a.run();
                    a.run();]]>
                </c>
                <p>Output:</p>
                <c>AAAAAAAAAAAAAAAAAAAA</c>
                <p>You can run two, three, as many threads as you need, and they will run at the same time:</p>
                <c><![CDATA[
                    var a = thread() 
                    {
                        for (var i = 0; i < 10; i++)
                            print('A');
                    };

                    var b = thread() 
                    {
                        for (var i = 0; i < 10; i++)
                            print('B');
                    };

                    a.run();
                    b.run();]]>
                </c>
                <p>The output is something like this:</p>
                <c>ABABABABABABABABABAB</c>
                <p>Note: there is no guarantee of the order of execution of threads. The result may well be:</p>
                <c>AABBBAAAABABBAABABAB</c>
                <p>It is guaranteed that every thread will be executed from beginning to end.</p>
                <p>The <c>Thread</c> prototype is derived from the <c>Function</c>. So, all function features are applicable for the threads. Say, you can run thread as function (if you need it, though not likely):</p>
                <c><![CDATA[
                    var t = thread()
                    {
                        for (var i = 0; i < 10; i++)
                            print(i);
                    };

                    t();]]>
                </c>
            </s>
            <s name="The 'Runner' object">
                <p>The 'run' method returns an instance of the 'Runner' object, which has the set of methods to started thread control.</p>
                <m name="kill">
                    <d>Kills the thread (without resuming ability) and removes it from the thread list. Returns <c>true</c> if the thread was killed.</d>
                    <e><![CDATA[
                        var b = thread() 
                        {
                            // this thread will never end if anybody does not stop it!
                            while(true)
                                print('B');
                        };

                        var r = b.run();
                        for (var i = 0; i < 10; i++)
                            print('A');
                        r.kill();]]>
                    </e>
                    <n>The output is something like this: <c>BBABBABBABBBABBABBABBBABBABBABBBABB</c>. Obviously, this approach allows controlling some "infinite" processes, such as services, listeners, etc.</n>
                </m>
                <m name="alive">
                    <d>Returns <c>true</c> if the thread is alive (not finished yet or not killed).</d>
                    <e><![CDATA[
                        var b = thread() 
                        {
                            for (var i = 0; i < 10; i++)
                                print('B');
                        };

                        var r = b.run();
                        while(r.alive())
                            print('A');]]>
                    </e>
                </m>
                <m name="suspend">
                    <d>Suspends the thread, returns <c>true</c> if the thread is suspended.</d>
                </m>
                <m name="resume">
                    <d>Resumes the suspended thread, returns <c>true</c> if the thread is resumed.</d>
                    <e><![CDATA[
                        var t = thread() 
                        {
                            // infinite thread
                            while(true)
                                print('#');
                        };

                        // run the thread
                        var r = t.run();

                        // print "AAAAA", result should be like "#A##A##A##A##A"
                        for (var i = 0; i < 5; i++)
                            print('A');
                            
                        // suspend the thread then print "BBBBB"
                        r.suspend();
                        for (var i = 0; i < 5; i++)
                            print('B');

                        // resume then print 'CCCCC'
                        r.resume();
                        for (var i = 0; i < 5; i++)
                            print('C');

                        // kill the thread
                        r.kill();

                        // Output: "#A##A##A##A##A##BBBBB##C##C##C##C##C##"]]>
                    </e>
                </m>
                <m name="join">
                    <d>Joins the thread, i.e. suspends the current thread while the joined thread is alive.</d>
                    <e><![CDATA[
                        var t = thread() 
                        {
                            for (var i = 0; i < 5; i++)
                                print('A');
                        };

                        var r = t.run();
                        r.join();
                        for (var i = 0; i < 5; i++)
                            print('B');
                            
                        // Output: "AAAAABBBBB"]]>
                    </e>
                </m>
                <m name="id">
                    <d>Returns numeric identifier of the thread (≥0).</d>
                </m>
            </s>
            <s name="Getting a reference to the current thread">
                <p>For some cases is needed to get an instance of the <c>Runner</c> object for the current thread. The static <c>Thread.current</c> method returns it. Example (prints the current thread Id):</p>
                <c><![CDATA[
                    var r = Thread.current();
                    println(r.id());]]>
                </c>
            </s>
            <s name="Passing parameters to a thread">
                <p>All parameters of the <c>run</c> method are passed to the thread as if it were a simple function call:</p>
                <c><![CDATA[
                    var t = thread(count)
                    {
                        for (var i = 0; i < count; i++)
                            print(i);
                    };
                    t.run(10); // output: "0123456789" ]]>
                </c>
            </s>
            <s name="Synchronization">
                <p>Two or more threads can access the same data. Simultaneous reading or writing can lead to an incorrect result: if one thread reads an object and the other thread writes it (i.e. adds or changes properties), in some cases the first thread may read incorrect data (if at the time of reading some data has changed, and some are not). Obviously, in order to preserve the consistency of the data, during the access to such a shared object, concurrent threads must be blocked - until one reads, the other can not write; until one writes, the other cannot read.</p>
                <p>The Goat programming language provides some tools for synchronization.</p>
                <s name="Critical section">
                    <p>This is the simplest primitive of synchronization. Inside the critical section, the interpreter does not switch threads.</p>
                    <p>A critical section is a block of code after the <c>lock</c> keyword:</p>
                    <c><![CDATA[
                        lock
                        {
                            // some code here...
                        }]]>
                    </c>
                    <p>The <c>lock</c> keyword can be used as a method name. A critical section is defined as the <c>lock</c> keyword and any statement after it. It doesn't have to be a block statement:</p>
                    <c>lock ++value;</c>
                    <p>Critical sections should be made very short, it is recommended to do it only for reading/writing one-two-three variables, as a long suspend of other threads can negatively affect the execution of the script. However, is the fastest way of synchronization.</p>
                    <p>Example: writing a variable from 7 threads simultaneously:</p>
                    <c><![CDATA[
                        var x = 0;

                        var t = thread()
                        {
                            var i;
                            for (i = 0; i < 100; ++i)
                            {
                                lock
                                {
                                    ++x;
                                }
                            }
                        };

                        var r1 = t.run();
                        var r2 = t.run();
                        var r3 = t.run();
                        var r4 = t.run();
                        var r5 = t.run();
                        var r6 = t.run();
                        var r7 = t.run();
                        r1.join();
                        r2.join();
                        r3.join();
                        r4.join();
                        r5.join();
                        r6.join();
                        r7.join();
                        println(x); // output: "700"]]>
                    </c>
                    <p>What happens if we wouldn't use a critical section here? The increment <c>++x</c> is not an atomic operation, it takes three steps:</p>
                    <l>
                        <i>Loading value of a variable (or a property);</i>
                        <i>Increment;</i>
                        <i>Storing a new value to a variable.</i>
                    </l>
                    <p>Let's say the initial value of variable 0 and two threads increment it.</p>
                    <l>
                        <i>The first thread loads the value of the variable (0).</i>
                        <i>The second thread loads the value of the variable (0, because the first thread did not change it yet).</i>
                        <i>The first thread increments the value (1).</i>
                        <i>The second thread increments the value (1, because it "does not know" that the first thread did something - the threads are independent).</i>
                        <i>The first thread stores the value to the variable (1).</i>
                        <i>The second thread stores the value to the variable (rewrites 1 to 1, but should be 2 - error).</i>
                    </l>
                    <p>This example does not take into account the fact that threads do not necessarily execute their instructions strictly by one. In fact, the first thread can execute any number of instructions before passing control to another thread. But in any case, <b>unsynchronized access to shared resources can lead to serious errors</b> that hard to detect and fix.</p>
                </s>
            </s>
        </s>
        <s name="Command line arguments">
            <p>As previously described, all arguments started with two hyphens are internal parameters of the interpreter; the first argument which is not an option is the name of the script file. All next arguments are sent to the script and can be read from the special pseudo-array named <b>parg</b>.</p>
            <p>The <c>parg</c> object is always created by the interpreter when the script starts. It contains zero or more <c>String</c> objects.</p>
            <p>Example. The script that reads file specified as the first argument and makes a copy (write another file) with the name specified as the second argument. </p>
            <c><![CDATA[
                import "io.goat";

                if (parg.length() != 2)
                {
                    println("syntax: goat copy.goat <source> <destination>");
                    exit(-1);
                }

                var data = load(parg[0]);
                if (!data)
                {
                    println("could not open '" + parg[0] + '\'');
                    exit(-1);
                }

                var dst = open(parg[1], File.Mode.WRITE);
                if (!dst)
                {
                    println("could not open '" + parg[1] + "' for writing");
                    exit(-1);
                }

                var len1 = data.length();
                var len2 = dst.write(data);
                println("Read " + len1 + " bytes, " + len2 + " bytes written.");
                dst.close();]]>
            </c>
            <p>Note that the <c>parg</c> object is pseudo-array. It inherited from <c>ArrayLike</c> prototype (see <link>Prototypes of built-in types</link> chapter). This object like a read-only array: you can read length of this and get an item by index, but can not modify it.</p>
        </s>
    </s>
    
    <s name="Standard library">
        <p>The standard library contains functions and classes for solving common tasks.</p>
        <p>All the functionality of the standard library is divided into two parts: <b>internal</b> (as part of the interpreter core) and <b>external.</b></p>
        <p>The functionality of the inner part of the library is written in C++ language and is the minimum required set for solving most tasks. This functionality includes platform-dependent components, such as working with files. No additional modules are required to use the internal library, these classes and functions are always available.</p>
        <p>The external library is written in the Goat language. It is a set of files that contain separate classes for solving various tasks. To use this class from the library, you need to link the corresponding file using the <c>import</c> keyword.</p>
        <s name="Internal (core) library">
            <s name="Functions" anchor="Built-in functions">
                <s name="Input/output">
                    <m name="print" descr="Converts an object to a string and sends this string to standard output.">
                        <a name="object" type="any type" descr="an object"/>
                        <e><![CDATA[
                            print("Hello");
                            print(2 + 3);
                            print(0.01);
                            print(false);
                            print(null);]]>
                        </e>
                    </m>
                    <m name="println" descr="Converts an object to a string and sends this string to standard output with a newline at the end.">
                        <a name="object" type="any type" descr="an object"/>
                        <e><![CDATA[
                            println("Hello");]]>
                        </e>
                    </m>
                    <m name="getc" descr="Reads one character from the standard input. Returns null if no characters (end-of-file is reached).">
                        <e><![CDATA[
                            while(true) 
                            {
                                var c = getc();
                                if (c == null)
                                    break;
                                print(c);
                            }]]>
                        </e>
                    </m>
                    <m name="gets" descr="Reads characters from the standard input and stores them as a string until a newline character or the end-of-file is reached.">
                        <e><![CDATA[
                            while(true) 
                            {
                                var s = gets();
                                println(s);
                            }]]>
                        </e>
                    </m>
                    <m name="open" descr="Opens a file.">
                        <a name="fname" type="String" descr="file name"/>
                        <a name="mode" type="File.Mode" descr="mode, see below"/>
                        <e><![CDATA[
                            var file = open("reference.xml", File.Mode.READ);
                            var data = file.read(256); // read first 256 bytes]]>
                        </e>
                        <n>Returns an instance of <c>File</c>, or <c>null</c> if the file can not be opened. For all modes that allow writing, in case if file not exists, the new one is created.</n>
                    </m>
                    <p>Available file modes are:</p>
                    <l>
                        <i><c>File.Mode.READ</c>, allows only to read a file, writing operations are blocked;</i>
                        <i><c>File.Mode.WRITE</c>, only write operations;</i>
                        <i><c>File.Mode.APPEND</c>, only write operations, new data will be added to the end of the existing file;</i>
                        <i><c>File.Mode.FULL</c>, both reading and writing.</i>
                    </l>
                    <p>See description of <link>File</link> class for more details.</p>
                </s>
                <s name="Mathematical">
                    <m name="abs" descr="Computes absolute value.">
                        <a name="arg" type="Integer | Real" descr="a value"/>
                        <e>var x = abs(-123); // 123</e>
                        <n>The returned value has the same type as the argument.</n>
                    </m>
                    <m name="acos" descr="Returns the arc cosine of arg, expressed in radians.">
                        <a name="arg" type="Real" descr="a value"/>
                        <e>var x = acos(-1); // 3.1415927...</e>
                    </m>
                    <m name="asin" descr="Returns the arc sine of arg, expressed in radians.">
                        <a name="arg" type="Real" descr="a value"/>
                        <e>var x = asin(1); // 1.5707963...</e>
                    </m>
                    <m name="atan" descr="Returns the arc tangent of arg, expressed in radians.">
                        <a name="arg" type="Real" descr="a value"/>
                    </m>
                    <m name="atan2" descr="Returns arc tangent from 2 arguments, expressed in radians.">
                        <a name="y" type="Real" descr="y-coordinate"/>
                        <a name="x" type="Real" descr="x-coordinate"/>
                        <e>var x = atan2(1, 1); // 0.7853982 radians, i.e. 45 degrees</e>
                    </m>
                    <m name="cbrt" descr="Returns the cubic root of arg.">
                        <a name="arg" type="Real" descr="a value"/>
                        <e>var x = cbrt(27); // 3</e>
                    </m>
                    <m name="cos" descr="Returns the cosine of an angle of arg radians.">
                        <a name="arg" type="Real" descr="a value"/>
                        <e>var x = cos(60.0 * PI / 180.0); // 0.5</e>
                    </m>
                    <m name="exp" descr="Computes exponential function.">
                        <a name="arg" type="Real" descr="value of the exponent"/>
                        <e>var x = exp(5); // 148.413159</e>
                    </m>
                    <m name="log">
                        <d>Computes natural logarithm (reverse operation to <c>exp</c>).</d>
                        <a name="arg" type="Real" descr="value whose logarithm is calculated"/>
                        <e>var x = log(exp(5)); // 5</e>
                    </m>
                    <m name="log2" descr="Computes binary logarithm.">
                        <a name="arg" type="Real" descr="value whose logarithm is calculated"/>
                        <e>var x = log2(1024); // 10</e>
                    </m>
                    <m name="log10" descr="Computes common (base-10) logarithm.">
                        <a name="arg" type="Real" descr="value whose logarithm is calculated"/>
                        <e>var x = log2(1000); // 3</e>
                    </m>
                    <m name="round" descr="Returns the rounded (integer) value of arg.">
                        <a name="arg" type="Real" descr="a value"/>
                        <e><![CDATA[
                            var x = round(2.8); // 3
                            var y = round(-2.1); // -2]]></e>
                        <n>Return type is <c>Integer</c>.</n>
                    </m>
                    <m name="sin" descr="Returns the sine of an angle of arg radians.">
                        <a name="arg" type="Real" descr="a value"/>
                        <e>var x = sin(PI/2); // 1</e>
                    </m>
                    <m name="sqrt" descr="Returns the square root of arg.">
                        <a name="arg" type="Real" descr="a value"/>
                        <e>var x = sqrt(64); // 8</e>
                    </m>
                    <m name="tan" descr="Returns the tangent of an angle of arg radians.">
                        <a name="arg" type="Real" descr="a value"/>
                    </m>
                </s>
                <s name="Other">
                    <m name="exit" descr="Terminates the current thread and passes a value to a handler">
                        <a name="value" type="Integer" descr="a value (optional)"/>
                        <e><![CDATA[
                            if (error)
                            {
                                exit(-1);
                            }]]>
                        </e>
                        <n>If the thread was alone, terminates the execution of the script. In this case, the returned value is written to <c>ERRORLEVEL</c> and can be analyzed by the calling script. </n>
                    </m>
                    <m name="clock" descr="Returns current system time in nanoseconds.">
                        <e><![CDATA[
                            var wait = $(time)
                            {
                                var begin = clock();
                                var diff = 0;
                                do
                                {
                                    diff = clock() - begin;
                                } while(diff < time * 1000000000);
                            };

                            var i;
                            for (i = 5; i > 0; i--)
                            {
                                print("" + i + "\n");
                                wait(1);
                            }]]>
                        </e>
                        <n>The example shows a simple implementation of delay and countdown using the 'clock' function. The function returns the time span value between the begin of the 'system epoch' (it depends from the platform) and the current time point. In itself, this value is useless, as a rule, the difference between the two clock values is used.</n>
                    </m>
                    <m name="range" descr="Returns a collection representing a range of integer numbers.">
                        <a name="begin | count" type="Integer" descr="A starting value of a range (if ending value is defined), or count of items of the range (starting from 0)"/>
                        <a name="end" descr="An ending value (optional, range does not include this value)"/>
                        <a name="step" descr="A step, i.e. increment of the next item (optional, default 1)"/>
                        <e><![CDATA[
                            for (var i in range(5)) print(i);           // 01234
                            for (var i in range(5, 10)) print(i);       // 56789
                            for (var i in range(0, 10, 3)) print(i);    // 0369
                            for (var i in range(9, 0, -2)) print(i);....// 97531]]>
                        </e>
                        <n>If <c>step &gt; 0</c> but <c>end &lt; begin</c>, and vice-versa, the function returns an empty collection (contains 0 values).</n>
                    </m>
                    <m name="uid">
                        <d>Returns an instance of <c>UId</c> class, which is a unique object (contains a 128-bit value that never repeats).</d>
                        <e>print(uid()); // an output something like &quot;8fb959ea0198df83&quot; but unique each time</e>
                        <n>The likelihood of collision (matching of <c>UId</c> with other identifiers generated at other times) is <b>very</b> low. A unique identifier can be used as a key in some data types.</n>
                    </m>
                </s>
            </s>
            <s name="Classes">
                <s name="Input/output" numbered="true">
                    <s name="File" anchor="File">
                        <p>The class for file reading/writing.</p>
                        <p>Files are opened by the <c>open</c> function (see above). The <c>open</c> function returns an object of <c>File</c> type, or <c>null</c> if the file could not be found or could not be open. The <c>File</c> class contains methods for reading/writing and some predefined fields, used in <c>open</c> and <c>seek</c> methods.</p>
                        <s name="Methods">
                            <m name="read">
                                <d>Reads a file and returns a <c>ByteArray</c> object with data (see also: <link>ByteArray</link>).</d>
                                <a name="count" type="Integer" descr="number of bytes to read"/>
                                <e><![CDATA[
                                    var f = open("data.txt", File.Mode.READ);
                                    var a = f.read(1024); // read first 1024 bytes ]]>
                                </e>
                                <n>If the number of bytes exceeds the file size, the method will return as many bytes as it could read. The position indicator of the file is advanced by the total amount of bytes read. The method throws the <c>Exception.IllegalOperation</c> exception if the file can not be read (opened for writing or closed).</n>
                            </m>
                            <m name="getc">
                                <d>Reads one byte from the file and returns it (as <c>Integer</c>), or <c>null</c> if reading unsuccessful.</d>
                                <e><![CDATA[
                                    var f = open("data.txt", File.Mode.READ);
                                    var byte = f.getc(); // read the first byte ]]>
                                </e>
                            </m>
                            <m name="write">
                                <d>Writes data to the file, to the current position. Returns number of bytes that was actually written.</d>
                                <a name="data" type="ByteArray" descr="data for writing"/>
                                <e><![CDATA[
                                    var f = open("data.txt", File.Mode.WRITE);
                                    var t = "This string will be written to the file.";
                                    f.write(t.encode("utf8"));]]>
                                </e>
                                <n>The position indicator of the file is shifted and points after the last written byte. The method throws the <c>Exception.IllegalOperation</c> exception if the file can not be written (opened for reading or closed).</n>
                            </m>
                            <m name="flush">
                                <d>Flushes all data from the write buffer to disc, i.e. physically write data.</d>
                                <e><![CDATA[
                                    var f = open("data.txt", File.Mode.WRITE);
                                    var t = "This string will be immediately written to the file.";
                                    f.write(t.encode("utf8"));
                                    f.flush();]]>
                                </e>
                            </m>
                            <m name="eof">
                                <d>Checks whether the end of file indicator associated with file is set, returning <c>true</c> if it is.</d>
                                <e><![CDATA[
                                    var f = open("data.txt", File.Mode.READ);
                                    while (!f.eof())
                                    {
                                        // read the file in chunks of size 1024 bytes
                                        var a = f.read(1024);
                                        // ...
                                    }]]>
                                </e>
                            </m>
                            <m name="position">
                                <d>Returns the current value of the position indicator of the file.</d>
                                <e><![CDATA[
                                    var f = open("data.txt", File.Mode.READ);
                                    f.seek(0, File.Origin.END);
                                    var len = f.position(); // length of file]]>
                                </e>
                            </m>
                            <m name="seek">
                                <d>Sets the position indicator associated with the file to a new position.</d>
                                <a name="offset" type="Integer" descr="number of bytes to offset from origin"/>
                                <a name="origin" type="File.Origin" descr="origin, one of: File.Origin.BEGIN, File.Origin.END or File.Origin.CURRENT"/>
                                <e><![CDATA[
                                    var f = open("data.txt", File.Mode.READ);
                                    f.seek(0, File.Origin.END); // go to end of the file
                                    var len = f.position(); // take position (position at the end is the length of the file)
                                    f.seek(0, File.Origin.BEGIN); // now, go to begin
                                    var data = f.read(len); // read the whole file]]>
                                </e>
                            </m>
                            <m name="close">
                                <d>Closes the file. All data flushes to the disc and the file descriptor is cleared. After closing, the file cannot be reading or writing.</d>
                                <e><![CDATA[
                                    var f = open("data.txt", File.Mode.WRITE);
                                    var t = "This string will be written to the file.";
                                    f.write(t.encode("utf8"));
                                    f.close();]]>
                                </e>
                                <n>This is an optional operation. All files are closes anyway: when you lose the last reference to the <c>File</c> instance, the garbage collector cleans it; if not - the file will be closed at the end of the script execution. But each opened file takes some resources, and if you want to save memory, close the file manually if it is not needed more.</n>.
                            </m>
                        </s>
                        <s name="Fields">
                            <h name="File.Mode">
                                <p>The object contains constants for file access mode, is used as an argument for <c>open</c> function.</p>
                                <c><![CDATA[
                                    File.Mode =
                                    {
                                        READ : ?,
                                        WRITE : ?,
                                        APPEND : ?,
                                        FULL : ?
                                    };]]>
                                </c>
                                <p>Usage:</p>
                                <c>var f = open("data.txt", File.Mode.READ);</c>
                                <p>The question mark <c>?</c> means that in fact a constant is assigned a value (this is usually a string), but it depends on the implementation. Never use a value (&quot;magic string&quot; or &quot;magic number&quot;) instead of a constant!</p>
                                <p>Very bad example, please do not repeat it:</p>
                                <c>var f = open(&quot;data.txt&quot;, &quot;READ&quot;); // yes, it works now... but can fail later</c>
                            </h>
                            <h name="File.Origin">
                                <p>The object contains constants for origin, is used as an argument for <c>File.seek</c> method.</p>
                                <c><![CDATA[
                                    File.Origin =
                                    {
                                        BEGIN : ?,
                                        END : ?,
                                        CURRENT : ?
                                    };]]>
                                </c>
                            </h>
                        </s>
                    </s>
                </s>
                <s name="Sequences" numbered="yes">
                    <s name="ByteArray" anchor="ByteArray">
                        <p>The class for storing an array of bytes.</p>
                        <p>The Goat interpreter does not have a separated type for bytes representing. The <c>Integer</c> type is used for this purpose. However, each <c>Integer</c> object takes much more memory than 1 byte. If you need to store an array of bytes, do not create an array of integers, use <c>ByteArray</c> class instead.</p>
                        <p>ByteArray class is used in files read/write operations.</p>
                        <s name="Methods">
                            <m name="length" descr="Returns length of the byte array."/>
                            <m name="push">
                                <d>Appends a byte to the byte array.</d>
                                <a name="byte" type="Integer" descr="byte, valid values [0...255]"/>
                                <e><![CDATA[
                                    var a = new ByteArray();
                                    a.push(0); ]]>
                                </e>
                            </m>
                            <m name="decode">
                                <d>Decodes the byte array as text and returns a string.</d>
                                <a name="encoding" type="String" descr="encoding; now only &quot;utf8&quot; is supported"/>
                                <e><![CDATA[
                                    // open the file and decode it as UTF-8
                                    var file = open("data.txt", File.Mode.READ);
                                    file.seek(0, File.Origin.END); // go to end of the file
                                    var len = file.position(); // take the length of the file
                                    file.seek(0, File.Origin.BEGIN); // now, go to begin
                                    var raw = file.read(len); // read the whole file
                                    var text = raw.decode("utf8"); // decode]]>
                                </e>
                            </m>
                        </s>
                        <s name="Operators">
                            <o name="[ ]" descr="Access to a separate byte by index.">
                                <e><![CDATA[
                                    var a = new ByteArray();
                                    a.push(0); 
                                    a.push(7);
                                    a.push(11);
                                    
                                    print(a[1]); // 7]]>
                                </e>
                            </o>
                        </s>
                    </s>
                    <s name="StringBuilder">
                        <p>The class for strings constructing.</p>
                        <p>The Goat programming language has immutable strings. It prevents many errors, but in some cases constructing of long string takes a lot of time, because for each iteration Goat creates a new string. For example:</p>
                        <c><![CDATA[
                            // some coordinates:
                            var c = { x: 10, y: 20, z: 30};
                            
                            // build string:
                            var str = "X=" + c.x + ", Y=" + c.y + ", Z=" + c.z;]]>
                        </c>
                        <p>It works, yes, but it is not a better solution. Goat splits the long expression and creates a new string (which, in turn, involves the creation of a new array of characters, and copying of the original array) on each step:</p>
                        <c><![CDATA[
                            "X=" + c.x
                            -> "X=10"
                            ... + ", Y=" 
                            -> "X=10, Y="
                            ... + c.y
                            -> "X=10, Y=20"
                            ... + ", Z=" 
                            -> "X=10, Y=20, Z="
                            ... + c.z
                            -> "X=10, Y=20, Z=30"]]>
                        </c>
                        <p>So, five strings will be constructed. What about thousands of strings? Say you have an array and you need to make a string from it. A lot of time, a lot of memory! Or, you can use <b>StringBuilder.</b></p>
                        <c><![CDATA[
                            // some coordinates:
                            var c = { x: 10, y: 20, z: 30};
                            
                            // build string:
                            var b = new StringBuilder();
                            b << "X=" << c.x << ", Y=" << c.y << ", Z=" << c.z;
                            var str = b.toString();]]>
                        </c>
                        <p>Much better.</p>
                        <p>StringBuilder has an array to hold characters. This array grows when new items (characters, strings, etc) added. This class does not create a new string for each addition. Thus, the construction of a long string takes much less time and memory.</p>
                        <s name="Methods">
                            <m name="add" descr="Appends string representation of an object to the sequence.">
                                <a name="object" type="any type" descr="an object"/>
                                <e><![CDATA[
                                    var b = new StringBuilder();
                                    b.append("test");
                                    b.append('#');
                                    b.append(123);
                                    print(b); // output: "test#123]]>
                                </e>
                                <n>If there are multiple arguments, each argument is converted to a string and added to the sequence.</n>
                            </m>
                            <m name="string" descr="Returns a string representing the data in this sequence.">
                                <e><![CDATA[
                                    var b = new StringBuilder();
                                    b.append("hello");
                                    b.append(", ");
                                    b.append("world");
                                    var s = b.string(); // contains "hello, world"]]>
                                </e>
                            </m>
                            <m name="data">
                                <d>Synonym for the <c>string</c> method.</d>
                            </m>
                            <m name="length" descr="Returns the length of the sequence."/>
                        </s>
                        <s name="Operators">
                            <o name="&lt;&lt;" descr="Appends string representation of object to the sequence.">
                                <e><![CDATA[
                                    var b = new StringBuilder();
                                    b << "test" << '#' << 123;
                                    print(b); // output: "test#123"]]>
                                </e>
                                <n>This is a synonym for the <c>append</c> method, but using the operator instead of the method is more convenient.</n>
                            </o>
                        </s>
                    </s>
                </s>
            </s>
            <s name="Constants">
                <h name="PI">
                    <p>The π (pi) constant (3.14159...)</p>
                    <c>print(PI);</c>
                </h>
            </s>
        </s>
        <s name="External library">
            <s name="Multithreading">
                <s name="Atomic">
                    <p>Atomic types are types that encapsulate a value whose access is guaranteed to not cause data races and can be used to synchronize memory accesses among different threads. The <c>Atomic</c> class is a wrapper, the value of that can be changed safely in a multi-thread script. </p>
                    <p>Example:</p>
                    <c><![CDATA[
                        import "atomic.goat";

                        // Create an atomic object and init this with integer
                        var a = new Atomic(0);

                        // The thread that increments atomic value
                        var t = $$()
                        {
                            for (var k = 0; k < 1000; k++)
                            {
                                a.inc();
                            }
                        };

                        // Now run 10 such threads 
                        var rr = [];
                        for (var k = 0; k < 10; k++)
                        {
                            rr.push(t.run());
                        }

                        // Join each thread (wait until all them finish)
                        for (var r in rr)
                        {
                            r.join();
                        }

                        println(a.get()); // output: "10000" ]]>
                    </c>
                    <s name="Methods">
                        <m name="init" descr="The constructor.">
                            <a name="value" type="any type" descr="an initial value"/>
                            <e>var a = new Atomic(0);</e>
                        </m>
                        <m name="set" descr="Sets a new value to the atomic object.">
                            <a  name="value" type="any type" descr="a new value"/>
                            <e><![CDATA[
                                var a = new Atomic(false);
                                // do some action, and then (maybe even in another thread):
                                a.set(true);]]>
                            </e>
                        </m>
                        <m name="get" descr="Returns the current value of the atomic object."/>
                        <m name="inc">
                            <d>Increments the current value of the atomic object, i.e. performs the <c>++</c> operator. This method works only for objects that supported increment: <c>Integer</c>, <c>Real</c>, <c>Char</c> and objects that redefined <c>++</c>.</d>
                        </m>
                        <m name="dec">
                            <d>Decrements the current value of the atomic object, i.e. performs the <c>--</c> operator.</d>
                        </m>
                        <m name="add">
                            <d>Adds another value to the value of the atomic object, i.e. performs the <c>+</c> operator.</d>
                            <a name="summand" type="any object" descr="a value to add"/>
                        </m>
                    </s>
                </s>
            </s>
            <s name="Data formats">
                <s name="Xml">
                    <p>Simple XML parser. For more info about the XML format, please visit <url>https://en.wikipedia.org/wiki/XML</url>.</p>
                    <p>The parser takes a string that contains the source document. If you need to parse the file, you must first read and decode it using other methods. The document is recognized as a whole, the output is a tree of XML elements. If the document contains an error, the parser throws an appropriate exception.</p>
                    <s name="Classes">
                        <s name="Xml.Element">
                            <p>The class that contains the data of one XML element. An XML element can contain attributes and child elements, thus, each element is the root of the element tree. The XML parser returns one root element that contains the whole document as a tree of elements.</p>
                            <s name="Fields">
                                <h name="tag">
                                    <p>String. The element's tag. For example, after parsing the element:</p>
                                    <c><![CDATA[
                                        <root>...</root>]]>
                                    </c>
                                    <p>the <c>tag</c> field will contain the value "root".</p>
                                </h>
                                <h name="attrib">
                                    <p>Object, contains attributes. For example, after parsing the element:</p>
                                    <c><![CDATA[
                                        <rectangle width="300" height="200">...</rectangle>]]>
                                    </c>
                                    <p>the <c>attrib</c> field will contain the object <c>{width:300,height:200}</c>.</p>
                                    <p>If the element does not have attributes, this field will contain an empty object.</p>
                                </h>
                                <h name="data">
                                    <p>A child element, or an array containing child elements, or <c>null</c>. A child element can be a string or an <c>Xml.Element</c> type. For example, after parsing the element:</p>
                                    <c><![CDATA[
                                        <list><elem_1>...</elem_1>Some text between elements<elem_2>...</elem_2></list>]]>
                                    </c>
                                    <p>the <c>data</c> field will be contain the array:</p>
                                    <l>
                                        <i>item 0: <c>Xml.Element</c> containing "elem_1" tag and child elements;</i>
                                        <i>item 1: string "Some text between elements";</i>
                                        <i>item 2: <c>Xml.Element</c> containing "elem_2" tag and child elements.</i>
                                    </l>
                                </h>
                            </s>
                            <s name="Methods">
                                <m name="toString" descr="Converts XML tree to a string.">
                                    <a name="indent" type="String" descr="if specified, this indentation will be added before each child element, for better readability of the document. If not specified, a compact document will be generated without indentation."/>
                                </m>
                                <p>For example, let's сreate a simple XML tree:</p>
                                <c><![CDATA[
                                    <root>
                                        <first>Data of the first element</first>
                                        <second/>
                                        <third>
                                            <child>Data of the child element</child>
                                        </third>
                                    </root>]]>
                                </c>
                                <p>To do this, write the following code:</p>
                                <c><![CDATA[
                                    import "xml.goat";

                                    var root = Xml.parse("<root><first>Data of the first element</first><second/><third><child>Data of the child element</child></third></root>");]]>
                                </c>
                                <p>Now convert the tree back into a string without indentation:</p>
                                <c>print(root.toString());</c>
                                <p>Output is:</p>
                                <c><![CDATA[
                                    <root><first>Data of the first element</first><second/><third><child>Data of the child element</child></third></root>]]>
                                </c>
                                <p>Сonvert the tree to a string again, but indented into two spaces:</p>
                                <c>print(root.toString(&quot;  &quot;));</c>
                                <p>Output is:</p>
                                <c><![CDATA[
                                    <root>
                                      <first>Data of the first element</first>
                                      <second/>
                                      <third>
                                        <child>Data of the child element</child>
                                      </third>
                                    </root>]]>
                                </c>
                                <p>Indentation can be not only spaces but also any other characters. Now let's try an indent, consisting of a vertical line and space (<c>| </c>):</p>
                                <c>print(root.toString(&quot;| &quot;));</c>
                                <p>Output is:</p>
                                <c><![CDATA[
                                    <root>
                                    | <first>Data of the first element</first>
                                    | <second/>
                                    | <third>
                                    | | <child>Data of the child element</child>
                                    | </third>
                                    </root>]]>
                                </c>
                                <m name="findByTag" descr="Returns an array contains children with the specified tag(s).">
                                    <a name="tag" type="String | Array" descr="A tag or an array of tags"/>
                                    <n>If no children found, returns an empty array.</n>
                                </m>
                                <m name="findFirstByTag">
                                    <d>Returns the first child with the specified tag, or <c>null</c> if child not found.</d>
                                    <a name="tag" type="String | Array" descr="A tag or an array of tags"/>
                                </m>
                            </s>
                        </s>
                        <s name="Xml.Error">
                            <p>The class contains a description of the error that occurred in the case of parsing a non-valid document.</p>
                            <p>Consists of two fields:</p>
                            <h name="type">
                                <p>Error type, string. The parser usually selects the type of error from the predefined set of strings:</p>
                                <c><![CDATA[
                                    Xml.Error.INVALID_TOKEN : "invalid token",
                                    Xml.Error.EXPECTED_TAG_NAME : "expected tag name",
                                    Xml.Error.UNEXPECTED_END : "unexpected end",
                                    Xml.Error.END_TAG_MISMATCH : "end tag does not match the start tag",
                                    Xml.Error.UNCLOSED_END_TAG : "end element was missing the character \'>\'",
                                    Xml.Error.MISSING_EQUALS : "missing \'=\' sign between attribute and attribute value",
                                    Xml.Error.MISSING_STRING : "a string literal was expected",
                                    Xml.Error.DUPLICATE_ATTRIBUTE : "duplicate attribute",
                                    Xml.Error.UNKNOWN_ENTITY : "unknown entity",
                                    Xml.Error.INVALID_CHARACTER : "invalid character",
                                    Xml.Error.EXPECTED_CDATA_SEQUENCE : "expected <![CDATA[ sequence",
                                    Xml.Error.INVALID_SEQUENCE: "invalid sequence"]]>
                                </c>
                            </h>
                            <h name="index">
                                <p>Integer, the number (index) of character on which the error occurred in the source string.</p>
                            </h>
                        </s>
                    </s>
                    <s name="Methods">
                        <m name="parse" descr="Parse the string and returns an XML tree.">
                            <a name="str" type="String" descr="the source string"/>
                            <e><![CDATA[
                                import "xml.goat";

                                var root = Xml.parse("<root><item>Data of the item</item></root>");]]>
                            </e>
                            <n>If XML document is not valid, throws <c>Xml.Error</c> exception. If valid, returns <c>Xml.Element</c> object contains root element.</n>
                        </m>
                    </s>
                </s>
            </s>
        </s>
    </s>
    
    <s name="Appendix">
        <s name="In comparison with JavaScript">
            <p>The Goat programming language based in general on JavaScript syntax, but it has some differences.</p>
            <l>
                <i>The interpreter (engine) of the programming language is not a complement to the existing solutions, say, V8. It is completely developed from scratch. The interpreter is a very small program and can be compiled and started on different platforms. I tried  Windows and Linux (both x86 and ARM). All you need are C++11 compiler and standard C library (libc etc).</i>
                <i>Programs are launched not in a browser, not in a special environment (say Node.js); you can write general-purpose applications. Easy to install: just copy the file with your code and interpreter and then start.</i>
                <i>The syntax is more simple, the object model is more unified.</i>
                <i>Goat language supports multi-threading and operators overloading.</i>
                <i>You can create an object from more than one prototype.</i>
            </l>
            <p>Some samples are below.</p>
            <s name="Identifiers">
                <h name="JavaScript">
                    <p>The first character of an identifier must be a letter, or an underscore (<c>_</c>), or a dollar sign (<c>$</c>). Subsequent characters may be letters, digits, underscores, or dollar signs.</p>
                </h>
                <h name="Goat">
                    <p>The first character must be a letter or an underscore (<c>_</c>). Subsequent characters may be letters, digits or underscores.</p>
                    <p>Dollar sign used as a short replacement of <c>function</c> keyword:</p>
                    <c>var f = $(a, b) { };</c>
                    <p>it's the same as:</p>
                    <c>var f = function(a, b) { };</c>
                </h>
            </s>
            <s name="Keywords">
                <p>The Goat programming language reserves several additional keywords:</p>
                <t>
                    <h>
                        <c>Keyword</c>
                        <c>Description</c>
                    </h>
                    <r>
                        <c><c>thread</c></c>
                        <c>Declares a thread</c>
                    </r>
                    <r>
                        <c><c>lock</c></c>
                        <c>Declares a critical section (this is a synchronization primitive)</c>
                    </r>
                    <r>
                        <c><c>import</c></c>
                        <c>Imports a source file</c>
                    </r>
                    <r>
                        <c><c>debug</c>(instead of <c>debugger</c>)</c>
                        <c>Stops the execution of Goat script, and switch the interpreter to debug (step-by-step) mode</c>
                    </r>
                </t>
            </s>
            <s name="Primitive types">
                <h name="JavaScript">
                    A primitive data type is data that is not an object and has no methods. There are 6 primitive data types: string, number, boolean, null, undefined, symbol. All primitives are immutable.
                </h>
                <h name="Goat">
                    <p>There are no primitive types. All data represented as objects. Each object include <c>undefined</c> has some methods. There are some predefined objects which are prototypes for primitive data, such as numbers or strings: <c>Char</c>, <c>String</c>, <c>Integer</c>, <c>Real</c>, <c>Boolean</c>, <c>Void</c>, <c>Undefined</c> and <c>Null</c>.</p>
                    <p>This programming language clearly distinguishes between strings (the prototype is <c>String</c>) and individual characters (the prototype is <c>Char</c>), as well as integers (<c>Integer</c>) and floating-point numbers (<c>Real</c>). These types have a different set of methods and operators, but if necessary, a type can be converted to another:</p>
                    <c><![CDATA[
                        var c = 'a'; // prototype of c is Char
                        var s = String.valueof(c); // conversion to String]]>
                    </c>
                    <p>All other structures, for example, functions, threads, arrays, etc have own prototypes (<c>Function</c>, <c>Thread</c>, <c>Array</c>).</p>
                </h>
            </s>
            <s name="Scope">
                <h name="JavaScript">
                    <p>There are two types of scopes: global and local. Variables defined inside a function are in the local scope. Variables defined inside of a block statement will remain in the scope they were already in. ECMAScript 6 introduced the <c>let</c> keyword. Contrary to the <c>var</c> keyword, the <c>let</c> keyword supports the declaration of local scope inside block statements.</p>
                    <c><![CDATA[
                        var func = function()
                        {
                            var v = 0;
                            // do something...
                            if (true)
                            {
                                let v = 1; // local declaration
                            }
                        };]]>
                    </c>
                    <p>If you re-declare a JavaScript variable in the same block, it will not lose its value.</p>
                </h>
                <h name="Goat">
                    <p>There is no global scope. You can re-declare variable with the same name in inner block statement, it will be used only in this block and its inner blocks.</p>
                    <c><![CDATA[
                        var func = $()
                        {
                            var v = 0;
                            if (true)
                            {
                                var v = 1;
                                print(v); // output: "1"
                            }
                            print(v); // output: "0"
                        };]]>
                    </c>
                    <p>But, if you re-declare a Goat variable in the same block, it will lose old value.</p>
                </h>
            </s>
            <s name="The 'this' keyword">
                <h name="JavaScript">
                    <p>You must use the <c>this</c> keyword to refer to the field of own object:</p>
                    <c><![CDATA[
                        var MyClass = function()
                        {
                            this.x = 0;
                        };
                        
                        MyClass.prototype.getX = function()
                        {
                            return this.x;
                        };]]>
                    </c>
                </h>
                <h name="Goat">
                    <p>You can use the <c>this</c> keyword to refer to the field of own object, but you must not do it in all cases. You can skip <c>this</c> keyword in the methods. But in some cases, <c>this</c> keyword cannot be avoided, for example, if you already have a local variable or an argument with that name, but you want to explicit read or write the property of the object, or, you can add new properties to own object (which are not yet there):</p>
                    <c><![CDATA[
                        var MyClass = 
                        {
                            init : $()
                            {
                                this.x = 0; // with 'this'
                            },
                            
                            getX : $()
                            {
                                return x; // without 'this'
                            }
                        };]]>
                    </c>
                </h>
            </s>
            <s name="Operators">
                <p>The Goat language has no comparison operators <c>===</c> (equal value and equal type) and <c>!==</c> (not equal value or not equal type). Operators <c>==</c> and <c>!=</c> works in most cases as <c>===</c> and <c>!==</c> operators in JavaScript.</p>
                <p>The Goat language has not <c>typeof</c> and <c>instanceof</c> operators. Use <c>instanceof</c> method instead:</p>
                <c>print(13.instanceof(Integer)); // output: "true"</c>
                <p>The Goat language provides  several new operators:</p>
                <l>
                    <i><c>-&gt;</c> that means inheritance;</i>
                    <i><c>#</c> for write protecting (after that, an object cannot be changed);</i>
                    <i><c>?.</c>as null conditional operator.</i>
                </l>
            </s>
            <s name="Operators overloading">
                <h name="JavaScript">
                    <p>Doesn't support.</p>
                </h>
                <h name="Goat">
                    <p>You can use the operator as method name:</p>
                    <c><![CDATA[
                        var Vector =
                        {
                            init : $(x, y)
                            {
                                this.x = x; this.y = y
                            },
                            
                            toString : $()
                            {
                                return "X: " + x + ", Y: " + y;
                            },
                            
                            "+" : $(vec)
                            {
                                return new Vector(x + vec.x, y + vec.y);
                            },
                            
                            "*" : $(val)
                            {
                                return new Vector(x * val, y * val);
                            }
                        };

                        var v1 = new Vector(100, 200);
                        var v2 = new Vector(200, 400);

                        println((v1 + v2).toString()); // output: "X: 300, Y: 600"
                        println((v1 * 5).toString()); // output: "X: 500, Y: 1000";]]>
                    </c>
                </h>
            </s>
            <s name="Multithreading">
                <h name="JavaScript">
                    <p>Doesn't support. There are some workarounds, say web workers, and, of course, functions <c>setTimeout()</c> and <c>setInterval()</c>.</p>
                </h>
                <h name="Goat">
                    <p>There is <c>thread</c> keyword. It possible to declare any function as a separate thread.</p>
                    <c><![CDATA[
                        var t0 = thread()
                        {
                            while(true)
                            {
                                print('A');
                            }
                        };

                        var t1 = thread()
                        {
                            while(true)
                            {
                                print('B');
                            }
                        };

                        t0.run();
                        t1.run();

                        // Output: "ABABABABABABAB...."]]>
                    </c>
                </h>
            </s>
            <s name="The 'new' keyword and constructors">
                <h name="JavaScript">
                    <p>Constructors are like regular functions, but we use them with the <c>new</c> keyword. If you inherit your object and the parent has a constructor, you need to call parent constructor to perform initialization logic.</p>
                    <c><![CDATA[
                        var A = function()
                        {
                            // init something...
                        };

                        var B = function()
                        {
                            A.apply(this);
                            // init something else...
                        };
                        B.prototype = new A();]]>
                    </c>
                </h>
                <h name="Goat">
                    <p>There is special method <c>init()</c>. If method defined, interpreter call it. If method also defined in base object, interpreter call it first (the order in which constructors are called is determined by the inheritance topology).</p>
                    <c><![CDATA[
                        var A = 
                        {
                            init : $()
                            {
                                // init something...
                            }
                        };

                        var B = A -> 
                        {
                            init : $()
                            {
                                // init something else...
                            }
                        };

                        var obj = new B(); /* both init method will be called,
                                              first from A, second from B */]]>
                    </c>
                </h>
            </s>
            <s name="Inheritance">
                <h name="JavaScript">
                    <c><![CDATA[
                        var A = function()
                        {
                            this.x = 0;
                        };

                        var B = function()
                        {
                            A.apply(this);
                            this.y = 1;
                        };
                        B.prototype = new A();

                        var C = function()
                        {
                            B.apply(this);
                            this.z = 2;
                        };
                        C.prototype = new B();]]>
                    </c>
                    <p>Nearly all objects in JavaScript are instances of <c>Object</c>, a typical object inherits properties (including methods) from <c>Object.prototype</c>.</p>
                </h>
                <h name="Goat">
                    <p>The syntax is much simpler. Use operator <c>-&gt;</c>:</p>
                    <c><![CDATA[
                        var A =
                        {
                            x : 0
                        };

                        var B = A ->
                        {
                            y : 1
                        };

                        var C = B ->
                        {
                            z : 2
                        };]]>
                    </c>
                    <p>Goat language has also has class (prototype) named <c>Object</c>, is the root of the class hierarchy. Any object has prototype; if it created from literal (for example, strings), or it created by <c>new</c> keyword, or if prototype(s) is explicitly specified when creating an object:</p>
                    <c><![CDATA[
                        var A = { }; // the prototype of 'A' is 'Object' 
                        var S = "hello"; // the prototype of 'S' is 'String'
                        var B = new A(); // the prototype of 'B' is 'A'
                        var C = B->{ }; // the prototype of 'C' is 'B']]>
                    </c>
                </h>
            </s>
            <s name="Multiple inheritance">
                <h name="JavaScript">
                    <p>Is not supported. You can use some tricks (say mixins) but it is not true multiple inheritance.</p>
                </h>
                <h name="Goat">
                    <p>Why not.</p>
                    <c><![CDATA[
                        var A =
                        {
                            x : 0
                        };

                        var B =
                        {
                            y : 1
                        };

                        var C = [A, B] ->
                        {
                            z : 2
                        };]]>
                    </c>
                    <p>The prototype traversal order for multiple inheritance is determined by the topological sorting of the prototype tree.</p>
                </h>
            </s>
            <s name="Syntactic sugar">
                <s name="Null conditional operator">
                    <h name="JavaScript">
                        <p>Doesn't support. Currently, it is proposal options, it will be supported later.</p>
                    </h>
                    <h name="Goat">
                        <p>Operator <c>?.</c> is added. Operator <c>?.</c> read a property (calls a method) only if a left object is not void, otherwise returns <c>undefined:</c></p>
                        <c><![CDATA[
                            var value = user?.address?.street;
                            ]]>
                        </c>
                    </h>
                </s>
            </s>
        </s>
        <s name="Command line options and environment variables" anchor="Full list of command line options">
            <p>Here is the full list of command line options.</p>
            <h name="--lib">
                <p>Path (paths) to external libraries (to importable files), for example, a path to the Goat standard library. Several paths should be separated by a semicolon.</p>
                <p>Example, for Windows:</p>
                <c>goat.exe program.goat --lib=c:\goat\lib;c:\project</c>
                <p>Example, for Linux:</p>
                <c>./goat program.goat --lib=/work/goat/lib;/work/project</c>
                <p>The search for the included file is performed in the order specified in the list. In the example above, the list contains two items:</p>
                <l>
                    <i>c:\goat\lib</i>
                    <i>c:\project</i>
                </l>
                <p>Say the script contains the line:</p>
                <c>import &quot;xml.goat&quot;;</c>
                <p>The interpreter first tried to open the file <c>c:\goat\lib\xml.goat</c>, and if it was not found, the file <c>c:\project\xml.goat</c>.</p>
                <p>The current folder where the script was launched from has the highest priority; the search starts from it. If you need to include a file from a specific folder, specify the full path in the <c>import</c> directive:</p>
                <c>import &quot;project/xml.goat&quot;;</c>
                <p>This option can be set as an environment variable <c>GOAT_LIBRARY_PATH</c>. Example, for Windows:</p>
                <c><![CDATA[
                    set GOAT_LIBRARY_PATH=c:\goat\lib;c:\project
                    goat.exe program.goat
                    ]]>
                </c>
                <p>Example, for Linux:</p>
                <c><![CDATA[
                    export GOAT_LIBRARY_PATH=/work/goat/lib;/work/project
                    /work/goat program.goat
                    ]]>
                </c>
                <p>If both the environment variable and the command line option are set, then the command line option is preferred. This means that both lists will be used, but first, the search will be performed in the list defined in the command line.</p>
            </h>
            <h name="--language= or --lang=">
                <p>Set language for compiler output messages. Supported languages are:</p>
                <l>
                    <i>english (en) - default</i>
                    <i>russian (ru)</i>
                </l>
                <p>This option can be set as an environment variable <c>GOAT_LANGUAGE</c>.</p>
            </h>
            <h name="--debug and --run">
                <p>After starting, you switch to debug mode, where you can add breakpoints and execute the program line by line. This mode is described in the <link>Step-by-step debugging</link> section.</p>
                <p>Example:</p>
                <c>goat.exe program.goat --debug</c>
                <p>This option can be set as an environment variable <c>GOAT_DEBUG</c>.</p>
                <p>After starting with the <c>--debug</c> option, the interpreter immediately enters debug mode. You should add breakpoints, and then enter <c>r</c> command to run the script. However, you can pre-set breakpoints directly in the script using the <c>debug</c> statement. If you have such statements and if you don't want to enter <c>r</c> command to run the script, add <c>--run</c> option and the script will be executed after launching until the first <c>debug</c> statement:</p>
                <c>goat.exe program.goat --debug --run</c>
            </h>
            <h name="--compile">
                <p>Compile the script into bytecode, but do not execute it.</p>
                <p>Example:</p>
                <c>goat.exe program.goat --compile</c>
                <p>As a result, a binary file <c>&lt;program_name&gt;+.bin</c> (in this case: <c>program.goat.bin</c>) will be written.  The binary is compressed to save space and is unpacked at each loading. To leave the file uncompressed (speeds uploading), use option <c>--do-not-compress</c>:</p>
                <c>goat.exe program.goat --compile --do-not-compress</c>
            </h>
            <h name="--bin">
                <p>Run a previously compiled script.</p>
                <p>Example:</p>
                <c>goat.exe --bin program.goat.bin</c>
                <p>Since the compilation procedure was performed earlier, loading prepared bytecode is faster. This will reduce the overall program execution time.</p>
            </h>
            <h name="--stdin">
                <p>Reads the original text of the program from standard input instead of a file. This option allows, for example, to execute short programs directly from the command line:</p>
                <c><![CDATA[
                    C:\>echo for (var i in range(10)) print(i); | goat.exe --stdin
                    0123456789]]>
                </c>
            </h>
            <h name="--gc">
                <p>One of the four modes of garbage collection.</p>
                <l>
                    <i><c>--gc=serial</c> enable serial mode, it means that the garbage collector periodically stops all threads (but it takes low processor resources for collection and has small memory overhead);</i>
                    <i><c>--gc=parallel</c> does not stop threads (but it constantly uses some processor resources and also it uses some extra memory), this mode enabled by default;</i>
                    <i><c>--gc=disabled</c> completely disables garbage collection. All memory is cleared only after the script is finished;</i>
                    <i><c>--gc=debug</c> used for debugging purposes for interpreter developer, it calls collector after each statement of a script and this is <b>very</b> slow.</i>
                </l>
                <p>If you don't know what "garbage collection" means, please do not use this parameter, the parallel collector is okay for most purposes.</p>
            </h>
            <h name="--heap-size=">
                <p>Limit memory used by a script. The value is specified in megabytes.</p>
                <p>Example. Limit memory usage to one megabyte:</p>
                <c>goat.exe program.goat --heap-size=1</c>
                <p>By default, the script uses all available RAM. Limiting memory can lead to a more frequent garbage collector operation and, as a result, to slower work. If there is not enough memory due to a large number of objects, the script will end with an error.</p>
            </h>
            <h name="--dump-memory-usage-report">
                <p>Write memory usage report to <c>&lt;program_name&gt;+.memory.txt</c> file.</p>
                <p>Example:</p>
                <c>goat.exe program.goat --dump-memory-usage-report</c>
                <p>A possible output (<c>program.goat.memory.txt</c>):</p>
                <c><![CDATA[
                    MEMORY USAGE REPORT  

                    heap size, bytes:     268435456
                    peak usage, bytes:    19240301
                    gc algorithm:         'serial'
                    count of gc launches: 834
                    total objects:        986649
                       actually created:  96828
                       reused:            889821 (90.1 %)]]>
                </c>
            </h>
            <h name="--dump-abstract-syntax-tree">
                <p>As a first step, the compiler parses the source code of the script into tokens and generates an abstract syntax tree (<url>https://en.wikipedia.org/wiki/Abstract_syntax_tree</url>). This option dumps abstract syntax tree of tokens to <c>&lt;program_name&gt;+.tokens.txt</c> file as a graph in DOT format (see <url>https://en.wikipedia.org/wiki/DOT_(graph_description_language)</url>). To visualize it, use an appropriate tool, for example, graphwiz (<url>http://graphviz.org</url>).</p>
                <p>Example. The script:</p>
                <c>println(2 + 3 * 4);</c>
                <p>Command line:</p>
                <c><![CDATA[
                    goat.exe program.goat --dump-abstract-syntax-tree
                    dot -Tsvg program.goat.tokens.txt -o ast.svg]]>
                </c>
                <p>Result:</p>
                <pic title="Abstract syntax tree">graph/abstract_syntax_tree.svg</pic>
            </h>
            <h name="--dump-parse-tree">
                <p>This option dumps parse tree to <c>&lt;program_name&gt;+.ptree.txt</c> file as a graph in DOT format. Parse tree (<url>https://en.wikipedia.org/wiki/Parse_tree</url> is generated from an abstract syntax tree as a second compilation step.</p>
            </h>
            <h name="--dump-assembler-code">
                <p>Write compiled bytecode to <c>&lt;program_name&gt;+.asm</c> file as list of assembler instructions for the virtual machine. Bytecode is generated from the parse tree as the last compilation step.</p>
                <p>Example. The script:</p>
                <c>println(2 + 3 * 4);</c>
                <p>Command line:</p>
                <c>goat.exe program.goat --dump-assembler-code</c>
                <p>A possible output (<c>program.goat.asm</c>):</p>
                <c><![CDATA[
                    .data
                      0    println

                    .code
                        integer    4
                        integer    3
                        mul
                        integer    2
                        add
                        load    0    ; println
                        call    1
                        pop
                        end]]>
                </c>
            </h>
        </s>
    </s>
</goat>
