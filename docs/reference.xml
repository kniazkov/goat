<goat>
	<v value="0.5 &quot;Overdrive&quot;"/>
	<s name="Introduction">
		<p><b>Goat</b> is a high-level, dynamic, weakly typed, prototype-based, multi-paradigm, and interpreted programming language, based on JavaScript syntax. It supports the basic functionality of JavaScript, but in addition, it adds support for multithreading, multiple inheritance, operator overloading (like in C ++), has simplified syntax, and so on.</p>
		<p>Why "Goat"? I was bitten by a goat. Indeed. This is how it was: really, it’s very difficult to come up with a good language name. The name should be short and memorable, for example, "Go" (but "Go" is occupied). So, one spring morning I was lying in a hammock, programming on a laptop and eating an apple. It was a wonderful day, beautiful weather, birds were singing, and then suddenly <url title="my goat">this_one.jpg</url> bit me. "Oh, you sweet little prankster", I thought (no no, actually I said another thing). I dropped my laptop and at this time the goat stole my apple. Then I thought perhaps the name "Goat" is not bad too. So I renamed the project folder to this name and since then it has not changed.</p>
	</s>
	
	<s name="Where to download the latest release">
		<p>On GitHub: <url>https://github.com/kniazkov/goat/releases/latest</url>.</p>
	</s>
	
	<s name="How to launch Goat script">
		<s name="Quick start">
			<p>Just download the executable file, open console, type executable name and specify a script file name as a parameter:</p>
			<c>goat.exe program.goat</c>
			<p>For UNIX-like systems, executable name is <c>goat</c>, without <c>.exe</c> extension:</p>
			<c>./goat program.goat</c>
		</s>
		<s name="Command line options">
			<p>The Goat interpreter parses command line arguments as follows. All arguments started with two hyphens are internal parameters of the interpreter ("options"). The first argument which is not an option is the name of the script file. All next arguments are send to the script.</p>
			<p>For example,</p>
			<c>goat.exe --lib=../lib program.goat arg1 arg2</c>
			<p>or, the same thing:</p>
			<c>goat.exe program.goat --lib=../lib arg1 arg2</c>
			<p>or:</p>
			<c>goat.exe program.goat arg1 arg2 --lib=../lib</c>
			<p>where: <c>goat.exe</c> is Goat executable, <c>program.goat</c> is name of the script, <c>--lib=../lib</c> is option of the interpreter, <c>arg1</c> and <c>arg2</c> are arguments of the script.</p>
			<p>Here is a short list of interpreter options. All options are described in the <link title="Appendix">Full list of command line options</link> section.</p>
			<h name="--lib">
				<p>Path (paths) to external libraries (to importable files). For example, a path to the Goat standard library. Several paths can be separated by a semicolon.</p>
				<c>goat.exe program.goat --lib=c:\goat\lib;c:\project</c>
				<p>Note about path delimiting character, this is most commonly the slash ("/") or the backslash  ("\"). While the interpreter parsed paths, it changes delimiting characters to the character used in the current platform. Say, for Windows, all delimiter characters replaced to the backslash, and for Linux (Unix) - to slash. So path <c>--lib=..\folder\lib</c> interpreted as well as path <c>--lib=../folder/lib</c>, for all platforms.</p>
			</h>
			<h name="--language= or --lang=">
				<p>Set language for compiler output messages. Supported languages are:</p>
				<l>
					<i>english (en) - default</i>
					<i>russian (ru)</i>
				</l>
				<p>Example. If the interpreter finds an error in the script, the error message will be displayed in Russian:</p>
				<c><![CDATA[
					program.goat (contains an error "Unknown character"):
						
						println(`Hello world`);
						
					Command line:
						
						./goat program.goat --lang=ru
						
					Output:
					
						println(`Hello world`);
						        ^
						program.goat, 1.9: неизвестный символ '`'
					]]>
				</c>
			</h>
			<h name="--debug">
				<p>After starting, you switch to debug mode, where you can add breakpoints and execute the program line by line. This mode is described in the <link>Step-by-step debugging</link> section.</p>
				<p>Example:</p>
				<c>goat.exe program.goat --debug</c>
			</h>
			<h name="--compile">
				<p>Compile the script into bytecode, but do not execute it.</p>
				<p>Example:</p>
				<c>goat.exe program.goat --compile</c>
				<p>As a result, a binary file <c>program.goat.bin</c> will be written.</p>
			</h>
			<h name="--bin">
				<p>Run a previously compiled script.</p>
				<p>Example:</p>
				<c>goat.exe --bin program.goat.bin</c>
				<p>Since the compilation procedure was performed earlier, loading prepared bytecode is faster. This will reduce the overall program execution time.</p>
			</h>
		</s>
	</s>
	
	<s name="Basics">
		<p><b>Important note. A significant part of this chapter is the redesigned tutorial from: <url>https://www.w3schools.com/js/default.asp</url>. Since the Goat language is the modified JavaScript language, so the description of the Goat language is the modified description of the  Javascript language. Any coincidences are NOT random.</b></p>
		<s name="Hello world">
			<p>Create a new file, say <c>hello_world.goat</c> (file extension does not matter) containing one line:</p>
			<c>print(&quot;Hello, world!&quot;);</c>
			<p>and then launch it:</p>
			<c>goat.exe hello_world.goat</c>
			<p>That's all. The interpreter will start the script and will print <c>Hello, world!</c> to the console.</p>
		</s>
		<s name="Internationalization and localization">
			<p>It is possible to use any Unicode characters in string literals. The Goat interpreter parses source files in UTF-8  format. The output stream also encoded to UTF-8. The previous example, but contains nonlatin characters:</p>
			<c>print(&quot;Привет, мир!&quot;);</c>
		</s>
		<s name="Program and statements">
			<s name="Program">
				<p>A computer program is a list of "instructions" to be "executed" by a computer. In a programming language, these programming instructions are called <b>statements.</b></p>
				<p>A <b>Goat program is a list of</b> programming <b>statements.</b></p>
				<c><![CDATA[
					var x, a, b; // statement 1
					a = 2; // statement 2
					b = 3; //       ... 3
					x = a + b; //       ... 4
					print(x); //       ... 5]]>
				</c>
				<p>Goat programs are executed by the Goat interpreter.</p>
			</s>
			<s name="Statements">
				<p>Goat statements are composed of: <b>Values</b>, <b>Operators</b>, <b>Expressions</b>, <b>Keywords</b>, and <b>Comments</b>.</p>
				<p>The statements are executed, one by one, in the same order as they are written.</p>
			</s>
			<s name="Semicolons">
				<p>Semicolons <c>;</c> separate Goat statements. Add a semicolon at the end of each executable statement:</p>
				<c><![CDATA[
					var x, a, b; // declare 3 variables
					a = 2; // assign the value 2 to 'a'
					b = 3; // assign the value 6 to 'b'
					x = a + b; // assign the sum of 'a' and 'b' to 'x'
					print(x); // print value of 'x']]>
				</c>
				<p>When separated by semicolons, multiple statements on one line are allowed:</p>
				<c>a = 2; b = 3; x = a + b;</c>
				<p>Though ending statements with a semicolon is not required, but highly recommended. This example is correct:</p>
				<c>print(2 + 3) // no semicolon at the end</c>
			</s>
			<s name="White space">
				<p>Goat parse tabulations and line breaks as white spaces. Goat ignores multiple spaces. You can add white space to your script to make it more readable. The following statements are equivalent:</p>
				<c><![CDATA[
					var a, b = 0;
					var a, b=0;
					var a,
						b = 0;]]>
				</c>
			</s>
			<s name="Code blocks">
				<p>Goat statements can be grouped together in code blocks, inside curly brackets <c>{...}</c>. The purpose of code blocks is to define statements to be executed together. One place you will find statements grouped together in blocks, is in Goat functions:</p>
				<c><![CDATA[
					var f = $(a, b)
					{
						var x;
						var y;
						x = a + b;
						y = a - b;
						print("summ: " + x + ", diff: " + y);
					};]]>
				</c>
			</s>
			<s name="Keywords and keyword sequences">
				<p>Goat statements often start with a keyword to identify the Goat action to be performed. Here is a list of the keywords (or keyword sequences):</p>
				<t>
					<h>
						<c width="180">Keyword</c>
						<c>Description</c>
					</h>
					<r>
						<c><c>var</c></c>
						<c>Declares a variable</c>
					</r>
					<r>
						<c><c>function</c> or <c>$</c></c>
						<c>Declares a function (method)</c>
					</r>
					<r>
						<c><c>thread</c></c>
						<c>Declares a thread</c>
					</r>
					<r>
						<c><c>lock</c></c>
						<c>Declares a critical section</c>
					</r>
					<r>
						<c><c>return</c></c>
						<c>Exits a function (method)</c>
					</r>
					<r>
						<c><c>if</c>..<c>else if</c>..<c>else</c></c>
						<c>Marks a block of statements to be executed, depending on a condition</c>
					</r>
					<r>
						<c><c>switch</c>(<c>case</c>, <c>default)</c></c>
						<c>Marks a block of statements to be executed, depending on different cases</c>
					</r>
					<r>
						<c><c>for</c>(<c>in</c>)</c>
						<c>Marks a block of statements to be executed, as long as a condition is true</c>
					</r>
					<r>
						<c><c>while</c>, <c>do</c>..<c>while</c></c>
						<c>Executes a block of statements, and repeats the block, while a condition is true</c>
					</r>
					<r>
						<c><c>break</c></c>
						<c>Terminates a switch or a loop</c>
					</r>
					<r>
						<c><c>continue</c></c>
						<c>Jumps out of a loop and starts at the top</c>
					</r>
					<r>
						<c><c>try</c>..<c>catch</c>..<c>finally</c></c>
						<c>Implements error handling to a block of statements</c>
					</r>
					<r>
						<c><c>throw</c></c>
						<c>Throws an exception</c>
					</r>
					<r>
						<c><c>new</c></c>
						<c>Creates a new object</c>
					</r>
					<r>
						<c><c>import</c></c>
						<c>Imports a source file</c>
					</r>
					<r>
						<c><c>debug</c></c>
						<c>Stops the execution of Goat script, and switch the interpreter to debug (step-by-step) mode</c>
					</r>
				</t>
				<p>Goat keywords are reserved words. Reserved words cannot be used as names for variables.</p>
			</s>
		</s>
		<s name="Syntax">
			<p>Goat syntax is the set of rules, how Goat programs are constructed:</p>
			<c><![CDATA[
				var a, b, x; // How to declare variables
				a = 2; // How to assign values
				b = 3;
				x = a + b; // How to compute values
				print(x); // How to call functions
			]]>
			</c>
			<s name="Values">
				<p>The Goat syntax defines two types of values: fixed values and variable values. Fixed values are called <b>literals.</b> Variable values are called <b>variables.</b></p>
				<s name="Literals">
					<p>The most important rules for writing fixed values are:</p>
					<p><b>Integer numbers</b> are written without decimals:</p>
					<c>123</c>
					<p><b>Real numbers</b> are written with decimals, the decimal separator is a dot:</p>
					<c>0.001</c>
					<p><b>Strings</b> are text, written within double quotes:</p>
					<c>"Hello"</c>
					<p><b>Chars</b> are symbols written within single quotes:</p>
					<c>'A'</c>
				</s>
				<s name="Variables">
					<p>In a programming language, variables are used to store data values. Goat uses the <c>var</c> keyword to <b>declare</b> variables. An <b>equal sign</b> is used to <b>assign</b> values to variables.</p>
					<p>In this example, <c>x</c> is defined as a variable. Then, <c>x</c> is assigned (given) the value 10:</p>
					<c><![CDATA[
						var x;
						x = 10;]]>
					</c>
				</s>
			</s>
			<s name="Operators">
				<p>Goat uses <b>arithmetic operators</b> ( <c>+ - *  /</c> ) to <b>compute</b> values:</p>
				<c>(5 + 6) * 10</c>
				<p>Goat uses an <b>assignment operator</b> ( = ) to <b>assign</b> values to variables:</p>
				<c><![CDATA[
					var a, b;
					a = 2;
					b = 3;]]>
				</c>
			</s>
			<s name="Expressions">
				<p>An <b>expression</b> is a combination of literals, variables, function calls, other expression and operators, which computes to a value. The computation is called an evaluation. For example, 5 * 10 evaluates to 50:</p>
				<c>5 * 10</c>
				<p>Expressions can also contain variable values:</p>
				<c>x * 2</c>
				<p>...or function calls:</p>
				<c>x * sin(y)</c>
				<p>The values can be of various types, such as numbers and strings:</p>
				<c>"Hello" + ", " + "world"</c>
			</s>
			<s name="Identifiers">
				<p><b>Identifiers</b> are names.</p>
				<p>In Goat, identifiers are used to name variables. The rules for legal names are much the same in most programming languages. In Goat, the first character must be a letter or an underscore (<c>_</c>). Subsequent characters may be letters, digits or underscores. Numbers are not allowed as the first character.</p>
			</s>
			<s name="Case sensitive">
				<p>All Goat identifiers are case sensitive. The variables <c>maxValue</c> and <c>maxvalue</c>, are two different variables.</p>
				<c><![CDATA[
					var maxValue, maxvalue;
					maxValue = 10;
					maxvalue = 0.1;]]>
				</c>
			</s>
		</s>
		<s name="Comments">
			<p>Goat comments can be used to explain Goat code, and to make it more readable. Goat comments can also be used to prevent execution when testing alternative code.</p>
			<s name="Single line comments">
				<p>Single line comments start with <c>//</c>. Any text between <c>//</c> and the end of the line will be ignored by Goat (will not be executed). This example uses a single-line comment before each code line:</p>
				<c><![CDATA[
					// Create object:
					var obj = {};
					// Add a field to the object:
					obj.value = 10; ]]>
				</c>
				<p>This example uses a single line comment at the end of each line to explain the code:</p>
				<c><![CDATA[
					var x = 5; // Declare x, give it the value of 5
					var y = x + 2;  // Declare y, give it the value of x + 2]]>
				</c>
			</s>
			<s name="Multi-line comments">
				<p>Multi-line comments start with <c>/*</c> and end with <c>*/</c>. Any text between <c>/*</c> and <c>*/</c> will be ignored by Goat. This example uses a multi-line comment (a comment block) to explain the code:</p>
				<c><![CDATA[
					/*
					The code below declares the function which calculates
					and print sum and difference of two arguments
					*/
					var f = $(a, b)
					{
						var x;
						var y;
						x = a + b;
						y = a - b;
						print("summ: " + x + ", diff: " + y);
					};]]>
				</c>
			</s>
			<s name="Using comments to prevent execution">
				<p>Using comments to prevent execution of code is suitable for code testing. Adding <c>//</c> in front of a code line changes the code lines from an executable line to a comment. This example uses <c>//</c> to prevent execution of one of the code lines:</p>
				<c><![CDATA[
					var person = {};
					person.name = "Ivan";
					//person.gender = "Male";
					person.age = 33;]]>
				</c>
				<p>This example uses a comment block to prevent execution of multiple lines:</p>
				<c><![CDATA[
					var person = {};
					person.name = "Ivan";
					/*
					person.gender = "Male";
					person.age = 33;
					*/]]>					
				</c>
			</s>
		</s>
		<s name="Variables">
			<p>Goat <b>variables</b> are containers for storing data values. In this example, <c>x</c>, <c>y</c>, and <c>z</c>, are variables:</p>
			<c><![CDATA[
				var x = 5;
				var y = 6;
				var z = x + y;]]>					
			</c>
			<s name="Identifiers">
				<p>All Goat variables must be identified with unique names. These unique names are called <b>identifiers.</b> Identifiers can be short names (like <c>x</c> and <c>y</c>) or more descriptive names (<c>age</c>, <c>sum</c>, <c>totalVolume</c>). The general rules for constructing names for variables (unique identifiers) are:</p>
				<l>
					<i>names can contain letters, digits and underscores;</i>
					<i>names must begin with a letter;</i>
					<i>names can also begin with <c>_</c>;</i>
					<i>names are case sensitive (<c>y</c> and <c>Y</c> are different variables);</i>
					<i>reserved words (like Goat keywords) cannot be used as names.</i>
				</l>
			</s>
			<s name="Data types">
				<p>Goat can handle many types of data. Goat variables can hold numbers like 100 and text values like "Hello". Basic data types are:</p>
				<p><b>Integer</b> number (without decimal character):</p>
				<c>var i = 10;</c>
				<p><b>Real</b> (floating-point) number:</p>
				<c>var r = 0.01;</c>
				<p><b>String:</b></p>
				<c>var s = "Hello";</c>
				<p><b>Char</b>(single symbol):</p>
				<c>var c = 'A';</c>
				<p>And <b>Boolean:</b></p>
				<c>var b = true;</c>
			</s>
			<s name="Declaring (creating) Goat variables">
				<p>Creating a variable in Goat is called "declaring" a variable. You declare a JavaScript variable with the <c>var</c> keyword:</p>
				<c>var name;</c>
				<p>After the declaration, the variable has no value (technically it has the value of <c>undefined</c>). To assign a value to the variable, use the equal sign:</p>
				<c>name = "Ivan";</c>
				<p>You can also assign a value to the variable when you declare it:</p>
				<c>var name = "Ivan";</c>
			</s>
			<s name="One statement, many variables">
				<p>You can declare many variables in one statement. Start the statement with <c>var</c> and separate the variables by comma:</p>
				<c>var name = "Ivan", age = 33, gender = "male";</c>
				<p>A declaration can span multiple lines:</p>
				<c><![CDATA[
					var name = "Ivan",
						age = 33,
						gender = "male";]]>
				</c>
			</s>
			<s name="Undefined">
				<p>Variables are often declared without a value. The value can be something that has to be calculated, or something that will be provided later, like user input. A variable declared without a value will have the value <c>undefined</c>.</p>
				<c>var name; // value of 'name' is undefined</c>
			</s>
			<s name="Re-declaring variables">
				<p>If you re-declare a Goat variable, it will lose old value.</p>
				<c><![CDATA[
					var name = "Ivan";
					// do something...
					var name; // now, value of 'name' if undefined]]>
				</c>
			</s>
			<s name="Arithmetic">
				<p>As with algebra, you can do arithmetic with Goat variables, using operators like <c>=</c> and <c>+</c>:</p>
				<c>var x = 5 + 2 + 3;</c>
				<p>You can also add strings, but strings will be concatenated:</p>
				<c>var s = "Hello" + ", " + "world!"</c>
				<p>Also try this. The Goat language will convert second operator to string if the first operator is string:</p>
				<c>var s = "Value is" + ' ' + 5;</c>
			</s>
		</s>
		<s name="Operators">
			<s name="Examples">
				<p>The <b>assignment</b> operator (<c>=</c>) assigns a value to a variable.</p>
				<c>var x = 10;</c>
				<p>The <b>addition</b> operator (<c>+</c>) adds numbers:</p>
				<c><![CDATA[
					var a = 2;
					var b = 3;
					var c = a + b;]]>
				</c>
				<p>The <b>multiplication</b> operator (<c>*</c>) multiplies numbers.</p>
				<c><![CDATA[
					var a = 2;
					var b = 3;
					var c = a * b;]]>
				</c>
			</s>
			<s name="Arithmetic operators">
				<p>Arithmetic operators are used to perform arithmetic on numbers:</p>
				<t>
					<h>
						<c width="100">Operator</c>
						<c>Description</c>
					</h>
					<r>
						<c><c>+</c></c>
						<c>Addition</c>
					</r>
					<r>
						<c><c>-</c></c>
						<c>Subtraction</c>
					</r>
					<r>
						<c><c>*</c></c>
						<c>Multiplication</c>
					</r>
					<r>
						<c><c>/</c></c>
						<c>Division</c>
					</r>
					<r>
						<c><c>%</c></c>
						<c>Modulus (remainder)</c>
					</r>
					<r>
						<c><c>++</c></c>
						<c>Increment</c>
					</r>
					<r>
						<c><c>--</c></c>
						<c>Decrement</c>
					</r>
				</t>
			</s>
			<s name="Assignment operators">
				<p>Assignment operators assign values to Goat variables. </p>
				<t>
					<h>
						<c width="100">Operator</c>
						<c width="100">Example</c>
						<c>Same as</c>
					</h>
					<r>
						<c><c>=</c></c>
						<c><c>x = y</c></c>
						<c></c>
					</r>
					<r>
						<c><c>+=</c></c>
						<c><c>x += y</c></c>
						<c><c>x = x + y</c></c>
					</r>
					<r>
						<c><c>-=</c></c>
						<c><c>x -= y</c></c>
						<c><c>x = x - y</c></c>
					</r>
					<r>
						<c><c>*=</c></c>
						<c><c>x *= y</c></c>
						<c><c>x = x * y</c></c>
					</r>
					<r>
						<c><c>/=</c></c>
						<c><c>x /= y</c></c>
						<c><c>x = x / y</c></c>
					</r>
					<r>
						<c><c>%=</c></c>
						<c><c>x %= y</c></c>
						<c><c>x = x % y</c></c>
					</r>
				</t>
				<p>The <b>addition assignment</b> operator (<c>+=</c>) adds a value to a variable.</p>
				<c><![CDATA[
					var x = 10;
					x += 5;]]>
				</c>
				<p>Value of <c>x</c> will be: <c>15</c></p>
			</s>
			<s name="String operators">
				<p>The <c>+</c> and <c>+=</c> operators can also be used to add (concatenate) strings.</p>
				<c><![CDATA[
					var a = "Hello";
					var b = "world";
					var s = a + ", " + b;]]>
				</c>
				<p>Value of <c>s</c> will be: <c>Hello, world!</c></p>
			</s>
			<s name="Adding strings and not-strings">
				<p>Adding two numbers, will return the sum, but adding a string and a not-string (number, symbol etc) will return a string:</p>
				<c><![CDATA[
					var x = 2 + 3;
					var s = "result is: " + x;]]>
				</c>
				<p>Value of <c>s</c> will be: <c>result is: 5</c></p>
			</s>
			<s name="Comparison operators">
				<t>
					<h>
						<c width="100">Operator</c>
						<c>Description</c>
					</h>
					<r>
						<c><c>==</c></c>
						<c>Equal to</c>
					</r>
					<r>
						<c><c>!=</c></c>
						<c>Not equal</c>
					</r>
					<r>
						<c><c>&gt;</c></c>
						<c>Greater than</c>
					</r>
					<r>
						<c><c>&lt;</c></c>
						<c>Less than</c>
					</r>
					<r>
						<c><c>&gt;=</c></c>
						<c>Greater than or equal to</c>
					</r>
					<r>
						<c><c>&lt;=</c></c>
						<c>Less than or equal to</c>
					</r>
					<r>
						<c><c>?</c></c>
						<c>Ternary operator</c>
					</r>
				</t>
			</s>
			<s name="Logical operators">
				<p>These logical operators work only with binary (<c>Boolean</c>) type:</p>
				<t>
					<h>
						<c width="100">Operator</c>
						<c>Description</c>
					</h>
					<r>
						<c><c>&amp;&amp;</c></c>
						<c>Logical and</c>
					</r>
					<r>
						<c><c>||</c></c>
						<c>Logical or</c>
					</r>
				</t>
				<p>These logical operators work with all types:</p>
				<t>
					<h>
						<c width="100">Operator</c>
						<c>Description</c>
					</h>
					<r>
						<c><c>!</c></c>
						<c>Logical not</c>
					</r>
					<r>
						<c><c>!!</c></c>
						<c>Logical double not</c>
					</r>
				</t>
			</s>
			<s name="Bitwise operators">
				<p>Bitwise operators work with <c>Integer</c> type.</p>
				<t>
					<h>
						<c width="100">Operator</c>
						<c>Description</c>
						<c>Example</c>
						<c>Same as</c>
						<c>Result</c>
						<c>Decimal</c>
					</h>
					<r>
						<c><c>&amp;</c></c>
						<c>And</c>
						<c><c>5 &amp; 1</c></c>
						<c><c>0101 &amp; 0001</c></c>
						<c><c>0001</c></c>
						<c><c>1</c></c>
					</r>
					<r>
						<c><c>|</c></c>
						<c>Or</c>
						<c><c>5 | 1</c></c>
						<c><c>0101 | 0001</c></c>
						<c><c>0101</c></c>
						<c><c>5</c></c>
					</r>
					<r>
						<c><c>~</c></c>
						<c>Not</c>
						<c><c>~5</c></c>
						<c><c>~0101</c></c>
						<c><c>...111010</c></c>
						<c><c>-6</c></c>
					</r>
					<r>
						<c><c>^</c></c>
						<c>Xor</c>
						<c><c>5 ^ 1</c></c>
						<c><c>0101 ^ 0001</c></c>
						<c><c>0100</c></c>
						<c><c>4</c></c>
					</r>
					<r>
						<c><c>&lt;&lt;</c></c>
						<c>Left shift</c>
						<c><c>5 &lt;&lt; 1</c></c>
						<c><c>0101 &lt;&lt; 1</c></c>
						<c><c>1010</c></c>
						<c><c>10</c></c>
					</r>
					<r>
						<c><c>&gt;&gt;</c></c>
						<c>Signed right shift</c>
						<c><c>5 &gt;&gt; 1</c></c>
						<c><c>0101 &gt;&gt; 1</c></c>
						<c><c>0010</c></c>
						<c><c>2</c></c>
					</r>
					<r>
						<c><c>&gt;&gt;&gt;</c></c>
						<c>Zero fill right shift</c>
						<c><c>5 &gt;&gt;&gt; 1</c></c>
						<c><c>0101 &gt;&gt;&gt; 1</c></c>
						<c><c>0010</c></c>
						<c><c>2</c></c>
					</r>
				</t>
			</s>
			<s name="Special operators">
				<t>
					<h>
						<c width="100">Operator</c>
						<c>Description</c>
					</h>
					<r>
						<c><c>-&gt;</c></c>
						<c>Inherit</c>
					</r>
					<r>
						<c><c>#</c></c>
						<c>Write protect</c>
					</r>
				</t>
			</s>
			<s name="Common operators">
				<p>Each object supports these operators: <c>-&gt;</c> (inherit), <c>#</c> (write protect), <c>==</c> (equal), <c>!=</c> (not equal) and <c>!</c> (logical not).</p>
				<h name="-&gt; (inherit)">
					<p>Each object can be a prototype for a new object. Below in this document, it will be explained what is prototyping.</p>
				</h>
				<h name="# (write protect)">
					<p>Returns a write protected object, that is, an object whose properties can not be changed.</p>
				</h>
				<h name="== (equal) and != (not equal)">
					<p>In common case, an object equals to another object, if these objects are the same object. For numbers, strings, other built-in types, an object is equal to another object if these objects have the same value, for example, <c>5 == 2 + 3</c>.</p>
				</h>
				<h name="! (not)">
					<p>In common case, <c>not</c> object is <c>false</c>. The chapters about the comparison and conditions will describe how this is used.</p>
				</h>
				<h name="!! (double not)">
					<p>Double negation is used to cast any object to <c>Boolean</c> type.</p>
				</h>
			</s>
		</s>
		<s name="Arithmetic">
			<s name="Arithmetic Operations">
				<p>A typical arithmetic operation operates on two numbers. The two numbers can be literals:</p>
				<c>var x = 100 + 50;</c>
				<p>or variables:</p>
				<c>var x = a + b;</c>
				<p>or expressions:</p>
				<c>var x = (100 + 50) * a;</c>
			</s>
			<s name="Operators and operands">
				<p>The numbers (in an arithmetic operation) are called <b>operands.</b></p>
				<p>The operation (to be performed between the two operands) is defined by an <b>operator.</b></p>
				<t>
					<h>
						<c width="100">Operand</c>
						<c width="100">Operator</c>
						<c>Operand</c>
					</h>
					<r>
						<c>100</c>
						<c>+</c>
						<c>50</c>
					</r>
				</t>
				<p>If at least one of the operators is a real number, the result will be a real number. If both operators are integers, the result will be an integer.</p>
				<p>The <b>addition</b> operator (<c>+</c>) adds numbers.</p>
				<c><![CDATA[
					var a = 2;
					var b = 3;
					var c = a + b; // 5]]>
				</c>
				<p>The <b>subtraction </b> operator (<c>-</c>) subtracts  numbers.</p>
				<c><![CDATA[
					var a = 2;
					var b = 3;
					var c = a - b; // -1]]>
				</c>
				<p>The <b>multiplication</b> operator (<c>*</c>) multiplies numbers.</p>
				<c><![CDATA[
					var a = 2;
					var b = 3;
					var c = a * b; // 6]]>
				</c>
				<p>The <b>division</b> operator (<c>/</c>) divides  numbers.</p>
				<c><![CDATA[
					var a = 6;
					var b = 2;
					var c = a / b; // 3]]>
				</c>
				<p>If at least one of operators is a real number, the Goat interpreter performs real division (for example, <c>6.0 / 4 = 1.5</c>). If both operators are integers, the interpreter performs integer division, i.e. the fractional part of the result will be lost (<c>6 / 4 = 1</c>).</p>
				<p>The <b>modular</b> operator (<c>%</c>) returns the division remainder.</p>
				<c><![CDATA[
					var a = 17;
					var b = 10;
					var c = a % b; // 7]]>
				</c>
				<p>The <b>increment </b> operator (<c>++</c>) increments numbers.</p>
				<c><![CDATA[
					var a = 2;
					a++; // 3]]>
				</c>
				<p>The <b>decrement</b> operator (<c>--</c>) decrements numbers.</p>
				<c><![CDATA[
					var a = 2;
					a--; // 1]]>
				</c>
			</s>
			<s name="Operator precedence">
				<p>Operator precedence describes the order in which operations are performed in an arithmetic expression.</p>
				<c>var x = 100 + 50 * 3;</c>
				<p>As in traditional mathematics, the multiplication is done first. Multiplication (<c>*</c>) and division (<c>/</c>) have higher <b>precedence</b> than addition (<c>+</c>) and subtraction (<c>-</c>).</p>
				<p>The precedence can be changed by using parentheses:</p>
				<c>var x = (100 + 50) * 3;</c>
				<p>When using parentheses, the operations inside the parentheses are computed first.</p>
				<p>When many operations have the same precedence (like addition and subtraction), they are computed from left to right:</p>
				<c>var x = 100 + 50 - 3;</c>
			</s>
			<s name="Operator precedence values">
				<t>
					<h>
						<c width="100">Value</c>
						<c width="100">Operator</c>
						<c>Description</c>
						<c>Example</c>
					</h>
					<r>
						<c>21</c>
						<c><c>()</c></c>
						<c>Expression grouping</c>
						<c><c>(3 + 4)</c></c>
					</r>
					<r>
						<c>20</c>
						<c><c>.</c></c>
						<c>Member</c>
						<c><c>person.name</c></c>
					</r>
					<r>
						<c>20</c>
						<c><c>[]</c></c>
						<c>Member</c>
						<c><c>person["name"]</c></c>
					</r>
					<r>
						<c>20</c>
						<c><c>?.</c></c>
						<c>Member with void guard</c>
						<c><c>person?.name</c></c>
					</r>
					<r>
						<c>19</c>
						<c><c>()</c></c>
						<c>Function call</c>
						<c><c>func()</c></c>
					</r>
					<r>
						<c>19</c>
						<c><c>new</c></c>
						<c>Create</c>
						<c><c>new StringBuilder()</c></c>
					</r>
					<r>
						<c>18</c>
						<c><c>++</c></c>
						<c>Prefix increment</c>
						<c><c>++x</c></c>
					</r>
					<r>
						<c>18</c>
						<c><c>--</c></c>
						<c>Prefix decrement</c>
						<c><c>--x</c></c>
					</r>
					<r>
						<c>17</c>
						<c><c>++</c></c>
						<c>Postfix increment</c>
						<c><c>x++</c></c>
					</r>
					<r>
						<c>17</c>
						<c><c>--</c></c>
						<c>Postfix decrement</c>
						<c><c>x--</c></c>
					</r>
					<r>
						<c>16</c>
						<c><c>!</c></c>
						<c>Logical not</c>
						<c><c>!x</c></c>
					</r>
					<r>
						<c>16</c>
						<c><c>!!</c></c>
						<c>Logical double not</c>
						<c><c>!!x</c></c>
					</r>
					<r>
						<c>16</c>
						<c><c>~</c></c>
						<c>Bitwise not</c>
						<c><c>~x</c></c>
					</r>
					<r>
						<c>15</c>
						<c><c>+</c></c>
						<c>Unary plus</c>
						<c><c>+x</c></c>
					</r>
					<r>
						<c>15</c>
						<c><c>-</c></c>
						<c>Unary minus</c>
						<c><c>-x</c></c>
					</r>
					<r>
						<c>14</c>
						<c><c>-&gt;</c></c>
						<c>Inherit</c>
						<c><c>A -&gt; { }</c></c>
					</r>
					<r>
						<c>13</c>
						<c><c>#</c></c>
						<c>Write protect</c>
						<c><c># { }</c></c>
					</r>
					<r>
						<c>12</c>
						<c><c>*</c></c>
						<c>Multiplication</c>
						<c><c>10 * 5</c></c>
					</r>
					<r>
						<c>12</c>
						<c><c>/</c></c>
						<c>Division</c>
						<c><c>10 / 5</c></c>
					</r>
					<r>
						<c>12</c>
						<c><c>%</c></c>
						<c>Modulo (remainder)</c>
						<c><c>17 % 10</c></c>
					</r>
					<r>
						<c>11</c>
						<c><c>+</c></c>
						<c>Addition</c>
						<c><c>2 + 3</c></c>
					</r>
					<r>
						<c>11</c>
						<c><c>-</c></c>
						<c>Subtraction</c>
						<c><c>5 - 2</c></c>
					</r>
					<r>
						<c>10</c>
						<c><c>&lt;&lt;</c></c>
						<c>Shift left</c>
						<c><c>x &lt;&lt; 2</c></c>
					</r>
					<r>
						<c>10</c>
						<c><c>&gt;&gt;</c></c>
						<c>Shift right</c>
						<c><c>x &gt;&gt; 2</c></c>
					</r>
					<r>
						<c>10</c>
						<c><c>&gt;&gt;&gt;</c></c>
						<c>Shift right (unsigned)</c>
						<c><c>x &gt;&gt;&gt; 2</c></c>
					</r>
					<r>
						<c>9</c>
						<c><c>&amp;</c></c>
						<c>Bitwise and</c>
						<c><c>x &amp; y</c></c>
					</r>
					<r>
						<c>8</c>
						<c><c>^</c></c>
						<c>Bitwise xor</c>
						<c><c>x ^ y</c></c>
					</r>
					<r>
						<c>7</c>
						<c><c>|</c></c>
						<c>Bitwise or</c>
						<c><c>x | y</c></c>
					</r>
					<r>
						<c>6</c>
						<c><c>&lt;</c></c>
						<c>Less than</c>
						<c><c>x &lt; y</c></c>
					</r>
					<r>
						<c>6</c>
						<c><c>&lt;=</c></c>
						<c>Less than or equal</c>
						<c><c>x &lt;= y</c></c>
					</r>
					<r>
						<c>6</c>
						<c><c>&gt;</c></c>
						<c>Greater than</c>
						<c><c>x &gt; y</c></c>
					</r>
					<r>
						<c>6</c>
						<c><c>&gt;=</c></c>
						<c>Greater than or equal</c>
						<c><c>x &gt;= y</c></c>
					</r>
					<r>
						<c>5</c>
						<c><c>==</c></c>
						<c>Equal</c>
						<c><c>x == y</c></c>
					</r>
					<r>
						<c>5</c>
						<c><c>!=</c></c>
						<c>Not equal</c>
						<c><c>x != y</c></c>
					</r>
					<r>
						<c>4</c>
						<c><c>&amp;&amp;</c></c>
						<c>Logical and</c>
						<c><c>x &amp;&amp; y</c></c>
					</r>
					<r>
						<c>3</c>
						<c><c>||</c></c>
						<c>Logical or</c>
						<c><c>x || y</c></c>
					</r>
					<r>
						<c>2</c>
						<c><c>?</c></c>
						<c>Ternary operator</c>
						<c><c>a ? b : c</c></c>
					</r>
					<r>
						<c>1</c>
						<c><c>=</c></c>
						<c>Assign</c>
						<c><c>x = y</c></c>
					</r>
					<r>
						<c>1</c>
						<c><c>+=</c></c>
						<c>Assign by</c>
						<c><c>x += y</c></c>
					</r>
					<r>
						<c>1</c>
						<c><c>-=</c></c>
						<c>Assign by</c>
						<c><c>x -= y</c></c>
					</r>
					<r>
						<c>1</c>
						<c><c>*=</c></c>
						<c>Assign by</c>
						<c><c>x *= y</c></c>
					</r>
					<r>
						<c>1</c>
						<c><c>/=</c></c>
						<c>Assign by</c>
						<c><c>x *= y</c></c>
					</r>
					<r>
						<c>1</c>
						<c><c>%=</c></c>
						<c>Assign by</c>
						<c><c>x %= y</c></c>
					</r>
					<r>
						<c>1</c>
						<c><c>&lt;&lt;=</c></c>
						<c>Assign by</c>
						<c><c>x &lt;&lt;= y</c></c>
					</r>
					<r>
						<c>1</c>
						<c><c>&gt;&gt;=</c></c>
						<c>Assign by</c>
						<c><c>x &gt;&gt;= y</c></c>
					</r>
					<r>
						<c>1</c>
						<c><c>&gt;&gt;&gt;=</c></c>
						<c>Assign by</c>
						<c><c>x &gt;&gt;&gt;= y</c></c>
					</r>
					<r>
						<c>1</c>
						<c><c>&amp;=</c></c>
						<c>Assign by</c>
						<c><c>x &amp;= y</c></c>
					</r>
					<r>
						<c>1</c>
						<c><c>^=</c></c>
						<c>Assign by</c>
						<c><c>x ^= y</c></c>
					</r>
					<r>
						<c>1</c>
						<c><c>|=</c></c>
						<c>Assign by</c>
						<c><c>x |= y</c></c>
					</r>
				</t>
			</s>
		</s>
		<s name="Assignment">
			<p>The <c>=</c> assignment operator assigns a value to a variable.</p>
			<c>var x = 10; // 10</c>
			<p>The <c>+=</c> assignment operator adds a value to a variable.</p>
			<c><![CDATA[
				var x = 10;
				x += 5; // 15 ]]>
			</c>
			<p>The <c>-=</c> assignment operator subtracts a value from a variable.</p>
			<c><![CDATA[
				var x = 10;
				x -= 5; // 5 ]]>
			</c>
			<p>The <c>*=</c> assignment operator multiplies a variable.</p>
			<c><![CDATA[
				var x = 10;
				x *= 5; // 50 ]]>
			</c>
			<p>The <c>/=</c> assignment operator divides a variable.</p>
			<c><![CDATA[
				var x = 10;
				x /= 5; // 2 ]]>
			</c>
			<p>The <c>%=</c> assignment operator assigns a remainder to a variable.</p>
			<c><![CDATA[
				var x = 17;
				x %= 10; // 7 ]]>
			</c>
		</s>
		<s name="Data types">
			<p>Goat variables can hold many data types: numbers, strings, objects and more:</p>
			<c>	<![CDATA[
				var length = 16; // Integer
				var price = 11.99; // Real
				var name = "Ivan"; // String
				var obj = {name: "Ivan", age: 33}; // Object
				x %= 10; // 7 ]]>
			</c>
			<s name="Concept">
				<p>In programming, data types is an important concept. To be able to operate on variables, it is important to know something about the type.</p>
				<p>For example, when adding a number and a something, the Goat interpreter will treat the second operator as a number:</p>
				<c>var x = 2 + 3; // result is: 5</c>
				<p>But, when adding a string and a something, the Goat interpreter will treat the second operator as a string. If the second operator is not a string, the interpreter will convert it to the string:</p>
				<c>var s = "text" + 123; // result is: "text123"</c>
				<p>The Goat interpreter evaluates expressions from left to right (but according to precedence).  Different sequences can produce different results:</p>
				<c><![CDATA[
					var s1 = "text" + 2 + 3; // result is: "text23"
					var s2 = "text" + (2 + 3); // result is: "text5"]]>
				</c>
			</s>
			<s name="Goat types are dynamic">
				<p>The Goat language has dynamic types. This means that the same variable can be used to hold different data types:</p>
				<c><![CDATA[
					var x; // 'x' is undefined
					x = 5; // now 'x' is a integer
					x = "Ivan"; // now 'x' is a string]]>
				</c>
			</s>
			<s name="Strings">
				<p>A string (or a text string) is a series of characters like "Abracadabra". Strings are written with double quotes:</p>
				<c>var name="Ivan";</c>
			</s>
			<s name="Chars">
				<p>Char is a single symbol. Chars are written with single quotes:</p>
				<c>var c = 'A';</c>
			</s>
			<s name="Integers">
				<p>A number without decimal point:</p>
				<c>var i = 10;</c>
			</s>
			<s name="Real numbers">
				<p>A number with decimal point (also, it called "floating-point number"):</p>
				<c>var r = 0.01;</c>
			</s>
			<s name="Booleans">
				<p>Booleans can only have two values: <c>true</c> or <c>false</c>:</p>
				<c><![CDATA[
					var t = true;
					var f = false;]]>
				</c>
				<p>Booleans are often used in conditional testing:</p>
				<c><![CDATA[
					var x = 5;
					var y = 5;
					var z = 6;
					var t = (x == y); // true
					var f = (x == z); // false]]>
				</c>
			</s>
			<s name="Arrays">
				<p>Goat arrays are written with square brackets. Array items are separated by commas. The following code declares (creates) an array called <c>herd</c>, containing three items (goats nicknames):</p>
				<c>var herd = ["Dirty", "Stinky", "Crazy"];</c>
				<p>Array indexes are zero-based, which means the first item is <c>[0]</c>, second is <c>[1]</c>, and so on.</p>
			</s>
			<s name="Objects">
				<p>Goat objects are written with curly braces. Object properties are written as <c>name: value</c> pairs, separated by commas.</p>
				<c>var goat = { name: "Stinky", wool: Color.WHITE, age: 3}; </c>
			</s>
			<s name="Undefined">
				<p>In the Goat language, a variable without a value, has the value <c>undefined</c>.</p>
				<c>var name; // value is undefined</c>
				<p>Any variable can be emptied, by setting the value to <c>undefined</c>.</p>
				<c>name = undefined;</c>
			</s>
			<s name="Null">
				<p>In the Goat language, <c>null</c> is "nothing". It is supposed to be something that doesn't exist. Any variable can be emptied, by setting the value to <c>null</c>.</p>
				<c>name = null;</c>
			</s>
			<p><c>null</c> is not <c>undefined</c>! <c>null</c> means: it defined, but the value of it is "nothing".</p>
		</s>
		<s name="Functions">
			<p>A Goat function is a block of code designed to perform a particular task. A Goat function is executed when "something" invokes it (calls it).</p>
			<c><![CDATA[
				var myFunction = function(a, b)
				{
					return a * b; // the function returns the product of 'a' and 'b'
				};]]>
			</c>
			<p>Why Functions? You can reuse code: Define the code once, and use it many times. You can use the same code many times with different arguments, to produce different results.</p>
			<s name="Syntax">
				<p>A Goat function is defined with the <c>function</c> keyword, followed by parentheses (). The parentheses may include parameter names separated by commas: <c>(parameter_1, parameter_2, ...)</c>. The code to be executed, by the function, is placed inside curly brackets: <c>{}</c>. To name a function (for the ability of invocation), the function object needs to be written to a variable:</p>
				<c><![CDATA[
					var name = function(parameter_1, parameter_2, parameter_3)
					{
						//code to be executed
					};]]>
				</c>
				<p>In the Goat language, the <c>function</c> keyword (it is long and is used very often ) can be changed to a dollar sign <c>$</c>:</p>
				<c><![CDATA[
					var name = $(parameter_1, parameter_2, parameter_3)
					{
						//code to be executed
					};]]>
				</c>
				<p>Function <b>parameters</b> are listed inside the parentheses <c>()</c> in the function definition. Function <b>arguments</b> are the <b>values</b> received by the function when it is invoked. Inside the function, the arguments (the parameters) behave as local variables.</p>
			</s>
			<s name="Return">
				<p>When the Goat interpreter reaches a <b>return statement</b>, the function will stop executing, then the interpreter will "return" to execute the code after the invoking statement. Functions often compute a return value. The return value is "returned" back to the "caller":</p>
				<c><![CDATA[
					var myFunction = function(a, b)
					{
						return a * b; // the function returns the product of 'a' and 'b'
					};
					
					var x = myFunction(4, 3);]]>
				</c>
				<p>The result in <c>x</c> will be <c>12</c>.</p>
			</s>
			<s name="Invocation">
				<p>The <c>()</c> operator invokes the function.</p>
				<p>To invoke a function without arguments, use empty operator:</p>
				<c><![CDATA[
					var doSomething = function()
					{
						//...
					};
					
					//...
					
					doSomething();]]>
				</c>
				<p>To invoke a function with arguments, place arguments, separated by comma, inside the <c>()</c> operator: </p>
				<c><![CDATA[
					var doSomething = function(a, b, c)
					{
						//...
					};
					
					//...
					
					doSomething("test", 3.14, false);]]>
				</c>
				<p>An argument can be any expression - string, number, another function call, etc.</p>
			</s>
			<s name="Built-in functions">
				<p>The Goat language has a lot of built-in functions (so-called built-in library). This library provides type definitions and functions for tasks such as string handling, mathematical computations, input/output processing and several other operating system services.</p>
				<p>For example, the <c>print</c> function converts the first argument to a string and outputs it to a console:</p>
				<c>print(2 + 3); // outputs: 5</c>
				<p>Built-in functions are fully described in the <link title="appropriate">Built-in functions</link> chapter.</p>
			</s>
		</s>
		<s name="Objects">
			<s name="Real life objects, properties and methods">
				<p>In real life, a car is an <b>object</b>. A car has <b>properties</b> like weight and color, and <b>methods</b> like start and stop.</p>
				<p>Object:</p>
				<c>var car = {};</c>
				<p>Properties:</p>
				<c><![CDATA[
					car.name = "Fiat";
					car.model = 500;
					car.weight = "850kg";
					car.color = "white";]]>
				</c>
				<p>Methods:</p>
				<c><![CDATA[
					car.start();
					car.drive();
					car.brake();
					car.stop();]]>
				</c>
				<p>All cars have the same <b>properties</b>, but the property values differ from car to car.</p>
				<p>All cars have the same <b>methods</b>, but the methods are performed at different times.</p>
			</s>
			<s name="Goat objects">
				<p>Recall that Goat variables are containers for data values. This code assigns a simple value ("Fiat") to a variable named <c>car</c>:</p>
				<c>var car = "Fiat";</c>
				<p>Objects are variables too. But objects can contain many values. This code assigns <b>many values</b> ("Fiat", 500, "white") to a <b>variable</b> named car:</p>
				<c>var car = {type: "Fiat", model: 500, color:"white"};</c>
				<p>The values are written as <c>name:value</c> pairs (name and value separated by a colon).</p>
			</s>
			<s name="Properties">
				<p>The <c>name:values</c> pairs (in Goat objects) are called properties.</p>
				<c>var goat = { name: "Stinky", wool: Color.WHITE, age: 3 };</c>
				<t>
					<h>
						<c width="100">Property</c>
						<c>Value</c>
					</h>
					<r>
						<c>name</c>
						<c>"Stinky"</c>
					</r>
					<r>
						<c>wool</c>
						<c>Color.WHITE</c>
					</r>
					<r>
						<c>age</c>
						<c>3</c>
					</r>
				</t>
			</s>
			<s name="Methods">
				<p>Methods are <b>actions</b> that can be performed on objects. Methods are stored in properties as <b>function definitions.</b> In other words, methods are functions that are performed on an object.</p>
				<c><![CDATA[
					var person = 
					{
						firstName : "Scott",
						lastName : "Cameron",
						age : 45,
						
						fullName : function()
						{
							return firstName + ' ' + lastName;
						}
					};
					
					var name = person.fullName(); // result is: "Scott Cameron"]]>
				</c>
			</s>
			<s name="Definition">
				<p>You define (and create) a Goat object with an object literal:</p>
				<c>var person = { firstName : "Scott", lastName : "Cameron", age : 45 };</c>
				<p>Spaces and line breaks are not important. An object definition can span multiple lines:</p>
				<c><![CDATA[
					var person =
					{
						firstName : "Scott",
						lastName : "Cameron",
						age : 45
					};]]>
				</c>
			</s>
			<s name="Accessing object properties">
				<p>You can access object properties in two ways:</p>
				<c>objectName.propertyName</c>
				<p>or</p>
				<c>objectName["propertyName"]</c>
				<p>For example,</p>
				<c>person.lastName</c>
				<p>or</p>
				<c>person["lastName"];</c>
			</s>
			<s name="Accessing object methods">
				<p>You access an object method with the following syntax:</p>
				<c>objectName.methodName()</c>
				<p>For example,</p>
				<c>name = person.fullName();</c>
			</s>
			<s name="Nested objects">
				<p>Properties can be not only strings and numbers, but also arrays and objects:</p>
				<c><![CDATA[
					var person = {
						firstName : "Scott",
						lastName : "Cameron",
						age : 45,
						children: [
							{ firstName: "Ann", lastName: "Cameron", age: 10 },
							{ firstName: "Dave", lastName: "Cameron", age: 14 }
						]
					};]]>
				</c>
				<p>Thus, objects can be unlimitedly nested within each other.</p>
			</s>
			<s name="Objects, variables and references">
				<p>Let's create a new object and assign it to a variable:</p>
				<c>var a = { name: "Ivan", age: 33 };</c>
				<p>Then, let's assign this variable to another variable:</p>
				<c>var b = a;</c>
				<p>Okay. Now, we try to look what the second variable contains:</p>
				<c>print(b); // output: {name:"Ivan",age:33}</c>
				<p>Right, it contains the same that contains the first variable. Now, we change one property of the second variable:</p>
				<c>b.name = "John";</c>
				<p>Now let's look at the result:</p>
				<c>print(b); // output: {name:"John",age:33}</c>
				<p>And now let's see what the first variable contains:</p>
				<c>print(a); // output: {name:"John",age:33}</c>
				<p>Thus, we changed the property of the second variable, but the first one also changed. Why? The Goat programming language does not store whole objects in variables. <b>The Goat programming language stores in the variables only references to objects, but not the objects themselves.</b> If you copy one variable to another, only the reference is copied.</p>
				<p>What can you do if you need to make a real copy of the object? Use special method <c>clone</c>:</p>	
				<c><![CDATA[
					var a = { name: "Ivan", age: 33 };
					var b = a.clone();
					b.name = "Jonh";
					print(b); // output: {name:"John",age:33}
					print(a); // output: {name:"Ivan",age:33}]]>
				</c>
			</s>
		</s>
		<s name="Scope">
			<p>Scope determines the accessibility (visibility) of variables.</p>
			<p>Variables declared within a Goat block (function, etc), become <b>local</b> to this block. Local variables have local scope: they can only be accessed within the block.</p>
			<c><![CDATA[
				// code here can not use 'nickname'
				
				var myFunction = function()
				{
					var nickname = "Stinky";
					
					// code here can use 'nickname'
				};
				
				// code here can not use 'nickname']]>
			</c>
			<p>However, local variables can be accessed from inner blocks:</p>
			<c><![CDATA[
				var myFunction = function()
				{
					var nickname = "Stinky";
					
					//...
					if (expression)
					{
						// code here can use 'nickname'
					}
					
					// code here can use 'nickname'
				};]]>
			</c>
			<p>Functions are inner blocks also. So, each function can access variables, declared outside this function:</p>
			<c><![CDATA[
				var myFunction = function()
				{
					var nickname = "Stinky";
					
					//...
					var innerFunction = function()
					{
						// code here can use 'nickname'
					};
					
					// code here can use 'nickname'
				};]]>
			</c>
			<p>Variables declared within a block, redefines variables with the same names, declared outside a block. New variable uses only in this block:</p>
			<c><![CDATA[
				var myFunction = function()
				{
					var nickname = "Stinky";
					//...
					print(nickname); // output: "Stinky"
					//...
					var innerFunction = function()
					{
						var nickname = "Dirty"; // redefine 'nickname' variable
						//...
						print(nickname); // output: "Dirty"
					};
					//...
					innerFunction();
					//...
					print(nickname); // output: "Stinky"
				};]]>
			</c>
		</s>
		<s name="Strings">
			<p>Goat strings are used for storing and manipulating text.</p>
			<s name="Definition">
				<p>A Goat string is zero or more characters written inside double quotes.</p>
				<c>var s = "Have a nice day";</c>
			</s>
			<s name="Special characters">
				<p>Because strings must be written within quotes, Goat will misunderstand this string:</p>
				<c>var s = "The line "No, I am your father" is often misquoted as "Luke, I am your father."";</c>
				<p>The string will be chopped to <c>"The line "</c>.</p>
				<p>The solution to avoid this problem, is to use the <b>backslash escape character.</b> The backslash (<c>\</c>) escape character turns special characters into string characters:</p>
				<t>
					<h>
						<c width="120">Code</c>
						<c width="120">Result</c>
						<c>Description</c>
					</h>
					<r>
						<c><c>\n</c></c>
						<c></c>
						<c>New line</c>
					</r>
					<r>
						<c><c>\r</c></c>
						<c></c>
						<c>Carriage return</c>
					</r>
					<r>
						<c><c>\t</c></c>
						<c></c>
						<c>Tabulation</c>
					</r>
					<r>
						<c><c>\&apos;</c></c>
						<c><c>&apos;</c></c>
						<c>Apostrophe (single quote)</c>
					</r>
					<r>
						<c><c>\&quot;</c></c>
						<c><c>&quot;</c></c>
						<c>Double quote</c>
					</r>
					<r>
						<c><c>\\</c></c>
						<c><c>\</c></c>
						<c>Backslash</c>
					</r>
				</t>
				<p>The sequence <c>\"</c> inserts a double quote in a string:</p>
				<c>var s = "The line \"No, I am your father\" is often misquoted as \"Luke, I am your father.\"";</c>
				<p>The sequence <c>\\</c> inserts a backslash in a string:</p>
				<c>var s = "The character \\ is called backslash.";</c>
			</s>
			<s name="Strings are objects">
				<p>The Goat language has no primitive types. All data represented as objects, including strings. For example, 
				another way to define string is the explicit definition (as an object) by operator <c>new</c>:</p>
				<c>var s = new String("My name is Ivan");</c>
				<p>Don't create strings using operator new. This makes no sense. This example is needed to show that in principle, the string does not differ from other objects (it has a prototype, it can be created by the <c>new</c> operator, and so on).</p>
				<p>Since a string is an object, it has properties, including methods. For example, the <c>length</c> method returns the length of a string:</p>
				<c><![CDATA[
					var s = "Test";
					var n = s.length(); // value of 'n' will be 4]]>
				</c>
			</s>
			<s name="String methods">
				<m name="length" descr="Returns the length of a string."/>
				<m name="substr" descr="Extracts a part of a string and returns the extracted part in a new string.">
					<a name="start" type="Integer" descr="the starting index (position). 0 is the first symbol"/>
					<a name="count" type="Integer" descr="optional; count of characters. If not specified, the substring begins with the character at the specified index and extends to the end of this string. If specified, anyway, the method returns not more symbols than it possible"/>
					<e><![CDATA[
						var a = "This is an example.";
						var b = a.subString(5, 2); // "is"
						var c = a.subString(11); // "example."]]>
					</e>
				</m>
				<m name="split" descr="Splits a string into an array of substrings using a separator.">
					<a name="separator" type="Char | String" descr="a separator"/>
					<e><![CDATA[
						var s = "My name is James Bond";
						var a = s.split(' '); // ["My","name","is","James","Bond"] ]]>
					</e>
				</m>
				<m name="encode">
					<d>Encodes a string into an array of bytes. Returns instance of <c>ByteArray</c> object.</d>
					<a name="encoding" type="String" descr="encoding; now only &quot;utf8&quot; is supported"/>
					<e><![CDATA[
						var s = "abcd 123 Тест";
						var a = s.encode("utf8"); // 61 62 63 64 20 31 32 33 20 d0 a2 d0 b5 d1 81 d1 82]]>
					</e>
				</m>
				<m name="valueof" descr="Converts any object to a string.">
					<a name="object" type="any type" descr="an object"/>
					<e><![CDATA[
						var i = 256 * 256;
						var s = String.valueof(i); // "65536" ]]>
					</e>
					<n>This is the static method, i.e. meant to be relevant to all the instances of a class rather than to any specific instance.</n>
				</m>
			</s>
			<s name="String operators">
				<p>Remind that each object (include strings) supports these operators: <c>-&gt;</c> (inherit), <c>==</c> (equal), <c>!=</c> (not equal) and <c>!</c> (logical not). Other operators are:</p>
				<o name="+, +=" descr="Converts the second operand to a string and then concatenates strings.">
					<e><![CDATA[
						var s0 = "hello" + ", " + "world!"; // "hello, world!";
						var s1 = "test" + 123; // "test123"
						var s2 = "value";
						s2 += 3.14; // "value3.14" ]]>
					</e>
				</o>
				<p>One of the simplest methods to convert anything to a string is adding this object to an empty string:</p>
				<c>var s = "" + 3.14; // "3.14"</c>
				<o name="&lt;, &lt;=, &gt;, &gt;=">
					<d>Lexicographical comparison of strings. If the second operator is not a string, returns <c>false</c>.</d>
					<e><![CDATA[
						print("hello" &gt;= "hell"); // outputs: true ]]>
					</e>
				</o>
			</s>
		</s>
		<s name="Characters">
			<p>A character (<c>Char</c>) is a type that corresponds to a symbol or grapheme: letter, digit etc.</p>
			<s name="Definition">
				<p>A Goat char is one character written inside single quotes.</p>
				<c>var c = 'A';</c>
			</s>
			<s name="Special characters">
				<p>As in strings, special characters after a backslash can be used here:</p>
				<t>
					<h>
						<c width="120">Code</c>
						<c width="120">Result</c>
						<c>Description</c>
					</h>
					<r>
						<c><c>\n</c></c>
						<c></c>
						<c>New line</c>
					</r>
					<r>
						<c><c>\r</c></c>
						<c></c>
						<c>Carriage return</c>
					</r>
					<r>
						<c><c>\t</c></c>
						<c></c>
						<c>Tabulation</c>
					</r>
					<r>
						<c><c>\&apos;</c></c>
						<c><c>&apos;</c></c>
						<c>Apostrophe (single quote)</c>
					</r>
					<r>
						<c><c>\&quot;</c></c>
						<c><c>&quot;</c></c>
						<c>Double quote</c>
					</r>
					<r>
						<c><c>\\</c></c>
						<c><c>\</c></c>
						<c>Backslash</c>
					</r>
				</t>
				<p>The sequence <c>\'</c> means a single quote:</p>
				<c>var c = '\'';</c>
			</s>
			<s name="Char methods">
				<m name="valueof" descr="Static method. Converts object to a char.">
					<a name="object" type="any type" descr="an object"/>
					<e><![CDATA[
						var i = 65;
						var c = Char.valueof(i); // 'A' ]]>
					</e>
					<n>If the object is an integer, returns a Char containing the character associated with the specified character code. Else, if the object is a char, just returns this object. Else, if the object is a string and this string contains only one symbol, returns this symbol. In all other cases, returns <c>null</c>.</n>
				</m>
			</s>
			<s name="Char operators">
				<o name="++, --">
					<d>Increments or decrements of a <c>Char</c> variable (or a field) by 1.</d>
					<e><![CDATA[
						var c = 'A'; // 'A';
						c++; // 'B'
						c++; // 'C'
						c--; // 'B' ]]>
					</e>
				</o>
				<o name="&lt;, &lt;=, &gt;, &gt;=">
					<d>Comparison of two <c>Char</c> objects. If the second parameter is not a char, returns <c>false</c>.</d>
					<e><![CDATA[
						print('A' < 'B'); // outputs: true]]>
					</e>
				</o>
			</s>
		</s>
		<s name="Numbers">
			<p>The Goat interpreter operates two type of numbers: integers and real numbers.</p>
			<s name="Integers">
				<s name="Definition">
					<p>Integer numbers are written without decimal point:</p>
					<c>var i = 3;</c>
					<p>Also, Goat interprets numerical constants as hexadecimal if they are preceded by <c>0x</c>:</p>
					<c><![CDATA[
						var i = 0x12ab34; // lower case symbols
						var j = 0x56CD78; // upper case symbols]]>
					</c>
					<p>and interprets numerical constants as binary if they are preceded by <c>0b</c>:</p>
					<c>var i = 0b1011;</c>
				</s>
				<s name="Methods">
					<m name="string" descr="Converts integer to a string.">
						<a name="radix" type="Integer" descr="optional, radix, one of: 2, 10 or 16, default 10"/>
						<e><![CDATA[
							var i = 254;
							var s = i.string(); // "254"
							var h = "0x" + i.string(16); // "0xfe"]]>
						</e>
					</m>
					<m name="valueof" descr="Static method. Converts object to an integer.">
						<a name="object" type="any type" descr="an object"/>
						<a name="radix" type="Integer" descr="optional, radix, one of: 2, 10 or 16, default 10"/>
						<e><![CDATA[
							var s = "  fffe ";
							var i = Integer.valueof(s, 16); // 65534 ]]>
						</e>
						<n>Attempts to convert a value to an integer, returns <c>null</c> if failed.</n>
					</m>
					<t>
						<h>
							<c width="200">Object type</c>
							<c>Conversion result</c>
						</h>
						<r>
							<c><c>Integer</c></c>
							<c>Returns unchanged</c>
						</r>
						<r>
							<c><c>Real</c></c>
							<c>Returns the integer part of a real number</c>
						</r>
						<r>
							<c><c>Boolean</c></c>
							<c>Returns <c>1</c> if <c>true</c>, <c>0</c> if <c>false</c></c>
						</r>
						<r>
							<c><c>Char</c></c>
							<c>Returns the character code as a number</c>
						</r>
						<r>
							<c><c>String</c></c>
							<c>Attempts to recognize a string as a number. Ignores whitespace before and after. Returns <c>null</c> if failed</c>
						</r>
						<r>
							<c>Other type</c>
							<c><c>null</c></c>
						</r>
					</t>
				</s>
				<s name="Operators">
					<p>The Integer type has more operators than the other types.</p>
					<o name="+, +=, -, -=, *, *=, /, /=">
						<d>Addition, subtraction, multiplication and division. Note that multiplication and division have a higher precedence than addition and subtraction, just as in algebra. If the second operand is a real number, then the result will also be a real number. If the second operand is an integer, the result will integer. Else if the second operand is not a number, returns <c>false</c>.</d>
						<e><![CDATA[
							var a = 2;
							var b = 3;
							var c = 5;
							var x = a + b * c; // 17 ]]>
						</e>
					</o>
					<o name="%, %=">
						<d>Modulo (remainder). Returns the remainder of an integer divided by an integer.</d>
						<e><![CDATA[
							var x = 17 % 10 // 7]]>
						</e>
					</o>
					<o name="&lt;, &lt;=, &gt;, &gt;=">
						<d>Comparison of two numbers (integer or real number). If the second parameter is not a number, returns <c>false</c>.</d>
						<e><![CDATA[
							print(4 > 3); // outputs: false]]>
						</e>
					</o>
					<o name="++, --">
						<d>Increments or decrements of an <c>Integer</c> variable (or a field) by 1.</d>
						<e><![CDATA[
							var x = 1; // 1;
							x++; // 2
							x++; // 3
							x--; // 2 ]]>
						</e>
					</o>
					<o name="~">
						<d>The bitwise <b>not</b>, or complement, is a unary operation that performs logical negation on each bit, forming the ones complement of the given binary value. Bits that are 0 become 1, and those that are 1 become 0:</d>
						<e><![CDATA[
							var x = 0b1011;
							var n = ~x; // ...1110100 ]]>
						</e>
						<n>The Integer is 64-bit data type, all these bits change their values. So in this example, all first bits became 1.</n>
					</o>
					<o name="&lt;&lt;, &lt;&lt;=">
						<d>Left shift, i.e.  bitwise operation that shifts all the bits of its operand. Shifts left by pushing zeros in from the right and let the leftmost bits fall off.</d>
						<e><![CDATA[
							var x = 0b1011;
							var s = x << 2; // 101100 ]]>
						</e>
					</o>
					<p>Left shifts can be useful as an efficient way to perform multiplication of unsigned integers by powers of 2. Shifting left by <c>n</c> bits on unsigned binary number has the effect of multiplying it by 2 to the power of <c>n</c>:</p>
					<c><![CDATA[
						var x = 5;
						var s = x << 3; // 5 * 8 = 40 ]]>
					</c>
					<o name="&gt;&gt;, &gt;&gt;=">
						<d>Signed right shift, shifts right by pushing copies of the leftmost bit in from the left, and let the rightmost bits fall off.</d>
						<e><![CDATA[
							var x = -5 // ...111011;
							var s = x > 1; // ...111101 (-3) ]]>
						</e>
					</o>
					<o name="&gt;&gt;&gt;, &gt;&gt;&gt;=">
						<d>Unsigned (zero fill) right shift, one or more zero bits are pushed in from the left, and the rightmost bits fall off.</d>
						<e><![CDATA[
							var x = 5 // 101;
							var s = x >>> 1; // 010 (2) ]]>
						</e>
					</o>
					<o name="&amp;, &amp;=">
						<d>Bitwise <b>and</b> returns 1 only if both bits are 1.</d>
						<e><![CDATA[
							var x = 5 // 101;
							var y = 1 // 001;
							var b = x & y; // 001 (1) ]]>
						</e>
					</o>
					<o name="|, |=">
						<d>Bitwise <b>or</b> returns 1 if one of the bits are 1.</d>
						<e><![CDATA[
							var x = 5 // 101;
							var y = 1 // 001;
							var b = x | y; // 101 (5) ]]>
						</e>
					</o>
					<o name="^, ^=">
						<d>Bitwise <b>xor</b> (exclusive <b>or</b>) returns 1 if the bits are different.</d>
						<e><![CDATA[
							var x = 5 // 101;
							var y = 1 // 001;
							var b = x ^ y; // 100 (4) ]]>
						</e>
					</o>
				</s>
			</s>
			<s name="Real numbers">
				<s name="Definition">
					<p>Real numbers are written with the decimal point (dot):</p>
					<c>var i = 3.14;</c>
				</s>
				<s name="Methods">
					<m name="valueof" descr="Static method. Converts object to a real number.">
						<a name="object" type="any type" descr="an object"/>
						<e><![CDATA[
							var s = "  65,535 ";
							var r = Real.valueof(s); // 65.535 ]]>
						</e>
						<n>Attempts to convert a value to a real number, returns <c>null</c> if failed.</n>
					</m>
					<t>
						<h>
							<c width="200">Object type</c>
							<c>Conversion result</c>
						</h>
						<r>
							<c><c>Real</c></c>
							<c>Returns unchanged</c>
						</r>
						<r>
							<c><c>Integer</c></c>
							<c>Returns the integer as a real number</c>
						</r>
						<r>
							<c><c>Boolean</c></c>
							<c>Returns <c>1.0</c> if <c>true</c>, <c>0.0</c> if <c>false</c></c>
						</r>
						<r>
							<c><c>Char</c></c>
							<c>Returns the character code as a number</c>
						</r>
						<r>
							<c><c>String</c></c>
							<c>Attempts to recognize a string as a real number. Ignores whitespace before and after. Recognizes a comma <c>,</c> as well as a dot <c>.</c> as a decimal separator. Returns <c>null</c> if failed</c>
						</r>
						<r>
							<c>Other type</c>
							<c><c>null</c></c>
						</r>
					</t>
				</s>
				<s name="Operators">
					<p>Real type supports only these operators: <c>+</c>, <c>+=</c>, <c>-</c>, <c>-=</c>, <c>*</c>, <c>*=</c>, <c>/</c>, <c>/=</c>, <c>&lt;</c>, <c>&lt;=</c>, <c>&gt;</c>, <c>&gt;=</c>, <c>++</c>, <c>--</c>. Bitwise operators are not supported.</p>
				</s>
			</s>
		</s>
		<s name="Arrays">
			<p>Goat arrays are used to store multiple values in a single variable.</p>
			<s name="Creating an array">
				<p>Using an array literal <c>[ ]</c>:</p>
				<c>var array_name = [item1, item2, ...];</c>
				<p>For example:</p>
				<c>var herd = ["Dirty", "Stinky", "Crazy"];</c>
				<p>Spaces and line breaks are not important. A declaration can span multiple lines:</p>
				<c><![CDATA[
					var herd = [
						"Dirty",
						"Stinky",
						"Crazy"
					];]]>
				</c>
				<p>Array elements can be objects, arrays, numbers, strings... (remind that numbers, strings etc - all are objects). Arrays are special kinds of objects. You can have functions in an array. You can have even arrays in an array.</p> 
			</s>
			<s name="Access the elements of an array">
				<p>You refer to an array element by referring to the <b>index number.</b> <c>[0]</c> is the first element in an array. <c>[1]</c> is the second. Array indexes start with 0.</p>
				<p>This statement accesses the value of the first element in <c>herd</c> array:</p>
				<c>var name = herd[0];</c>
				<p>This statement modifies the first element in <c>herd</c> array:</p>
				<c>herd[0] = "Nasty";</c>
			</s>
			<s name="Adding array elements">
				<p>The way to add a new element to an array is using the <c>push</c> method:</p>
				<c><![CDATA[
					var fruits = ["Banana", "Orange", "Apple", "Mango"];
					fruits.push("Lemon"); // adds a new element ("Lemon") to fruits ]]>
				</c>
			</s>
			<s name="The difference between arrays and objects">
				<p>Arrays use <b>numbered indexes.</b></p>
				<p>Objects use <b>named indexes.</b></p>
				<p>Arrays are a special kind of objects, with numbered indexes.</p>
			</s>
			<s name="Array methods">
				<m name="length" descr="Returns the length (count of items) of an array."/>
				<m name="push" descr="Adds a new item to the end of an array.">
					<a name="object" type="any type" descr="an item"/>
				</m>
			</s>
			<s name="Array operators">
				<o name="+">
					<d>If the second operand is array, returns a new array that is a concatenation of two operands, i.e. contains all items from the left operand and then all items from the right operand. Otherwise, if the second operand is not an array (so it is another object), returns a new array contains all items from the left operand plus one additional item (right operand).</d>
					<e><![CDATA[
						var a = [1,2,3];
						var b = [4,5];
						var x = a + b; // [1,2,3,4,5]
						var y = x + 6; // [1,2,3,4,5,6] ]]>
					</e>
				</o>
			</s>
			<s name="Looping array elements">
				<p>The best way to loop through an array, is using a <c>for</c> loop:</p>
				<c><![CDATA[
					var fruits = ["Banana", "Orange", "Apple", "Mango"];
					var i, count = fruits.length();
					for (i = 0; i < count; i++)
					{
						println(fruits[i]);
					} ]]>
				</c>
				<p>Output:</p>
				<c><![CDATA[
					Banana
					Orange
					Apple
					Mango ]]>
				</c>
				<p>The same result with <c>for..in</c> loop:</p>
				<c><![CDATA[
					var fruits = ["Banana", "Orange", "Apple", "Mango"];
					var fruit;
					for (fruit in fruits)
					{
						println(fruit);
					} ]]>
				</c>
			</s>
		</s>
		<s name="Booleans">
			<p>A Goat <c>Boolean</c> represents one of two values: <c>true</c> or <c>false</c>.</p>
			<s name="Boolean values">
				<p>Very often, in programming, you will need a data type that can only have one of two values, like</p>
				<l>
					<i><b>Yes</b> or <b>No</b></i>
					<i><b>On</b> or <b>Off</b></i>
					<i><b>Light Side</b> or <b>Dark Side</b></i>
				</l>
				<p>For this, The Goat programming language has a <c>Boolean</c> data type. It can only take the values <c>true</c> or <c>false</c>.</p>
				<c><![CDATA[
					var t = true;
					var f = false; ]]>
				</c>
			</s>
			<s name="Comparisons and conditions">
				<p>The chapter <link>Comparisons</link> gives a full overview of comparison operators.</p>
				<p>The chapter <link>Conditions</link> gives a full overview of conditional statements.</p>
				<p>Here are some examples:</p>
				<t>
					<h>
						<c width="100">Operator</c>
						<c>Description</c>
						<c>Example</c>
					</h>
					<r>
						<c><c>==</c></c>
						<c>Equal to</c>
						<c><c>if (day == "Monday")</c></c>
					</r>
					<r>
						<c><c>&gt;</c></c>
						<c>Greater than</c>
						<c><c>if (salary &gt; 9000)</c></c>
					</r>
					<r>
						<c><c>&lt;</c></c>
						<c>Less than</c>
						<c><c>if (age &lt; 18)</c></c>
					</r>
				</t>
				<p>The Boolean value of an expression is the basis for all Goat comparisons and conditions.</p>
			</s>
		</s>
		<s name="Comparison and logical operators" anchor="Comparisons">
			<p>Comparison and logical operators are used to test for <c>true</c> or <c>false</c>.</p>
			<s name="Comparison operators">
				<p>Comparison operators are used in logical statements to determine equality or difference between variables or values.</p>
				<p>Given that <c>x = 5</c>, the table below explains the comparison operators:</p>
				<t>
					<h>
						<c width="100">Operator</c>
						<c>Description</c>
						<c>Comparing</c>
						<c>Returns</c>
					</h>
					<r>
						<c><c>==</c></c>
						<c>Equal to</c>
						<c><c>x == 8</c></c>
						<c><c>false</c></c>
					</r>
					<r>
						<c/>
						<c/>
						<c><c>x == 5</c></c>
						<c><c>true</c></c>
					</r>
					<r>
						<c/>
						<c/>
						<c><c>x == "5"</c></c>
						<c><c>false</c></c>
					</r>
					<r>
						<c><c>!=</c></c>
						<c>Not equal</c>
						<c><c>x != 8</c></c>
						<c><c>true</c></c>
					</r>
					<r>
						<c><c>&gt;</c></c>
						<c>Greater than</c>
						<c><c>x &gt; 8</c></c>
						<c><c>false</c></c>
					</r>
					<r>
						<c><c>&lt;</c></c>
						<c>Less than</c>
						<c><c>x &lt; 8</c></c>
						<c><c>true</c></c>
					</r>
					<r>
						<c><c>&gt;=</c></c>
						<c>Greater than or equal to</c>
						<c><c>x &gt;= 8</c></c>
						<c><c>false</c></c>
					</r>
					<r>
						<c><c>&lt;=</c></c>
						<c>Less than or equal to</c>
						<c><c>x &lt;= 5</c></c>
						<c><c>true</c></c>
					</r>
				</t>
				<p>Comparison operators can be used in conditional statements to compare values and take action depending on the result:</p>
				<c>if (age &lt; 18) print("Too young");</c>
			</s>
			<s name="Logical operators">
				<p>Logical operators are used to determine the logic between variables or values.</p>
				<p>Given that <c>x = 6</c> and <c>y = 3</c>, the table below explains the logical operators:</p>
				<t>
					<h>
						<c width="100">Operator</c>
						<c>Description</c>
						<c>Example</c>
						<c>Returns</c>
					</h>
					<r>
						<c><c>&amp;&amp;</c></c>
						<c>Logical <b>and</b></c>
						<c><c>(x &lt; 10 &amp;&amp; y &gt; 1)</c></c>
						<c><c>true</c></c>
					</r>
					<r>
						<c><c>||</c></c>
						<c>Logical <b>or</b></c>
						<c><c>(x == 5 || y == 5)</c></c>
						<c><c>false</c></c>
					</r>
					<r>
						<c><c>!</c></c>
						<c>Logical <b>not</b></c>
						<c><c>!(x == y)</c></c>
						<c><c>true</c></c>
					</r>
				</t>
				<h name="Logical and (&amp;&amp;)">
					<p>The expression <c>A &amp;&amp; B</c> is <c>true</c> if <c>A</c> and <c>B</c> are both <c>true</c>; else it is <c>false</c>.</p>
				</h>
				<h name="Logical or (||)">
					<p>The expression <c>A || B</c> is <c>true</c> if <c>A</c> or <c>B</c> (or both) are <c>true</c>; if both are <c>false</c>, the expression is <c>false</c>.</p>
				</h>
				<h name="Logical not (!)">
					<p>The expression <c>!A</c> is <c>true</c> if <c>A</c> is <c>false</c>.</p>
				</h>
			</s>
			<s name="Conditional (ternary) operator">
				<p>Goat also contains a conditional operator that assigns a value to a variable based on some condition:</p>
				<c>variablename = (condition) ? value1 : value2</c>
				<p>For example,</p>
				<c>var voteable = (age &lt; 18) ? "Too young" : "Old enough";</c>
				<p>If the variable <c>age</c> is a value below 18, the value of the variable voteable will be <c>"Too young"</c>, otherwise the value of voteable will be <c>"Old enough"</c>.</p>
			</s>
			<s name="Comparing different types">
				<p>Comparing data of different types may give unexpected results. As a rule, the operators <c>==</c> and <c>!=</c> check that the types of the two variables match, otherwise will be returned default value (<c>false</c> in case of <c>==</c>). For example, you can compare numbers but you can not compare a number and a string. If you need to compare, just explicit convert an operand to another type to match the second operand:</p>
				<c><![CDATA[
					var s = "1024";    // String
					var i = 256 * 4;   // Integer
					if (String.valueof(i) == s)
					{
						// do something
					}]]>
				</c>
				<p>There is one exclusion. You can compare integer numbers and real numbers although they are different types. An integer operand will be converted to a real before comparison.</p>
				<p>If you really not sure that operands have the same type, but you extremely need to compare it, cast both operands to the same type:</p>
				<c><![CDATA[
					var s = "1024";
					var i = 256 * 4;
					if (Real.valueof(i) == Real.valueOf(s)) // convert both to Real
					{
						// do something
					}]]>
				</c>
			</s>
		</s>
		<s name="Conditions" anchor="Conditions">
			<s name="Conditional statements">
				<p>Conditional statements are used to perform different actions based on different conditions.</p>
				<p>Very often when you write code, you want to perform different actions for different decisions. You can use conditional statements in your code to do this. In Goat we have the following conditional statements:</p>
				<l>
					<i>Use <c>if</c> to specify a block of code to be executed, if a specified condition is true</i>
					<i>Use <c>else</c> to specify a block of code to be executed, if the same condition is false</i>
					<i>Use <c>else if</c> to specify a new condition to test, if the first condition is false</i>
					<i>Use <c>switch</c> to specify many alternative blocks of code to be executed</i>
				</l>
			</s>
			<s name="The 'if' statement">
				<p>Use the <c>if</c> statement to specify a block of Goat code to be executed if a condition is true. Syntax:</p>
				<c><![CDATA[
					if (condition)
					{
						block of code to be executed if the condition is true
					}]]>
				</c>
				<p>Example (outputs <c>"Okay"</c>):</p>
				<c><![CDATA[
					var testscore = 70;
					//...
					if (testscore > 60)
					{
						print("Okay");
					}]]>
				</c>
				<p>Note that <c>if</c> is in lowercase letters. Uppercase letters (<c>If</c> or <c>IF</c>) will generate a Goat error.</p>
			</s>
			<s name="The 'else' statement">
				<p>Use the <c>else</c> statement to specify a block of code to be executed if the condition is false. Syntax:</p>
				<c><![CDATA[
					if (condition)
					{
						block of code to be executed if the condition is true
					}
					else
					{
						block of code to be executed if the condition is false
					}]]>
				</c>
				<p>Example (outputs <c>"Excellent result"</c>):</p>
				<c><![CDATA[
					var testscore = 95;
					//...
					if (testscore < 90)
					{
						print("Okay");
					}
					else
					{
						print("Excellent result");
					}]]>
				</c>
			</s>
			<s name="The 'else if' statement">
				<p>Use the <c>else if</c> statement to specify a new condition if the first condition is false. Syntax:</p>
				<c><![CDATA[
					if (condition1)
					{
						block of code to be executed if condition1 is true
					}
					else if (condition2)
					{
						block of code to be executed if the condition1 is false and condition2 is true
					}
					else
					{
						block of code to be executed if the condition1 is false and condition2 is false
					}]]>
				</c>
				<p>Example:</p>
				<c><![CDATA[
					if (testscore < 50)
					{
						print("Bad result");
					}
					else if (testscore < 90)
					{
						print("Okay");
					}
					else
					{
						print("Excellent result");
					}]]>
				</c>
			</s>
			<s name="Single statements instead of blocks">
				<p>If a block contains only one statement, you can use this statement without parentheses. The previous example, but with single statements instead of blocks:</p>
				<c><![CDATA[
					if (testscore < 50)
						print("Bad result");
					else if (testscore < 90)
						print("Okay");
					else
						print("Excellent result");]]>
				</c>
				<p>It's a little shorter, isn't it? You can even write the whole 'if' statement to one line:</p>
				<c>if (obj == null) return;</c>
				<p>It's the same to:</p>
				<c><![CDATA[
					if (obj == null)
						return;]]>
				</c>
				<p>Or</p>
				<c><![CDATA[
					if (obj == null)
					{
						return;
					}]]>
				</c>
				<p>Of course, the same rules apply to other constructions described below.</p>
			</s>
		</s>
		<s name="Switch statement">
			<p>The switch statement is used to perform different actions based on different conditions. Use the switch statement to select one of many blocks of code to be executed.</p>
			<s name="Syntax">
				<c><![CDATA[
					switch(expression)
					{
						case n:
							code block
							break;
						case n:
							code block
							break;
						default:
							code block
					}]]>
				</c>
				<p>This is how it works:</p>
				<l>
					<i>The switch expression is evaluated once.</i>
					<i>The value of the expression is compared with the values of each case.</i>
					<i>If there is a match, the associated block of code is executed.</i>
				</l>
				<p>Example. This function converts weekday (as a number between 0 and 6) to a string:</p>
				<c><![CDATA[
					var weekday = function(number)
					{
						var day;
						switch (number)
						{
							case 0:
								day = "Sunday";
								break;
							case 1:
								day = "Monday";
								break;
							case 2:
								day = "Tuesday";
								break;
							case 3:
								day = "Wednesday";
								break;
							case 4:
								day = "Thursday";
								break;
							case 5:
								day = "Friday";
								break;
							case 6:
								day = "Saturday";
						}
						return day;
					}; ]]>
				</c>
			</s>
			<s name="The 'break' keyword">
				<p>When Goat reaches a <c>break</c> keyword, it breaks out of the switch block. This will stop the execution of more code and case testing inside the block. When a match is found, and the job is done, it's time for a break. There is no need for more testing.</p>
				<p>It is not necessary to break the last case in a switch block. The block breaks (ends) there anyway.</p>
			</s>
			<s name="The 'default' keyword">
				<p>The <c>default</c> keyword specifies the code to run if there is no case match.</p>
				<p>Example. This function converts weekday (as a number between 0 and 6) to a string, but if weekday is neither Saturday (6) nor Sunday (0), returns a default message:</p>
				<c><![CDATA[
					var weekday = function(number)
					{
						var day;
						switch (number)
						{
							case 0:
								day = "Sunday";
								break;
							case 6:
								day = "Saturday";
								break;
							default:
								day = "Working day";
						}
						return day;
					}; ]]>
				</c>
				<p>The default case (if exists) should be the last case in a switch block.</p>
			</s>
			<s name="Common code blocks">
				<p>Sometimes you will want different switch cases to use the same code:</p>
				<c><![CDATA[
					var weekday = function(number)
					{
						var day;
						switch (number)
						{
							case 0:
								day = "Sunday";
								break;
							case 6:
								day = "Saturday";
								break;
							case 4:
							case 5:
								day = "Soon it is Weekend";
								break;
							default:
								day = "Working day";
						}
						return day;
					}; ]]>
				</c>
			</s>
		</s>
		<s name="Loops">
			<s name="What is loops">
				<p>Loops can execute a block of code a number of times.</p>
				<p>Loops are handy, if you want to run the same code over and over again, each time with a different value. Often this is the case when working with arrays.</p>
				<p>For example, we have an array:</p>
				<c>var herd = ["Dirty", "Stinky", "Crazy", "Nasty", "Dumb", "Dumber"];</c>
				<p>Instead of writing:</p>
				<c><![CDATA[
					print(herd[0] + "\n");
					print(herd[1] + "\n");
					print(herd[2] + "\n");
					print(herd[3] + "\n");
					print(herd[4] + "\n");
					print(herd[5] + "\n");]]>
				</c>
				<p>You can write:</p>
				<c><![CDATA[
					var i, l = herd.length();
					for (i = 0; i < l; i++)
					{
						print(herd[i] + "\n");
					}]]>
				</c>
			</s>
			<s name="Different kinds of loops">
				<p>Goat supports different kinds of loops:</p>
				<l>
					<i><c>for</c> - loops through a block of code a number of times;</i>
					<i><c>for..in</c> - loops through the properties of an object;</i>
					<i><c>while</c> - loops through a block of code while a specified condition is true;</i>
					<i><c>do..while</c> - also loops through a block of code while a specified condition is true.</i>
				</l>
			</s>
			<s name="The 'for' loop">
				<p>The <c>for</c> loop is often the tool you will use when you want to create a loop. The <c>for</c> loop has the following syntax:</p>
				<c><![CDATA[
					for (statement 1; statement 2; statement 3)
					{
						code block to be executed
					}]]>
				</c>
				<p><b>Statement 1</b> is executed before the loop (the code block) starts.</p>
				<p><b>Statement 2</b> defines the condition for running the loop (the code block).</p>
				<p><b>Statement 3</b> is executed each time after the loop (the code block) has been executed.</p>
				<p>Example (outputs <c>"0123456789"</c>):</p>
				<c><![CDATA[
					var i;
					for (i = 0; i < 10; i++)
					{
						print(i);
					}]]>
				</c>
				<p>From the example above, you can read:</p>
				<p>Statement 1 sets a variable before the loop starts (<c>i = 0</c>).</p>
				<p>Statement 2 defines the condition for the loop to run (<c>i</c> must be less than 10).</p>
				<p>Statement 3 increases a value (<c>i++</c>) each time the code block in the loop has been executed.</p>
				<s name="Statement 1">
					<p>Normally you will use statement 1 to initialize the variable used in the loop (<c>i = 0</c>). This is not always the case, Goat doesn't care. Statement 1 is optional. You can omit statement 1 (like when your values are set before the loop starts):</p>
					<c><![CDATA[
						var i = 0;
						for (; i < 10; i++)
						{
							print(i);
						}]]>
					</c>
					<p>Also, you can declare a variable in statement 1 using <c>var</c> keyword:</p>
					<c><![CDATA[
						for (var i = 0; i < 10; i++)
						{
							print(i);
						}]]>
					</c>
					<p>This variable will be visible only inside the 'for' loop.</p>
				</s>
				<s name="Statement 2">
					<p>Often statement 2 is used to evaluate the condition of the initial variable. This is not always the case, Goat doesn't care. Statement 2 is also optional. If statement 2 returns <c>true</c>, the loop will start over again, if it returns <c>false</c>, the loop will end.</p>
					<p>If you omit statement 2, you must provide a <c>break</c> or a <c>return</c> inside the loop. Otherwise the loop will never end.</p>
				</s>
				<s name="Statement 3">
					<p>Often statement 3 increments the value of the initial variable. This is not always the case, Goat doesn't care, and statement 3 is optional. Statement 3 can do anything like negative increment (<c>i--</c>), positive increment (<c>i = i + 15</c>), or anything else. Statement 3 can also be omitted (like when you increment your values inside the loop):</p>
					<c><![CDATA[
						for (i = 0; i < 10; )
						{
							print(i);
							i++;
						}]]>
					</c>
				</s>
			</s>
			<s name="The 'for..in' loop">
				<p>The Goat <c>for..in</c> statement loops through the properties of an object:</p>
				<c><![CDATA[
					var person = {name: "Ivan", age: 33, gender: "male"};
					var x;
					for (x in person)
					{
						print(x + ": " + person[x] + "\n");
					}]]>
				</c>
				<p>Output:</p>
				<c><![CDATA[
					name: Ivan
					age: 33
					genger: male]]>
				</c>
				<p>Note that objects store unordered pairs <c>key:value</c>. The order of traversal of object properties may not match with the order of the properties at object creation. In the example above, the output can be:</p>
				<c><![CDATA[
					age: 33
					name: Ivan
					genger: male]]>
				</c>
			</s>
			<s name="The 'while' loop">
				<p>The <c>while</c> loop loops through a block of code as long as a specified condition is <c>true</c>. Syntax:</p>
				<c><![CDATA[
					while (condition)
					{
						code block to be executed
					}]]>
				</c>
				<p>Example  (outputs <c>"0123456789"</c>):</p>
				<c><![CDATA[
					var i = 0;
					while (i < 10)
					{
						print(i);
						i++;
					}]]>
				</c>
				<p>Note: if you forget to increase the variable used in the condition, the loop will never end.</p>
			</s>
			<s name="The 'do..while' loop">
				<p>The <c>do..while</c> loop is a variant of the while loop. This loop will execute the code block once, before checking if the condition is <c>true</c>, then it will repeat the loop as long as the condition is <c>true</c>. Syntax:</p>
				<c><![CDATA[
					do 
					{
						code block to be executed
					}
					while (condition);]]>
				</c>
				<p>Example. The loop will always be executed at least once, even if the condition is <c>false</c>, because the code block is executed before the condition is tested:</p>
				<c><![CDATA[
					var i = 0;
					do 
					{
						print(i);
						i++;
					} while (i < 10);]]>
				</c>
			</s>
			<s name="The 'break' statement">
				<p>You have already seen the <c>break</c> statement used in an earlier chapter of this tutorial. It was used to "jump out" of a <c>switch</c> statement. The <c>break</c> statement can also be used to "jump out" of a loop. The <c>break</c> statement breaks the loop and continues executing the code after the loop (if any):</p>
				<c><![CDATA[
					var i;
					for (i = 0; i < 10; i++)
					{
						if (i == 6)
							break;
						print(i);
					}]]>
				</c>
				<p>Output: <c>012345</c>.</p>
			</s>
			<s name="The 'continue' statement">
				<p>The <c>continue</c> statement breaks one iteration (in the loop), if a specified condition occurs, and continues with the next iteration in the loop.</p>
				<p>This example skips the value of 3:</p>
				<c><![CDATA[
					var i;
					for (i = 0; i < 10; i++)
					{
						if (i == 3)
							continue;
						print(i);
					}]]>
				</c>
				<p>Output: <c>012456789</c>.</p>
			</s>
		</s>
		<s name="Exceptions">
			<s name="Errors will happen!">
				<p>When executing Goat code, different errors can occur. For example, division by zero:</p>
				<c>print(1 / 0); // oops</c>
			</s>
			<p>The <c>try</c> statement lets you test a block of code for errors.</p>
			<p>The <c>catch</c> statement lets you handle the error.</p>
			<p>The <c>throw</c> statement lets you create custom errors.</p>
			<p>The <c>finally</c> statement lets you execute code, after try and catch, regardless of the result.</p>
			<s name="Try and catch">
				<p>The <c>try</c> statement allows you to define a block of code to be tested for errors while it is being executed.</p>
				<p>The <c>catch</c> statement allows you to define a block of code to be executed, if an error occurs in the try block.</p>
				<p>The Goat statements <c>try</c> and <c>catch</c> come in pairs:</p>
				<c><![CDATA[
					try 
					{
						Block of code to try
					}
					catch(err) 
					{
						Block of code to handle errors
					}]]>
				</c>
				<p>Example:</p>
				<c><![CDATA[
					try 
					{
						print(4 / 4);
						print(4 / 2);
						print(4 / 1);
						print(4 / 0);
					}
					catch(err)
					{
						print("Error");
					}]]>
				</c>
				<p>Output:</p>
				<c>124Error</c>
				<p>When an error occurs, Goat will normally stop and generate an error object. The technical term for this is: Goat will <b>throw an exception</b> (throw an error).</p>
			</s>
			<s name="The 'throw' statement">
				<p>The <c>throw</c> statement allows you to create a custom error.</p>
				<p>Technically you can <b>throw an exception</b> (throw an error). The exception can be any object:</p>
				<c>throw "Oops!"; // throw a string</c>
				<p>The thrown object passes as parameter of the <c>catch</c> statement.</p>
				<p>If you use <c>throw</c> together with <c>try</c> and <c>catch</c>, you can control program flow and generate custom error messages.</p>
				<c><![CDATA[
					var kelvin2Celsius = function(value)
					{
						if (value < 0)
							throw "Wrong parameter: " + value;
						
						return value -273.15;
					};
					
					try 
					{
						print("\n" + kelvin2Celsius(300));
						print("\n" + kelvin2Celsius(0));
						print("\n" + kelvin2Celsius(-10));
					}
					catch(err)
					{
						print("\n" + err);
					}]]>
				</c>
				<p>Output:</p>
				<c><![CDATA[
					26.85
					-273.15
					Wrong parameter: -10]]>
				</c>
			</s>
			<s name="The 'finally' statement">
				<p>The finally statement lets you execute code, after try and catch, regardless of the result:</p>
				<c><![CDATA[
					try
					{
						Block of code to try
					}
					catch(err)
					{
						Block of code to handle errors
					} 
					finally
					{
						Block of code to be executed regardless of the try / catch result
					}]]>
				</c>
			</s>
			<s name="The error object">
				<p>The exception can be any object. For some situations, the interpreter throws predefined exception objects, such as:</p>
				<t>
					<h>
						<c>Exception</c>
						<c>Situation</c>
					</h>
					<r>
						<c><c>NameIsNotDefined</c></c>
						<c>Attempt to call a function with an undefined name. For example, <c>Print</c> (first capital letter) instead of <c>print</c></c>
					</r>
					<r>
						<c><c>IsNotAFunction</c></c>
						<c>Attempt to call a function: name is defined, but it is not a function.<c>var f = 0; f();</c></c>
					</r>
					<r>
						<c><c>OperatorIsNotDefined</c></c>
						<c>Attempt to use an operator that is not applicable to this data type. For example, you can not multiply strings: <c>"hello" * "world"</c></c>
					</r>
					<r>
						<c><c>DivisionByZero</c></c>
						<c>Division by zero, <c>print(1 / 0);</c></c>
					</r>
					<r>
						<c><c>IncorrectIndex</c></c>
						<c>Index of an array is not an integer, <c>var a = [0, 13, 666]; print(a["0"]);</c></c>
					</r>
					<r>
						<c><c>OutOfBounds</c></c>
						<c>Index of an array is too big , <c>var a = [0, 13, 666]; print(a[10]);</c></c>
					</r>
					<r>
						<c><c>IllegalArgument</c></c>
						<c>Wrong argument of a function or an operator</c>
					</r>
				</t>
				<p>Each object (include error objects) has the <c>instanceof</c> method. You can use this method to determine the type of exception:</p>
				<c><![CDATA[
					try 
					{
						// do something
					}
					catch(err)
					{
						if (err.instanceof(Exception.OutOfBounds))
						{
							// do domething if out of bounds
						}
					}]]>
				</c>
			</s>
		</s>
		<s name="Import">
			<s name="Overview">
			<p>Sometimes the program becomes so large that it is more reasonable to separate it into several files. In addition, you can use pre-designed libraries - say, to recognize XML files. Goat provides a way to include files to a program using an <c>import</c> keyword.</p>
			<c><![CDATA[
				import "xml.goat";
				
				// now, you can use functions from XML library:
				var root = Xml.parse("<root></root>");]]>
			</c>
			<p>No file will be imported twice. For example, your program uses library <c>A</c> and library <c>B</c>. But library <c>B</c> uses (imports) library <c>A</c> also. So, library <c>A</c> will be imported only once, for all project.</p>
			<p>Where the interpreter finds files to import? </p>
			<l>
				<i>first, in the current folder, where was started Goat script;</i>
				<i>second, in the list of folders specified in the <c>--lib</c> option of the interpreter.</i>
			</l>
			</s>
			<s name="--lib option">
				<p>Path (paths) to importable files. For example, folder <c>c:\goat\lib</c> contains Goat standard library; so, to use it, launch the interpreter with <c>--lib</c> option:</p>
				<c>goat.exe program.goat --lib=c:\goat\lib</c>
				<p>Several paths can be separated by a semicolon. The interpreter for each imported file first searches the first path in the list, then the second one, and so on.</p>
			</s>
		</s>
		<s name="Debugging">
			<s name="Interactive mode">
				<p>Goat has two basic modes: script and interactive. The normal mode is the mode where the scripted and finished files are run in the Goat interpreter. Interactive mode is a command line shell which gives immediate feedback for each statement while running previously fed statements in active memory. As new lines are fed into the interpreter, the fed program is evaluated both in part and in whole.</p>
				<p>To start interactive mode, launch the Goat interpreter without script file (in common cases without any parameters):</p>
				<c>goat.exe</c>
				<p>Will open a console:</p>
				<c>?</c>
				<p>Enter any correct statement and press Enter:</p>
				<c><![CDATA[
					? var i = 0;
					
					?]]>
				</c>
				<p>In the example above, the interpreter will create a variable <c>i</c> and wait for the new statement to be entered. So, now you can print the value of the variable:</p>
				<c><![CDATA[
					? print(i);
					0
					?]]>
				</c>
				<p>You can use any statements you want:</p>
				<c><![CDATA[
					? for (var k = 0; k < 10; k++) print(k);
					0123456789
					?]]>
				</c>
				<p>If statement takes more than one line, add a backslash to go a new line:</p>
				<c><![CDATA[
					? for (var k = 0; k < 10; k++) \
					{ \
						if (k == 3) continue; \
						print(k); \
					}
					012456789
					?]]>
				</c>
				<p>The values of all variables are saved:</p>
				<c><![CDATA[
					? var obj = {};
					
					? obj.field = 1;
					
					? print(obj);
					{field:1};
					?]]>
				</c>
				<p>The special statement <c>exit</c> exits interactive mode.</p>
				<c>exit</c>
			</s>
			<s name="Step-by-step debugging" anchor="Step-by-step debugging">
				<s name="The 'debug' keyword">
					<p><d>The <c>debug</c> keyword stops the execution of Goat, and switch the interpreter to step-by-step mode. If no debugging is available, the <c>debug</c> statement has no effect.</d></p>
					<c><![CDATA[
						var i, j;
						for (i = 0; i < 10; i++)
						{
							debug;
							j = i * i;
							print("" + j + "\n");
						}]]>
					</c>
					<p>Then launch the interpreter with <c>--debug</c> option:</p>
					<c>goat.exe program.goat --debug</c>
					<p>The program will start and then stop on <c>debug</c> keyword:</p>
					<c><![CDATA[
						> program.goat, 3.7: debug;
						[step] ?]]>
					</c>
				</s>
				<s name="Step-by-step dialog">
					<p>After stop (and each step) the interpreter outputs step-by-step dialog and wait for a command:</p>
					<c><![CDATA[
						> program.goat, 4.9: j = i * i;
						[step] ?]]>
					</c>
					<p>In the example above, the individual elements of the dialog have the following meanings:</p>
					<t>
						<h>
							<c>Element</c>
							<c>Description</c>
						</h>
						<r>
							<c><c>program.goat</c></c>
							<c>Filename of the current script</c>
						</r>
						<r>
							<c><c>4.9</c></c>
							<c>Current line (4) and symbol in line (9)</c>
						</r>
						<r>
							<c><c>j = i * i;</c></c>
							<c>The expression that will now be executed</c>
						</r>
						<r>
							<c><c>[step]</c></c>
							<c>Command by default</c>
						</r>
						<r>
							<c><c>?</c></c>
							<c>Prompt to enter a command</c>
						</r>
					</t>
					<p>You can enter the following commands:</p>
					<t>
						<h>
							<c>Short command</c>
							<c>Full command</c>
							<c>Description</c>
						</h>
						<r>
							<c><c>c</c></c>
							<c><c>continue</c></c>
							<c>Continue until the next stop on <c>debug</c> statement.</c>
						</r>
						<r>
							<c><c>s</c></c>
							<c><c>step</c></c>
							<c>Next step (over). If this step is a function call, then the function is executed entirely.</c>
						</r>
						<r>
							<c><c>i</c></c>
							<c><c>into</c></c>
							<c>Next step (into). If the next step is a function call, the interpreter "enters inside" the function and then stops at the first statement of the function.</c>
						</r>
						<r>
							<c><c>o</c></c>
							<c><c>out</c></c>
							<c>Next step (out). The interpreter executes the current function to the end and stops at the first statement after calling this function.</c>
						</r>
						<r>
							<c/>
							<c><c>$var_name</c></c>
							<c>Prints the contents of a variable <c>var_name</c>.</c>
						</r>
					</t>
					<p>If you press <c>Enter</c> without entering any command, the default command (in square brackets) will be executed. Typically, the default command is the last command executed.</p>
				</s>
			</s>
		</s>
	</s>
	
	<s name="Advanced programming">
		<p>Forget everything you learned in school.</p>
		<s name="The new look at objects">
			<s name="Keys and values">
				<p>Objects are containers for pairs <c>key:value</c>:</p>
				<c>var person = { firstName : "Scott", lastName : "Cameron", age : 45 };</c>
				<p>The <c>key:value</c> pairs (in Goat objects) are called <b>properties.</b></p>
				<p>Values can be any objects: strings, numbers etc. What about keys? In the example above, keys are identifiers (such as names of variables).In common cases, using identifiers as keys is enough: it is convenient. You always can to add a new property using the dot operator <c>.</c>:</p>
				<c>person.profession = "Programmer";</c>
				<p>But, keys can be not only identifiers. You can use any object as a key. For example, integers:</p>
				<c>person[3] = "value";</c>
				<p>...or booleans:</p>
				<c>person[true] = false;</c>
				<p>...and, of course, strings:</p>
				<c>person["profession"] = "Programmer";</c>
				<p>If you use a string as a key, and this string can be an identifier (the first character must be a letter or an underscore (<c>_</c>), subsequent characters may be letters, digits or underscores), Goat transforms this string to an identifier. Later you can access to this field using identifier:</p>
				<c><![CDATA[
					person["weight"] = 80;
					//...
					print(person.weight); // output: 80]]>
				</c>
				<p>And vice versa, any property declared using an identifier, can be accessed using a string:</p>
				<c><![CDATA[
					person.weight = 80;
					//...
					print(person["weight"]); // output: 80]]>
				</c>
				<p>So, objects are containers for pairs <c>key:value</c>, where the key can be an identifier or any object, and the value can be any object. However, the Goat program works a little faster if you use identifiers as keys, so this is the preferred method.</p>
			</s>
			<s name="Each object has some predefined methods">
				<p>Goat adds these methods to each object.</p>
				<m name="instanceof" descr="Returns whether an object is derived from another object or not.">
					<a name="object" type="any type" descr="the prototype"/>
					<e><![CDATA[
						var isInteger = $(obj)
						{
							return obj.instanceof(Integer);
						};]]>
					</e>
					<n>The method is used to determine the type (more correctly, the prototype) of the object. What is a prototype, will be described a little later.</n>
				</m>
				<m name="clone" descr="Returns a clone of the object, that is, a new object in which all properties are the same as in the source object.">
					<e><![CDATA[
						var a = { name: "Ivan", age: 33 };
						var b = a.clone();
						b.name = "Jonh";
						print(b); // output: {name:"John",age:33}
						print(a); // output: {name:"Ivan",age:33} ]]>
					</e>
					<n>This is required if you need to get a real copy of the object, then change it and leave the original object unchanged.</n>
				</m>
				<m name="flat" descr="Returns a flat object, that is, an object that contains all the properties of the source object, as well as all properties of all prototypes of the source object. What is a prototype, will be described a little later."/>
			</s>
			<s name="Everything is an object">
				<p>All data (strings, numbers, booleans) represented as objects. These are "special" objects that have special behavior. But beyond this, these objects do everything the same as other, "ordinary" objects.</p>
				<p>For example, you can add a property for a string:</p>
				<c><![CDATA[
					var str = "hello!";
					str.somePropertyName = 123;]]>
				</c>
				<p>...or add some method to an integer:</p>
				<c><![CDATA[
					var n = 123;
					n.increment = $()
					{
						return this + 1;
					}; ]]>
				</c>
				<p>As each object has some predefined methods, strings, booleans, integers, and others also have all these methods:</p>
				<c><![CDATA[
					var str = "hello!";
					print(str.instanceof(String)); // output: true
					
					var num = 10;
					print(num.instanceof(Boolean)); // ounput: false]]>
				</c>
			</s>
		</s>
		<s name="Methods">
			<s name="Difference between method and function">
				<p>A <b>method</b> in object-oriented programming is a function associated with an object.</p>
				<p>In other words, functions work only with parameters, but methods also "see" all the properties (fields and other methods) of own object and can modify these.</p>
				<p>Example. Declare an object <c>obj</c> that contains one field <c>x</c> and one method <c>getX</c>. The method can access the field:</p>
				<c><![CDATA[
					var obj = 
					{
						x: 10;
						
						getX : $()
						{
							return x;
						}
					};
					
					var n = obj.getX(); // 10]]>
				</c>
			</s>
			<s name="Search order">
				<p>Since a property (or variable) with the same name can be defined in many places, the programming language specifies a clear order of searching for the value by name.</p>
				<p>Suppose we want to read a variable named <c>x</c>. The highest priority has local variables:</p>
				<c><![CDATA[
					var obj = 
					{
						x: 10; // property 'x'
						
						getX : $() 
						{
							var x = 2 + 3; // local variable 'x'
							return x;
						}
					};
					
					var n = obj.getX(); // 5 ]]>
				</c>
				<p>If a local variable with this name is not found, the Goat programming language tries to find this name in the list of arguments of the method:</p>
				<c><![CDATA[
					var obj = 
					{
						x: 10; // property 'x'
						
						getX : $(x) // method with argument named 'x'
						{ 
							return x;
						}
					};
					
					var n = obj.getX(7); // 7 ]]>
				</c>
				<p>Then the search is performed in the object properties:</p>
				<c><![CDATA[
					var x = 777; // external variable 'x'
					
					var obj = {
						x: 10; // property 'x'
						
						getX : $()
						{
							return x;
						}
					};
					
					var n = obj.getX(); // 10 ]]>
				</c>
				<p>The last thing to do is look for variables outside the object:</p>
				<c><![CDATA[
					var x = 777; // external variable 'x'
					
					var obj = 
					{
						getX : $() 
						{
							return x;
						}
					};
					
					var n = obj.getX(); // 777 ]]>
				</c>
			</s>
			<s name="The 'this' keyword">
				<p>When a method is called, a special variable named <c>this</c> is always defined. This variable refers to the object whose method was called. You can not overwrite the value of this variable. This variable is used to explicitly access the properties of the "own" object.</p>
				<c><![CDATA[
					var obj = 
					{
						x: 10; // property 'x'
						
						getX : $() 
						{
							return this.x;
						}
					};
					
					var n = obj.getX(); // 10 ]]>
				</c>
				<p>In fact, the example above is completely analogous to this example:</p>
				<c><![CDATA[
					var obj = {
						x: 10; // property 'x'
						
						getX : $() 
						{
							return x; // without 'this' keyword
						}
					};
					
					var n = obj.getX(); // 10 ]]>
				</c>
				<p>That is, in most cases, we can do without using <c>this</c> keyword. But in some cases, <c>this</c> keyword cannot be avoided. For example, if you already have a local variable or an argument with that name, but you want to explicit read or write the property of the object:</p>
				<c><![CDATA[
					var obj = {
						x: 10; // property 'x'
						
						getX : $() 
						{
							return x;
						}
						
						setX " $(x)
						{
							this.x = x; // read the argument 'x' and write the property 'x' 
						}
					};
					
					obj.setX(777);
					var n = obj.getX(); // 777 ]]>
				</c>
				<p>Or, you can add new properties to own object (which are not yet there):</p>
				<c><![CDATA[
					var obj = 
					{
						x: 10; // property 'x'
						
						init : $() // constructor
						{ 
							this.y = 20; // add a new property 'y'
						}
					};]]>
				</c>
			</s>
		</s>
		<s name="Prototypes">
			<s name="Prototype and inheritance">
				<p>Goat is prototype-oriented language. What is "prototype" means?</p>
				<p>A <b>prototype</b> is an object from which other objects <b>inherit</b> properties and methods. Any object can be a prototype for another object.</p>
				<p><b>Inheritance</b> is when an object is based on another object using the same implementation.</p>
				<p>How does it work? When accessing an object (method call or field reading), the Goat programming language first looks for this property in the object itself. If Goat does not find it, tries to look for this property in the prototype object. If still not found, then Goat is searching in a prototype of the prototype, and so on.</p>
				<c><![CDATA[
					// declare an object:
					var parent = { x: 1 };
					
					// inherit another object:
					var child = parent -> { y: 2, z: 3 }; 
					
					// now you have access to properties in the parent object:
					print(child.x); // output: 1]]>
				</c>
				<pic title="Multiple inheritance">graph/inheritance.svg</pic>
			</s>
			<s name="Operator -&gt;">
				<p>Operator <c>-&gt;</c> builds a new object from the <b>prototype</b> and <b>description:</b></p>
				<c>var obj = prototype -&gt; description;</c>
				<p>A <b>prototype</b> is any object from which properties (fields and methods) will be used if properties with such names are not found in the child object.</p>
				<p>A <b>description</b> is an object that will be cloned before a prototype is attached to it. The description thus <b>extends</b> the prototype, and as a result, a new object is created that contains both its own properties and the properties of all its parents.</p>
				<p>Example:</p>
				<c><![CDATA[
					// declare an object:
					var A = { x: 1 };
					
					// inherit:
					var B = A -> { y: 2, z: 3 }; // 'B' contains 'x', 'y' and 'z' ]]>
				</c>
				<p>Of course, you can declare a description elsewhere:</p>
				<c><![CDATA[
					// declare an object:
					var A = { x: 1 };
					
					// declare a description:
					var D = { y: 2, z: 3 };
					
					// inherit:
					var B = A -> D; // 'B' still contains 'x', 'y' and 'z' ]]>
				</c>
			</s>
			<s name="Prototype сhain">
				<p>If you created a new object using an operator <c>-&gt;</c>, then this object, in turn, can also be a prototype of some other object:</p>
				<c><![CDATA[
					// declare an object:
					var A = { x: 1 };
					
					// inherit first time:
					var B = A -> { y: 2 }; // 'B' contains 'x' and 'y' 
					
					// inherit second time:
					var C = B -> { z: 3 }; // 'C' contains 'x', 'y' and 'z' ]]>
				</c>
				<p>The Goat programming language looks for the property by its name along the whole prototype chain, from last to first prototype. For example,</p>
				<c>print(C.x);</c>
				<p>The order of search is:</p>
				<l>
					<i>first, a property named <c>x</c> will be searched in the <c>C</c> object and will not be found;</i>
					<i>second, a property will be searched in the <c>B</c> object and will not be found;</i>
					<i>finally, a property will be searched in the <c>A</c> object and will be found.</i>
				</l>
				<p>Another example, attempt to read an undefined property:</p>
				<c>print(C.w);</c>
				<p>In this case, the Goat programming language will scan the whole prototype chain (first <c>C</c>, then <c>B</c>, then <c>A</c>), but will not find the properties and return <c>undefined</c> result.</p>
			</s>
			<s name="Changing the prototype">
				<p>You can not change the prototype of the object. Instead, you can change properties of the prototype itself. In this case, these properties will immediately change in all children:</p>
				<c><![CDATA[
					// declare an object:
					var A = { x: 1 };
					
					// inherit:
					var B = A -> { y: 2, z: 3 }; 
					
					// read the value of 'x' property (of the child object):
					print(B.x); // output: 1
					
					// change the value of 'x' property (in the parent object):
					A.x = 777;
					
					// read the value of 'x' property again:
					print(B.x); // output: 777]]>
				</c>
			</s>
			<s name="The 'new' operator">
				<p>The <c>new</c> operator creates a new object from the prototype and then calls a special method - constructor to initialize the object.</p>
				<c><![CDATA[
					// declare the class:
					var Vector = { 
						x : 0,
						y : 0
					};
					
					// create the object using the 'new' operator
					var v = new Vector();]]>
				</c>
				<p>In the simplest case, as in the example above, this operation is completely analogous to the inheritance from the prototype:</p>
				<c>var v = Vector -&gt; { };</c>
				<p>But, in addition to inheritance, the <c>new</c> operator calls a chain of constructors.</p>
				<s name="Constructor">
					<p>A constructor is a method named <c>init</c>.</p>
					<c><![CDATA[
						// declare the class:
						var Vector = 
						{ 
							init : $() 
							{
								this.x = 0;
								this.y = 0;
							}
						};
						
						// create the object using the 'new' operator
						var v = new Vector();]]>
					</c>
					<p>Output:</p>
					<c>{x:0,y:0}</c>
					<p>Note that in the first example (without the constructor), the <c>x</c> and <c>y</c> variables  do not belong to the new object, but to the prototype. In the new example, the variables are created each time the object is created by the <c>new</c> operator, and these variables belong to the object.</p>
					<p>Where can this be useful? This is necessary in cases where each object must have its own independent data set.</p>
					<p>Let's consider another example. Say there is some "Dictionary" class that stores values in an associative array:</p>
					<c><![CDATA[
						var Dictionary = 
						{ 
							data : {},
							
							add : $(english, french) 
							{
								data[english] = french;
							}
						};
						
						// create the first dictionary
						var d1 = new Dictionary();
						d1.add("red", "rouge");
						d1.add("green", "vert");
						
						// create the second dicrionary
						var d2 = new Dictionary();
						d2.add("blue", "bleu");
						d2.add("black", "noir");
						
						// read the data from the first dictionary:
						print(d1.data);]]>
					</c>
					<p>Will this work? No. The output is:</p>
					<c>{"red":"rouge","green":"vert","blue":"bleu","black":"noir"}</c>
					<p>The resulting object contains data from both the first and second dictionary. Why? Because the <c>d.data</c> object  does not belong to <c>d1</c> object, but belongs to its prototype, that is, both objects <c>d1</c> and <c>d2</c> have access to it. But this is wrong. Each dictionary instance must have its own object for data storage. You can create this object in the constructor:</p>
					<c><![CDATA[
						var Dictionary = 
						{ 
							init : $() 
							{
								this.data = {};
							},
							
							add : $(english, french) 
							{
								data[english] = french;
							}
						};
						
						// create the first dictionary
						var d1 = new Dictionary();
						d1.add("red", "rouge");
						d1.add("green", "vert");
						
						// create the second dicrionary
						var d2 = new Dictionary();
						d2.add("blue", "bleu");
						d2.add("black", "noir");
						
						// read the data from the first dictionary:
						print(d1.data);]]>
					</c>
					<p>Now it's right:</p>
					<c>{"red":"rouge","green":"vert"}</c>
					<p>So, constructors are needed to initialize objects, so that each instance of a class, created using the <c>new</c> operator, contains its unique data.</p>
				</s>
				<s name="Constructor with parameters">
					<p>An <c>init</c> method can have parameters that are passed to it as arguments of the <c>new</c> operator:</p>
					<c><![CDATA[
						var Vector = 
						{
							init : $(x, y) 
							{
								this.x = x;
								this.y = y;
							}
						};

						var v = new Vector(10, 20);

						print(v);
						]]>
					</c>
					<p>Output:</p>
					<c>{x:10,y:20}</c>
					<p>So, the parameterized constructor allows initializing an object using the data passed as parameters.</p>
				</s>
				<s name="Constructors chain">
					<p>Consider a chain of prototypes, with each prototype containing an <c>init</c> method:</p>
					<c><![CDATA[
						var A = 
						{
							init : $() 
							{
								this.x = 1;
							}
						};

						var B = A -> 
						{
							init : $() 
							{
								this.y = 2;
							}
						};

						var C = B -> 
						{
							init : $() 
							{
								this.z = 3;
							}
						};

						var obj = new C();

						print(obj);]]>
					</c>
					<p>Output:</p>
					<c>{x:1,y:2,z:3}</c>
					<p>As you can see, all three constructors were called, because the resulting object contains all three variables.</p>
					<p>How it works. If the prototype chain contains prototypes that have an <c>init</c> method, then the <c>new</c>operator calls these methods one by one, starting from the "deepest" prototype.</p>
					<p>In the example above, the <c>init</c> method of object <c>A</c> will be called first, then the <c>init</c> method of object <c>B</c>, then the <c>init</c> method of object <c>C</c>.</p>
					<p>This order of calling constructors allows you to correctly initialize the object. Let's try to change the value of the variable in the last constructor:</p>
					<c><![CDATA[
						var A = 
						{
							init : $() 
							{
								this.x = 1;
							}
						};

						var B = A -> 
						{
							init : $() 
							{
								this.y = 2;
							}
						};

						var C = B -> 
						{
							init : $() 
							{
								x = 7;
								this.z = 3;
							}
						};

						var a = new A();
						var b = new B();
						var c = new C();

						print("" + a + "\n" + b + "\n" + c);
						]]>
					</c>
					<p>Output:</p>
					<c><![CDATA[
						{x:1}
						{x:1,y:2}
						{x:7,y:2,z:3}]]>
					</c>
					<p>You see? Each subsequent constructor in the chain complements the object initialization. During this, of course, the results of the work of the previous constructor can be changed.</p>
				</s>
				<s name="Passing parameters to the constructors chain">
					<p>When passing parameters through the <c>new</c> operator, all parameters are passed only to the first constructor:</p>
					<c><![CDATA[
						var A =
						{
							init : $() 
							{
								this.x = 10;
							}
						};

						var B = A -> 
						{
							init : $(y, z) 
							{
								this.y = y;
								this.z = z;
							}
						};

						var obj = new B(20, 30);

						print(obj);
						]]>
					</c>
					<p>Output:</p>
					<c>{x:10,y:20,z:30}</c>
					<p>All remaining constructors in the chain are called without parameters.</p>
				</s>
			</s>
			<s name="Overriding">
				<p>You can override properties (fields and methods) in children objects.</p>
				<p>Method overriding, in Goat programming language, is a language feature that allows a subobject to provide a specific implementation of a method that is already provided by one of its prototypes. The implementation in the subobject overrides (replaces) the implementation in the prototype by providing a method that has the same name as the method in the prototype. The version of a method that is executed will be determined by the object that is used to invoke it.</p>
				<c><![CDATA[
					// the object with the method which will be overridden:
					var Animal = 
					{
						talk : $() 
						{
							print("This animal can not speak.\n");
						}
					};
					
					// inherit the first object and override the method:
					var Goat = Animal -> 
					{
						talk : $() 
						{
							print("Baa!\n");
						}
					}; 
					
					// inherit the second object and override the method again:
					var Cow = Animal -> 
					{
						talk : $() 
						{
							print("Moo!\n");
						}
					}; 

					// inherit the third object but does not override the method:
					var Fish = Animal -> 
					{
					};
					
					// create three objects and call the methods:
					var g = new Goat();
					var c = new Cow();
					var f = new Fish();
					
					g.talk();
					c.talk();
					f.talk();]]>
				</c>
				<p>Output:</p>
				<c><![CDATA[
					Baa!
					Moo!
					This animal can not speak.]]>
				</c>
				<p>The same rule for fields. Field with the same name as in prototype overrides the previous field:</p>
				<c><![CDATA[
					// the object with the field which will be overridden:
					var Programmer = 
					{
						salary : 1000
					};
					
					// inherit the first object and override the field:
					var Senior = Programmer -> 
					{
						salary : 1500
					}; 
					
					// inherit the second object but does not override the field:
					var UnitTester = Programmer -> 
					{
					};
					
					// create two objects and read the fields:
					var s = new Senior();
					var ut = new UnitTester();
					
					print(s.salary);
					print("\n");
					print(ut.salary);]]>
				</c>
				<p>Output:</p>
				<c><![CDATA[
					1500
					1000]]>
				</c>
			</s>
			<s name="Operator overloading">
				<p>Operators can be redefined. From the point of view of the interpreter, the operator is no different from the usual method. The method that defines the operator has the same name as the operator itself. Let's consider an example:</p>
				<c><![CDATA[
					var Vector = 
					{
						init : $(x, y) 
						{
							this.x = x; this.y = y
						},
						
						toString : $() 
						{
							return "X: " + x + ", Y: " + y;
						},
						
						"+" : $(vec) 
						{
							return new Vector(x + vec.x, y + vec.y);
						},
						
						"*" : $(val) 
						{
							return new Vector(x * val, y * val);
						}
					};

					var v1 = new Vector(100, 200);
					var v2 = new Vector(200, 400);

					var v3 = v1 + v2;
					print(v3.toString() + "\n");

					var v4 = v1 * 5;
					print(v4.toString() + "\n");
					]]>
				</c>
				<p>Output:</p>
				<c><![CDATA[
					X: 300, Y: 600
					X: 500, Y: 1000]]>
				</c>
				<p>In the example above, the class "Vector" is described. A vector is a complex data structure. Vectors can be added, a vector can be multiplied by a number. Therefore, for this structure, two operators are defined: <c>+</c> and <c>*</c>. Each operator returns a new vector as the result of an operation of addition or multiplication.</p>
				<p>How it works. When the interpreter processes a binary operator, it finds the corresponding method at the <b>left</b> operand and calls this method, passing the <b>right</b> operand as the parameter. The result of the operation is the return value of the method. In the case of a unary operator, the method is called without parameters.</p>
				<p>Unary operators: <c>++</c>, <c>--</c>, <c>!</c>, <c>~</c>, <c>+</c>, <c>-</c>, and binary operators <c>+</c>, <c>-</c>, <c>*</c>, <c>/</c>, <c>%</c>, <c>&lt;&lt;</c>, <c>&gt;&gt;</c>, <c>&gt;&gt;&gt;</c>, <c>&amp;</c>, <c>^</c>, <c>|</c>, <c>&lt;</c>, <c>&lt;=</c>, <c>&gt;</c>, <c>&gt;=</c>, <c>&amp;&amp;</c>, <c>||</c> can be overloaded.</p>
				<p>Operators "Assign by" (<c>+=</c>, <c>*=</c>, etc.) can be overloaded also.</p>
			</s>
			<s name="Multiple inheritance">
				<p>Objects in the Goat programming language can have more than one prototype. In this case, the resulting object will contain all the properties and methods of all parents:</p>
				<c><![CDATA[
					var Animal = 
					{
						eat : $() 
						{
							print("'eat' method is called\n");
						}
					};

					var Mammal = Animal -> 
					{
						drinkMilk : $()
						{
							print("'drinkMilk' method is called\n");
						}
					};

					var WingedAnimal = Animal -> 
					{
						flap : $() 
						{
							print("'flap' method is called\n");
						}
					};

					// A bat is a winged mammal
					var Bat = [Mammal, WingedAnimal] -> 
					{
					};

					var bat = new Bat();
					bat.flap();
					bat.drinkMilk();
					bat.eat();]]>
				</c>
				<p>Output:</p>
				<c><![CDATA[
					'flap' method is called
					'drinkMilk' method is called
					'eat' method is called]]>
				</c>
				<p>There is one problem that is called the "diamond problem". Consider this structure of inheritance:</p>
				<c><![CDATA[
					var A = 
					{
						alpha : 1
					};

					var B = A -> 
					{
						beta : 2
					};

					var C = A -> 
					{
						beta : 3
					};

					var D = [B, C] -> 
					{
						gamma : 4
					};

					var d = new D();

					print(d.alpha);
					print(d.beta);
					print(d.gamma);]]>
				</c>
				<p>The <c>D</c> objects inherits from <c>B</c> and <c>D</c>. But both <c>B</c> and <c>C</c> objects have the <c>beta</c> property, in <c>B</c> object the property equals 2, in <c>C</c> object property equals 3. So, what is the value of the <c>d.beta</c> property? 2 or 3? The correct answer is 2.</p>
				<p>The interpreter uses depth search. If he did not find a property in the object, it first explores the properties of the first (left) prototype, and then all the prototypes of this prototype (<c>D-&gt;B-&gt;A</c>). And only then the next chain of prototypes is explored (<c>D-&gt;C-&gt;A</c>).</p>
				<p><b>Be careful with multiple inheritance.</b> Sometimes this type of inheritance is very useful, but misuse can lead to errors.</p>
			</s>
			<s name="The 'instanceof' method">
				<p>The method checks whether there is an object passed as an argument in the prototype chain. This is a way to determine if an object is instantiated from a specific prototype.</p>
				<p>Each object has the <c>instanceof</c> method.</p>
				<p>Consider this code:</p>
				<c><![CDATA[
					var A = { };
					var B = A -> { };
					var C = A -> { };

					var X = new A();
					var Y = new B();
					var Z = new C();]]>
				</c>
				<p>So,</p>
				<l>
					<i><c>X.instanceof(A)</c> returns <c>true</c> because object <c>A</c> is a prototype of object <c>X</c>;</i>
					<i>but <c>X.instanceof(B)</c> and <c>X.instanceof(C)</c> returns <c>false</c> because objects <c>B</c> and <c>C</c> are not prototypes of object <c>X</c>;</i>
					<i><c>Y.instanceof(B)</c> returns <c>true</c> because object <c>B</c> is a prototype of object <c>Y</c>;</i>
					<i><c>Y.instanceof(A)</c> returns <c>true</c> because object <c>A</c> is a prototype of object <c>B</c> and object <c>B</c> is a prototype of object <c>Y</c>;</i>
					<i><c>Y.instanceof(C)</c> returns <c>false</c> because object <c>C</c> is not prototypes of object <c>Y</c>;</i>
					<i><c>Z.instanceof(C)</c> returns <c>true</c> because object <c>C</c> is a prototype of object <c>Z</c>;</i>
					<i><c>Z.instanceof(A)</c> returns <c>true</c> because object <c>A</c> is a prototype of object <c>C</c> and object <c>C</c> is a prototype of object <c>Z</c>;</i>
					<i><c>Z.instanceof(B)</c> returns <c>false</c> because object <c>B</c> is not prototype of object <c>Z</c>.</i>
				</l>
			</s>
			<s name="The 'clone' method">
				<p>Returns a clone of the object, that is, a new object in which all properties are the same as in the source object.</p>
				<p>Each object has the <c>clone</c> method.</p>
				<p>The method creates a new object and then copies all the properties and methods from the original object to the new one. Now, if you change the copy, the original object will remain unchanged:</p>
				<c><![CDATA[
					var original = 
					{
						x : 10,
						y : 20,
						z : 30
					};

					var copy = original.clone();

					copy.y = 100;

					print(original);
					print(copy);]]>
				</c>
				<p>Output:</p>
				<c>{x:10,y:20,z:30}{x:10,y:100,z:30}</c>
				<p><b>If possible, do not use <c>clone</c> method, inherit an object instead!</b> Cloning is a very expensive operation, due to the need to copy each field.</p>
				<p>The <c>clone</c> method is implicitly called in some other operations. For example, operators <c>-&gt;</c> (inherit) and <c>#</c> (write protect, see below) call this method. This method (however, like all the others) can be redefined. And then the operators will call the overridden method.</p>
				<p>For example, you can prevent cloning an object, and instead of a clone, return the object itself:</p>
				<c><![CDATA[
					var original = 
					{
						x : 10,
						y : 20,
						z : 30,
						
						clone : $() 
						{
							return this;
						}
					};

					var copy = original.clone(); // copy is the same object as the original ]]>
				</c>
				
			</s>
			<s name="The 'flat' method">
				<p>Returns a flat object, that is, an object that contains all the properties of the source object, as well as all properties of all prototypes of the source object.</p>
				<p>Each object has the <c>flat</c> method.</p>
				<p>The method creates a new object and then copies all the properties and methods from the original object and from all prototypes of the original object. Thus, a new object has no prototypes but has all data from the original object:</p>
				<c><![CDATA[
					var A = 
					{
						x : 10
					};

					var B = A -> 
					{
						y : 20
					};

					var C = B-> 
					{
						z : 30
					};

					var F = C.flat();

					print(F);]]>
				</c>
				<p>Output:</p>
				<c>{x:10,y:20,z:30}</c>
				<p>The new object is, as it were, "flat", the same as if it were declared thus:</p>
				<c><![CDATA[
					var F = 
					{
						x : 10,
						y : 20,
						z : 30
					};]]>
				</c>
				<p>Note that the copying is done starting from the very "deep" prototype. Thus, if somewhere in the chain of prototypes some property was redefined, then the "flat" object will contain an overridden property:</p>
				<c><![CDATA[
					var A = 
					{
						x : 10
					};

					var B = A -> 
					{
						x : 15, // overrided
						y : 20
					};

					var C = B-> 
					{
						z : 30
					};

					var F = C.flat();

					print(F);]]>
				</c>
				<p>Output:</p>
				<c>{x:15,y:20,z:30}</c>
			</s>
			<s name="Prototypes of built-in types">
				<p>Each object of built-in type (string, integer etc) has own built-in prototype:</p>
				<l>
					<i><c>String</c> is the prototype for strings. Every time you define a string, for example, <c>var s = "hello, world"</c> you create a new object that has the <c>String</c> prototype;</i>
					<i><c>Integer</c> is the prototype for integers;</i>
					<i><c>Real</c> is the prototype for floating-point numbers;</i>
					<i><c>Char</c> is the prototype for characters;</i>
					<i><c>Boolean</c> is the prototype for booleans;</i>
					<i><c>Null</c> is the prototype for <c>null</c> constant;</i>
					<i><c>Array</c> is the prototype for all arrays;</i>
					<i>functions are also objects! Each time you declare a function, for example, <c>var f=$(){ }</c> an object is created, the prototype of which is <c>Function</c>.</i>
				</l>
				<p>Other prototypes of built-in classes are: <c>Thread</c>, <c>Exception</c>, <c>File</c>, <c>StringBuilder</c>, <c>ByteArray</c>.</p>
				<p>Each prototype has, respectively, its properties, methods, and operators. For example, strings have a predefined <c>+</c> operator, which allows to concatenate strings.</p>
				<p>Using a prototype, you can check whether the object is the right data type. Here is an example of a function, at the beginning of which it is checked whether the argument is an integer:</p>
				<c><![CDATA[
					var f = $(value) 
					{
						if (value.instanceof(Integer)) 
						{
							//...
						}
					};]]>
				</c>
			</s>
		</s>
		<s name="All about nothing">
			<p>There are special objects in the Goat programming language that means "nothing": <c>undefined</c>, <c>null</c> and <c>void</c>.</p>
			<s name="undefined">
				<p>As previously described, <c>undefined</c> means that no value has been assigned. Any variable defined using "var" keyword without an initial value has the value of <c>undefined</c>:</p>
				<c><![CDATA[
					var v;
					print(v); // output: "undefined"]]>
				</c>
				<p>Moreover, if you try to read the value of an undeclared variable, this value will also be <c>undefined</c>:</p>
				<c>print(n3j9v0kXXq);  // output: "undefined"</c>
				<p>The same is true if you read a non-existent property of an object:</p>
				<c><![CDATA[
					var obj = { x: 10, y: 20 };
					print(obj.z); // output: "undefined"]]>
				</c>
				<p>Is <c>undefined</c> an object? Yes. This is an object, and it even has its own prototype: <c>Undefined</c>. But you can not do anything with this object. You cannot change properties of <c>undefined</c>, you can not call methods. All you can is compare this object to <c>undefined</c>:</p>
				<c><![CDATA[
					if (obj == undedined) 
					{
						//...
					}]]>
				</c>
				<p>Or:</p>
				<c><![CDATA[
					if (defined(obj)) 
					{
						//...
					}]]>
				</c>
			</s>
			<s name="null">
				<p>The second special object. It means that the value was defined, that is, it is not equal to <c>undefined</c>, but it is empty. Null is not numeric, is not a string. This is "nothing".</p>
				<p>Unlike <c>undefined</c>, the <c>null</c> object is not created implicitly anywhere. It can be explicitly assigned to a variable or returned from a method:</p>
				<c><![CDATA[
					var n = null;
					
					var f = $() 
					{
						//...
						return null;
					};]]>
				</c>
				<p><c>null</c> is not equal to <c>undefined</c>:</p>
				<c><![CDATA[
					var u; // undefined
					
					if (u == null) // false!
					{
						//...
					}
					
					var n = null;
					
					if (defined(n)) // true!
					{
						// ...
					}
					]]>
				</c>
				<p>Is <c>null</c> an object? Yes. This is an object, like <c>undefined</c>, and it has its own prototype: <c>Null</c>. You can not add prototypes to <c>null</c>, but you can call methods, for example:</p>
				<c>print(null.instanceof(Null)); // "true"</c>
			</s>
			<s name="void">
				<p>The third data type, which combines the two previous ones.</p>
				<p>The <c>void</c> object has prototype <c>Void</c>", and both <c>Undefined</c> and <c>Null</c> inheriths from <c>Void</c>. So, in other words, <b><c>undefined</c> is <c>void</c> and <c>null</c> is <c>void</c>.</b> This is used if you need to check with one operation whether the object is <c>null</c> or <c>undefined</c>:</p>
				<c><![CDATA[
					var f = $(value) 
					{
						if (value == void) 
						{
							throw new Exception.IllegalArgument();
						}
						
						//...
					};]]>
				</c>
				<p>This is the same as:</p>
				<c><![CDATA[
					var f = $(value) 
					{
						if (value == undefined || value == null) 
						{
							throw new Exception.IllegalArgument();
						}
						
						//...
					};]]>
				</c>
			</s>
			<s name="Operator ?. (void guard)">
				<p>You can not read a property from <c>undefined</c> or <c>null</c>. If you try to read a property (or call a method) from <c>undefined</c>, this will throw an exception <c>Exception.CanNotReadPropertyOfUndefined</c>. If you try to read a property from <c>null</c>, then <c>null</c> contains no properties (except standard methods and operators). Thus, sometimes it is necessary to check whether a variable (most often an argument of a method) is a void. This avoids unintended consequences like exceptions. For example:</p>
				<c><![CDATA[
					// safe 'exist' field reading from 'some.object.that.might.not.exist': 
					if (some != void) 
					{
						if (some.object != void) 
						{
							if (some.object.that != void) 
							{
								if (some.object.that.might != void) 
								{
									if (some.object.that.might.not != void) 
									{
										return some.object.that.might.not.exist;
									}
								}
							}
						}
					}
					return 0;]]>
				</c>
				<p>This, probably, is not the shortest solution.</p>
				<p>Operator <c>?.</c> read a property (calls a method) only if a left object is not void, otherwise returns <c>undefined:</c></p>
				<c><![CDATA[
					/* if object is void (null or undefined) then val = undefined,
					  else val = property: */
					val = object?.property;
					
					/* if object is void (null or undefined) then val = undefined,
					  else val is result of method call: */
					val = object?.method();]]>
				</c>
				<p>The result can be supplemented by the <b>or</b> (<c>||</c>) operator to change <c>undefined</c> to alternate value:</p>
				<c><![CDATA[
					/* if object is void (null or undefined) then val = alternate,
					  else val = property: */
					val = object?.property || alternate;
					
					/* if object is void (null or undefined) then val = alternate,
					  else val is result of method call: */
					val = object?.method() || alternate;]]>
				</c>
				<p>Okay, let's rewrite the first example. Is not it, much shorter:</p>
				<c>return some?.object?.that?.might?.not?.exist || 0;</c>
			</s>
		</s>
		<s name="Objects write protection">
			<p>Objects can be write protected. After protecting, nothing can change (or add) properties or methods of the object.</p>
			<s name="Operator #">
				<p>This is a unary operator. It clones an object passed as a parameter (to the right of the operator) and then write protect the result of cloning. The object returned by the operator cannot be changed:</p>
				<c><![CDATA[
					var obj = # 
					{
						x : 10,
						y : 20
					};
					
					obj.z = 30; // illegal operation!
					]]>
				</c>
				<p>The operator does not change the original object. Only its copy is protected:</p>
				<c><![CDATA[
					var A = 
					{
						x : 10,
						y : 20
					};
					
					var B = #A;
					
					A.z = 30; // allowed
					B.z = 30; // is not allowed
					]]>
				</c>
			</s>
			<s name="What happens when writing to a write protected object?">
				<p>The interpreter will immediately throw an exception <c>Exception.IllegalOperation</c>:</p>
				<c><![CDATA[
					var A = # 
					{
						x: 10,
						y: 20
					};

					try 
					{
						A.z = 0;
					}
					catch(e) 
					{
						if (e.instanceof(Exception.IllegalOperation))
							print("oops!");
					}]]>
				</c>
			</s>
			<s name="Why is it necessary to protect objects from writing?">
				<p>Obviously, to prevent changes that will lead to an error. A classic example is the creation of enumerations. The standard library contains many such enumerations. For example, file mode for i/o operations:</p>
				<c><![CDATA[
					File.Mode = 
					{
						READ : "READ",
						WRITE : "WRITE",
						APPEND : "APPEND",
						FULL : "FULL"
					};]]>
				</c>
				<p>This enumeration is used when opening a file:</p>
				<c>var file = open(file_name, File.Mode.WRITE);</c>
				<p>However, if it were possible, intentionally or accidentally, to change the values of this enumeration, for example, like this:</p>
				<c>File.Mode.WRITE = &quot;READ&quot;;</c>
				<p>...continued use of this enumeration would result in an error. Therefore, such an object must be immutable. To protect object, just add operator <c>#</c> before object declaration.</p>
				<p>All objects of the standard library - classes, functions, enums, including built-in, i.e. Object, String, Integer, etc. - are write protected.</p>
			</s>
		</s>
		<s name="Threads">
			<p>The Goat programming language supports threads. A thread of execution is the smallest sequence of programmed instructions that  managed independently by a scheduler. In other words, thread is the ability to execute two or more sections of code at the same time.</p>
			<p>Each running program contains at least one thread. Goat does not separate the "main" and "non-main" threads - each thread can initiate a new thread, and each thread can stop execution of another thread (if it has a pointer to this). The program ends only when all threads are completed.</p>
			<s name="Threads declaration">
				<p>Threads are declared in the same way as functions, but the <c>thread</c> keyword is used instead of the <c>function</c> keyword:</p>
				<c><![CDATA[
					var a = thread() 
					{
						for (var i = 0; i < 10; i++)
							print('A');
					};]]>
				</c>
			</s>
			<s name="Starting">
				<p>To start a thread, need to call the <c>run()</c> method:</p>
				<c><![CDATA[
					var a = thread() 
					{
						for (var i = 0; i < 10; i++)
							print('A');
					};
					
					a.run();]]>
				</c>
				<p>Output:</p>
				<c>AAAAAAAAAA</c>
				<p>You can not re-run a thread that is already in progress.</p>
				<p>You can run two, three, as many threads as you need, and they will run at the same time:</p>
				<c><![CDATA[
					var a = thread() 
					{
						for (var i = 0; i < 10; i++)
							print('A');
					};

					var b = thread() 
					{
						for (var i = 0; i < 10; i++)
							print('B');
					};

					a.run();
					b.run();]]>
				</c>
				<p>The output is something like this:</p>
				<c>ABABABABABABABABABAB</c>
				<p>Note: there is no guarantee of the order of execution of threads. The result may well be:</p>
				<c>AABBBAAAABABBAABABAB</c>
				<p>It is guaranteed that every thread will be executed from beginning to end.</p>
			</s>
			<s name="Stopping">
				<p>The running thread can be stopped by the <c>stop()</c> method:</p>
				<c><![CDATA[
					var b = thread() 
					{
						// this thread will never end if it does not stop!
						while(true)
							print('B');
					};

					b.run();
					for (var i = 0; i < 10; i++)
						print('A');
					b.stop();]]>
				</c>
				<p>The output is something like this:</p>
				<c>BBABBABBABBBABBABBABBBABBABBABBBABB</c>
			</s>
		</s>
	</s>
	
	<s name="Standard library">
		<p>The standard library contains functions and classes for solving common tasks.</p>
		<p>All the functionality of the standard library is divided into two parts: <b>internal</b> (as part of the interpreter core) and <b>external.</b></p>
		<p>The functionality of the inner part of the library is written in C++ language and is the minimum required set for solving most tasks. This functionality includes platform-dependent components, such as working with files. No additional modules are required to use the internal library, these classes and functions are always available.</p>
		<p>The external library is written in Goat language. It is a set of files that contain separate classes for solving various tasks. To use this class from the library, you need to link the corresponding file using the <c>import</c> keyword.</p>
		<s name="Internal (core) library">
			<s name="Functions" anchor="Built-in functions">
				<s name="Input/output">
					<m name="print" descr="Converts an object to a string and sends this string to standard output.">
						<a name="object" type="any type" descr="an object"/>
						<e><![CDATA[
							print("Hello");
							print(2 + 3);
							print(0.01);
							print(false);
							print(null);]]>
						</e>
					</m>
					<m name="getc" descr="Reads one character from the standard input. Returns null if no characters (end-of-file is reached).">
						<e><![CDATA[
							while(true) 
							{
								var c = getc();
								if (c == null)
									break;
								print(c);
							}]]>
						</e>
					</m>
					<m name="gets" descr="Reads characters from the standard input and stores them as a string until a newline character or the end-of-file is reached.">
						<e><![CDATA[
							while(true) 
							{
								var s = gets();
								println(s);
							}]]>
						</e>
					</m>
					<m name="open" descr="Opens a file.">
						<a name="fname" type="String" descr="file name"/>
						<a name="mode" type="File.Mode" descr="mode, one of: File.Mode.READ, File.Mode.WRITE or File.Mode.APPEND"/>
						<e><![CDATA[
							var file = open("reference.xml", File.Mode.READ);
							var data = file.read(256); // read first 256 bytes]]>
						</e>
						<n>See description of 'File' class for more details.</n>
					</m>
				</s>
				<s name="Other">
					<m name="defined">
						<d>Returns <c>true</c> if the object is defined (i.e. not equals <c>undefined</c>), and <c>false</c> otherwise.</d>
						<a name="object" type="any type" descr="an object"/>
						<e><![CDATA[
							var func = $(param) 
							{
								if (!defined(param))
								{
									return;
								}
								
								//...
							};]]>
						</e>
					</m>
					<m name="clock" descr="Returns current system time in nanoseconds.">
						<e><![CDATA[
							var wait = $(time)
							{
								var begin = clock();
								var diff = 0;
								do
								{
									diff = clock() - begin;
								} while(diff < time * 1000000000);
							};

							var i;
							for (i = 5; i > 0; i--)
							{
								print("" + i + "\n");
								wait(1);
							}
							]]>
						</e>
						<n>The example shows a simple implementation of delay and countdown using the 'clock' function. The function returns the time span value between the begin of the 'system epoch' (it depends from the platform) and the current time point. In itself, this value is useless, as a rule, the difference between the two clock values is used.</n>
					</m>
				</s>
			</s>
			<s name="Classes">
				<s name="Input/output">
					<s name="File">
						<p>The class for file reading/writing.</p>
						<p>Files are opened by the <c>open</c> function (see above). The <c>open</c> function returns an object of <c>File</c> type, or <c>null</c> if the file could not be found or could not be open. The <c>File</c> class contains methods for reading/writing and some predefined fields, used in <c>open</c> and <c>seek</c> methods.</p>
						<s name="Methods">
							<m name="read">
								<d>Reads a file and returns a <c>ByteArray</c> object with data.</d>
								<a name="count" type="Integer" descr="number of bytes to read"/>
								<e><![CDATA[
									var f = open("data.txt", File.Mode.READ);
									var a = f.read(1024); // read first 1024 bytes ]]>
								</e>
								<n>If the number of bytes exceeds the file size, the method will return as many bytes as it could read. The position indicator of the file is advanced by the total amount of bytes read.</n>
							</m>
							<m name="eof">
								<d>Checks whether the end of file indicator associated with file is set, returning <c>true</c> if it is.</d>
								<e><![CDATA[
									var f = open("data.txt", File.Mode.READ);
									while (!f.eof())
									{
										// read the file in chunks of size 1024 bytes
										var a = f.read(1024);
										// ...
									}]]>
								</e>
							</m>
							<m name="position">
								<d>Returns the current value of the position indicator of the file.</d>
								<e><![CDATA[
									var f = open("data.txt", File.Mode.READ);
									f.seek(0, File.Origin.END);
									var len = f.position(); // length of file]]>
								</e>
							</m>
							<m name="seek">
								<d>Sets the position indicator associated with the file to a new position.</d>
								<a name="offset" type="Integer" descr="number of bytes to offset from origin"/>
								<a name="origin" type="File.Origin" descr="origin, one of: File.Origin.BEGIN, File.Origin.END or File.Origin.CURRENT"/>
								<e><![CDATA[
									var f = open("data.txt", File.Mode.READ);
									f.seek(0, File.Origin.END); // go to end of the file
									var len = f.position(); // take position (position at the end is the length of the file)
									f.seek(0, File.Origin.BEGIN); // now, go to begin
									var data = f.read(len); // read the whole file]]>
								</e>
							</m>
						</s>
						<s name="Fields">
							<h name="File.Mode">
								<p>The object contains constants for file access mode, is used as an argument for <c>open</c> function.</p>
								<c><![CDATA[
									File.Mode =
									{
										READ : ?,
										WRITE : ?,
										APPEND : ?
									};]]>
								</c>
								<p>Usage:</p>
								<c>var f = open("data.txt", File.Mode.READ);</c>
								<p>The question mark <c>?</c> means that in fact a constant is assigned a value (this is usually a number), but it depends on the implementation. Never use a value (magic number) instead of a constant!</p>
								<p>Very bad example, please do not repeat it:</p>
								<c>var f = open("data.txt", 0); // yes, it works now... but can fail later</c>
							</h>
							<h name="File.Origin">
								<p>The object contains constants for origin, is used as an argument for <c>File.seek</c> method.</p>
								<c><![CDATA[
									File.Origin =
									{
										BEGIN : ?,
										END : ?,
										CURRENT : ?
									};]]>
								</c>
							</h>
						</s>
					</s>
				</s>
				<s name="Sequences">
					<s name="ByteArray">
						<p>The class for storing an array of bytes.</p>
						<p>The Goat interpreter does not have separated type for bytes representing. Integer type is used for this purpose. However, each Integer object takes much more memory than 1 byte. If you need to store an array of bytes, do not create an array of integers, use <b>ByteArray</b> class instead.</p>
						<p>ByteArray class is used in files read/write operations.</p>
						<s name="Methods">
							<m name="length" descr="Returns length of the byte array."/>
							<m name="push">
								<d>Appends a byte to the byte array.</d>
								<a name="byte" type="Integer" descr="byte, valid values [0...255]"/>
								<e><![CDATA[
									var a = new ByteArray();
									a.push(0); ]]>
								</e>
							</m>
							<m name="decodeUTF8">
								<d>Decodes the byte array as UTF-8 encoded text and returns a string.</d>
								<e><![CDATA[
									// open the file and decode it as UTF-8
									var file = open("data.txt", File.Mode.READ);
									file.seek(0, File.Origin.END); // go to end of the file
									var len = file.position(); // take the length of the file
									file.seek(0, File.Origin.BEGIN); // now, go to begin
									var raw = file.read(len); // read the whole file
									var text = raw.decodeUTF8(); // decode]]>
								</e>
							</m>
						</s>
					</s>
					<s name="StringBuilder">
						<p>The class for strings constructing.</p>
						<p>The Goat programming language has immutable strings. It prevents many errors, but in some cases constructing of long string takes a lot of time, because for each iteration Goat creates a new string. For example:</p>
						<c><![CDATA[
							// some coordinates:
							var c = { x: 10, y: 20, z: 30};
							
							// build string:
							var str = "X=" + c.x + ", Y=" + c.y + ", Z=" + c.z;]]>
						</c>
						<p>It works, yes, but it is not a better solution. Goat splits the long expression and creates a new string (which, in turn, involves the creation of a new array of characters, and copying of the original array) on each step:</p>
						<c><![CDATA[
							"X=" + c.x
							-> "X=10"
							... + ", Y=" 
							-> "X=10, Y="
							... + c.y
							-> "X=10, Y=20"
							... + ", Z=" 
							-> "X=10, Y=20, Z="
							... + c.z
							-> "X=10, Y=20, Z=30"]]>
						</c>
						<p>So, five strings will be constructed. What about thousands of strings? Say you have an array and you need to make a string. A lot of time, a lot of memory! Or, you can use <b>StringBuilder.</b></p>
						<c><![CDATA[
							// some coordinates:
							var c = { x: 10, y: 20, z: 30};
							
							// build string:
							var b = new StringBuilder();
							b << "X=" << c.x << ", Y=" << c.y << ", Z=" << c.z;
							var str = b.toString();]]>
						</c>
						<p>Much better.</p>
						<p>StringBuilder has an array to hold characters. This array grows when new items (characters, strings, etc) added. This class does not create a new string for each addition. Thus, the construction of a long string takes much less time and memory.</p>
						<s name="Methods">
							<m name="append" descr="Appends string representation of object to the sequence.">
								<a name="object" type="any type" descr="an object"/>
								<a name="count" type="Integer" descr="optional, the number of times the object will be added"/>
								<e><![CDATA[
									var b = new StringBuilder();
									b.append("test");
									b.append('#');
									b.append(123);
									b.append('*', 5);
									print(b); // output: "test#123*****"]]>
								</e>
							</m>
							<m name="toString" descr="Returns a string representing the data in this sequence.">
								<e><![CDATA[
									var b = new StringBuilder();
									b.append("hello");
									b.append(", ");
									b.append("world");
									var s = b.toString(); // contains "hello, world"]]>
								</e>
							</m>
						</s>
						<s name="Operators">
							<o name="&lt;&lt;" descr="Appends string representation of object to the sequence.">
								<e><![CDATA[
									var b = new StringBuilder();
									b << "test" << '#' << 123;
									print(b); // output: "test#123"]]>
								</e>
								<n>This is a synonym for the <c>append</c> method, but using the operator instead of the method is more convenient.</n>
							</o>
						</s>
					</s>
				</s>
			</s>
		</s>
		<s name="External library">
			<s name="Containers">
				<p>Containers are used to store data. A container is a grouping of some variable number of data items (possibly zero) that have some shared significance to the problem being solved and need to be operated upon together in some fashion.</p>
				<p>Examples of containers include list, stack, queue, etc.</p>
				<s name="Stack">
					<p>A stack is a data type that serves as a container of elements, with two principal operations: <b>push</b>, which adds an element to the container, and <b>pop</b>, which removes the most recently added element that was not yet removed.</p>
					<p>Elements can be taken from the stack in the reverse order to how they were put there. Another name of the stack structure - LIFO ("last in, first out"). Additionally, a peek operation may give access to the top without modifying the stack.</p>
					<s name="Methods">
						<m name="empty">
							<d>Returns <c>true</c> if the stack is empty and <c>false</c> otherwise.</d>
						</m>
						<m name="push" descr="Adds an element to the stack.">
							<a name="object" type="any type" descr="an object"/>
						</m>
						<m name="pop" descr="Removes the most recently added element and returns it.">
							<n>If the stack is empty, throws <c>Stack.StackIsEmpty</c> exception.</n>
						</m>
						<m name="peek" descr="Returns the top element without modifying the stack.">
							<n>If the stack is empty, throws <c>Stack.StackIsEmpty</c> exception.</n>
						</m>
						<m name="iterator" descr="Returns an iterator pointing to the beginning of the stack."/>
					</s>
					<s name="Example">
						<p>Code:</p>
						<c><![CDATA[
							import "stack.goat";

							var s = new Stack();

							for (var i = 0; i < 5; i++)
								s.push(i);

							while(!s.empty())
								print("" + s.pop() + "\n");]]>
						</c>
						<p>Output:</p>
						<c><![CDATA[
							4
							3
							2
							1
							0]]>
						</c>
					</s>
				</s>
				<s name="Iterator">
					<p>An iterator is an object that enables to traverse a container. Each container inherits <c>Iterable</c> object which has <c>iterator()</c> method. This method returns an iterator object which points to the first item of the container (or points to nothing if the container is empty). An iterator object has methods for reading/writing data and also has <c>next()</c> method to move to next item. Each container implements its iterator, which has the above methods. Thus, regardless of the container (stack, list, etc.), we have a universal way to traverse a container and get/modify data.</p>
					<s name="Methods">
						<m name="valid">
							<d>Returns <c>true</c> if the iterators is valid (i.e. points to an item of the container) and <c>false</c> otherwise.</d>
						</m>
						<m name="next" descr="Moves to the next container element."/>
						<m name="read" descr="Returns value of the current item.">
							<n>If the iterator is not valid, throws <c>Exception.InvalidOperation</c> exception.</n>
						</m>
						<m name="write" descr="Write (replace) value of the current item.">
							<a name="val" type="any type" descr="a value"/>
							<n>If the iterator is not valid, throws <c>Exception.InvalidOperation</c> exception.</n>
						</m>
						<m name="iterator" descr="Returns an iterator pointing to the beginning of the stack."/>
					</s>
					<s name="Example">
						<p>Code:</p>
						<c><![CDATA[
							import "stack.goat";

							var s = new Stack();

							for (var v = 0; v < 5; v++)
								s.push(v);

							for (var i = s.iterator(); i.valid(); i.next())
								print("" + i.read() + "\n");]]>
						</c>
						<p>Output:</p>
						<c><![CDATA[
							4
							3
							2
							1
							0]]>
						</c>
					</s>
				</s>
			</s>
			<s name="Timer">
				<p>The <b>Timer</b> class measures time intervals. At the end of the interval, a function (callback) is called. The <c>setTimer()</c> method calls a function once; the <c>setInterval()</c> method calls periodically. Also, the <c>Timer</c> class has several auxiliary classes for determining time intervals.</p>
				<s name="Classes">
					<s name="Timer.Duration">
						<p>Base class for determining time intervals. Has a method:</p>
						<m name="getNanoseconds" descr="Returns the time interval, converted to nanoseconds."/>
					</s>
					<s name="Timer.Nanoseconds">
						<p>Derived from <c>Timer.Duration</c>, determine the time interval in nanoseconds.</p>
						<c><![CDATA[
							import "timer.goat"
							
							var d = new Timer.Nanoseconds(50); // determine 50 nanoseconds
							]]>
						</c>
					</s>
					<s name="Timer.Microseconds">
						<p>Derived from <c>Timer.Duration</c>, determine the time interval in microseconds.</p>
					</s>
					<s name="Timer.Milliseconds">
						<p>Derived from <c>Timer.Duration</c>, determine the time interval in milliseconds.</p>
					</s>
					<s name="Timer.Seconds">
						<p>Derived from <c>Timer.Duration</c>, determine the time interval in seconds.</p>
					</s>
					<s name="Timer.Minutes">
						<p>Derived from <c>Timer.Duration</c>, determine the time interval in minutes.</p>
					</s>
					<s name="Timer.Hours">
						<p>Derived from <c>Timer.Duration</c>, determine the time interval in hours.</p>
					</s>
					<s name="Timer.Interval">
						<p>An object returned from <c>setInterval()</c> method.</p>
						<s name="Methods">
							<m name="stop" descr="Stops a periodic function call."/>
						</s>
						<s name="Fields">
							<h name="ticks">
								<p>Integer. The number of triggered calls, that is, how many times the function was called.</p>
							</h>
							<h name="skipped">
								<p>Integer. The number of skips.</p>
								<p>If the setInterval() method does not have time to process the previous function call until the next call, the next call of the function is skipped.</p>
							</h>
						</s>
					</s>
				</s>
				<s name="Methods">
					<p>The ability to measure small (up to nanosecond) time intervals always depends on the particular platform on which the interpreter runs.</p>
					<m name="setTimer" descr="Calls the function (callback) once after a determined time has elapsed.">
						<a name="callback" type="Function" descr="a function"/>
						<a name="duration" type="Timer.Duration" descr="a duration (Timer.Seconds, Timer.Milliseconds etc.)"/>
						<n>The function is called in a separate thread. It runs concurrently with the main thread of the program. May need to synchronize (mutexes, etc.) when accessing some data.</n>
						<e><![CDATA[
							import "timer.goat";

							print("begin... ");

							Timer.setTimer($()
							{
								print("done!");
							}, new Timer.Seconds(5));]]>
						</e>
					</m>
					<m name="setInterval" descr="Calls the function (callback) periodically.">
						<a name="callback" type="Function" descr="a function"/>
						<a name="interval" type="Timer.Duration" descr="an interval (Timer.Seconds, Timer.Milliseconds etc.)"/>
						<n>The function is called in a separate thread. The <c>setInterval()</c> method tries to call a function (callback) at regular intervals. Namely, <b>the moments of the beginning of a function call</b> are located approximately at regular intervals. If the <c>setInterval()</c> method does not have time to process the previous function call until the next call, the next call of the function is skipped. </n>
						<e><![CDATA[
							import "timer.goat";

							print("begin...\n");

							var c = 0;
							var i = Timer.setInterval($()
							{
								print("" + c + "\n");
								c++;
							}, new Timer.Seconds(1));

							while(c < 10)
							{
								// wait for 10 seconds
							}

							i.stop();]]>
						</e>
					</m>
				</s>
			</s>
			<s name="XML">
				<p>Simple XML parser. For more info about XML format, please visit <url>https://en.wikipedia.org/wiki/XML</url>.</p>
				<p>The parser takes a string that contains the source document. If you need to parse the file, you must first read and decode it using other methods. The document is recognized as a whole, the output is a tree of XML elements. If the document contains an error, the parser throws an appropriate exception.</p>
				<s name="Classes">
					<s name="XML.Element">
						<p>The class that contains the data of one XML element. An XML element can contain attributes and child elements, thus, each element is the root of the element tree. The XML parser returns one root element that contains all document as a tree of elements.</p>
						<s name="Fields">
							<h name="tag">
								<p>String. The element's tag. For example, after parsing the element:</p>
								<c><![CDATA[
									<root>...</root>]]>
								</c>
								<p>the <c>tag</c> field will be contain the value "root".</p>
							</h>
							<h name="attrib">
								<p>Object, contains attributes. For example, after parsing the element:</p>
								<c><![CDATA[
									<rectangle width="300" height="200">...</rectangle>]]>
								</c>
								<p>the <c>attrib</c> field will be contain the object <c>{width:300,height:200}</c>.</p>
								<p>If the element does not have attributes, this field will contain an empty object.</p>
							</h>
							<h name="content">
								<p>An array containing child elements. A child element can be a string or an <c>XML.Element</c> type. For example, after parsing the element:</p>
								<c><![CDATA[
									<list><elem_1>...</elem_1>Some text between elements<elem_2>...</elem_2></list>]]>
								</c>
								<p>the <c>content</c> field will be contain the array:</p>
								<l>
									<i>item 0: <c>XML.Element</c> containing "elem_1" tag and child elements;</i>
									<i>item 1: string "Some text between elements";</i>
									<i>item 2: <c>XML.Element</c> containing "elem_2" tag and child elements.</i>
								</l>
							</h>
						</s>
						<s name="Methods">
							<m name="toString" descr="Converts XML tree to a string.">
								<a name="indent" type="String" descr="If specified, this indentation will be added before each child element, for better readability of the document. If not specified, a compact document will be generated without indentation."/>
							</m>
							<p>For example, let's сreate a simple XML tree:</p>
							<c><![CDATA[
								<root>
									<first>Data of the first element</first>
									<second/>
									<third>
										<child>Data of the child element</child>
									</third>
								</root>]]>
							</c>
							<p>To do this, write the following code:</p>
							<c><![CDATA[
								import "xml.goat";

								var root = XML.parse("<root><first>Data of the first element</first><second/><third><child>Data of the child element</child></third></root>");]]>
							</c>
							<p>Now convert the tree back into a string without indentation:</p>
							<c>print(root.toString());</c>
							<p>Output is:</p>
							<c><![CDATA[
								<root><first>Data of the first element</first><second/><third><child>Data of the child element</child></third></root>]]>
							</c>
							<p>Сonvert the tree to a string again, but indented into two spaces:</p>
							<c>print(root.toString("  "));</c>
							<p>Output is:</p>
							<c><![CDATA[
								<root>
								  <first>Data of the first element</first>
								  <second/>
								  <third>
									<child>Data of the child element</child>
								  </third>
								</root>]]>
							</c>
							<p>Indentation can be not only spaces but also any other characters. Now let's try an indent, consisting of a vertical line and space (<c>| </c>):</p>
							<c>print(root.toString("| "));</c>
							<p>Output is:</p>
							<c><![CDATA[
								<root>
								| <first>Data of the first element</first>
								| <second/>
								| <third>
								| | <child>Data of the child element</child>
								| </third>
								</root>]]>
							</c>
						</s>
					</s>
					<s name="XML.Error">
						<p>The class contains a description of the error that occurred in the case of parsing a non-valid document.</p>
						<p>Consists of two fields:</p>
						<h name="type">
							<p>Error type, string. The parser usually selects the type of error from the predefined set of strings:</p>
							<c><![CDATA[
								XML.Error.INVALID_TOKEN : "invalid token",
								XML.Error.EXPECTED_TAG_NAME : "expected tag name",
								XML.Error.UNEXPECTED_END : "unexpected end",
								XML.Error.END_TAG_MISMATCH : "end tag does not match the start tag",
								XML.Error.UNCLOSED_END_TAG : "end element was missing the character \'>\'",
								XML.Error.MISSING_EQUALS : "missing \'=\' sign between attribute and attribute value",
								XML.Error.MISSING_STRING : "a string literal was expected",
								XML.Error.DUPLICATE_ATTRIBUTE : "duplicate attribute",
								XML.Error.UNKNOWN_ENTITY : "unknown entity",
								XML.Error.INVALID_CHARACTER : "invalid character",
								XML.Error.EXPECTED_CDATA_SEQUENCE : "expected <![CDATA[ sequence"]]>
							</c>
						</h>
						<h name="index">
							<p>Integer, the character number (index) in the source line on which the error occurred.</p>
						</h>
					</s>
				</s>
				<s name="Methods">
					<m name="parse" descr="Parse the string and returns an XML tree.">
						<a name="str" type="String" descr="the source string"/>
						<e><![CDATA[
							import "xml.goat";

							var root = XML.parse("<root><item>Data of the item</item></root>");]]>
						</e>
						<n>If XML document is not valid, throws <c>XML.Error</c> exception. If valid, returns <c>XML.Element</c> object contains root element.</n>
					</m>
				</s>
			</s>
		</s>
	</s>
	
	<s name="Appendix">
		<s name="In comparison with JavaScript">
			<p>The Goat programming language based in general on JavaScript syntax, but it has some differences.</p>
			<l>
				<i>The interpreter (engine) of the programming language is not a complement to the existing solutions, say, V8. It is completely developed from scratch. The interpreter is a very small program and can be compiled and started on different platforms. I tried  Windows and Linux (both x86 and ARM). All you need are C++11 compiler and standard C library (libc etc).</i>
				<i>Programs are launched not in a browser, not in a special environment (say Node.js); you can write general-purpose applications. Easy to install: just copy the file with your code and interpreter and then start.</i>
				<i>The syntax is more simple, the object model is more unified.</i>
				<i>Goat language supports multi-threading and operators overloading.</i>
				<i>You can create an object from more than one prototype.</i>
			</l>
			<p>Some samples are below.</p>
			<s name="Identifiers">
				<h name="JavaScript">
					<p>The first character of an identifier must be a letter, or an underscore (<c>_</c>), or a dollar sign (<c>$</c>). Subsequent characters may be letters, digits, underscores, or dollar signs.</p>
				</h>
				<h name="Goat">
					<p>The first character must be a letter or an underscore (<c>_</c>). Subsequent characters may be letters, digits or underscores.</p>
					<p>Dollar sign used as a short replacement of <c>function</c> keyword:</p>
					<c>var f = $(a, b) { };</c>
					<p>it's the same as:</p>
					<c>var f = function(a, b) { };</c>
				</h>
			</s>
			<s name="Keywords">
				<p>The Goat programming language reserves several additional keywords:</p>
				<t>
					<h>
						<c>Keyword</c>
						<c>Description</c>
					</h>
					<r>
						<c><c>thread</c></c>
						<c>Declares a thread</c>
					</r>
					<r>
						<c><c>lock</c></c>
						<c>Declares a critical section (this is a synchronization primitive)</c>
					</r>
					<r>
						<c><c>import</c></c>
						<c>Imports a source file</c>
					</r>
					<r>
						<c><c>debug</c>(instead of <c>debugger</c>)</c>
						<c>Stops the execution of Goat script, and switch the interpreter to debug (step-by-step) mode</c>
					</r>
				</t>
			</s>
			<s name="Primitive types">
				<h name="JavaScript">
					A primitive data type is data that is not an object and has no methods. There are 6 primitive data types: string, number, boolean, null, undefined, symbol. All primitives are immutable.
				</h>
				<h name="Goat">
					<p>There are no primitive types. All data represented as objects. Each object except <c>undefined</c> has some methods. There are some predefined objects which are prototypes for primitive data, such as numbers or strings: <c>Char</c>, <c>String</c>, <c>Integer</c>, <c>Real</c>, <c>Boolean</c>, <c>Void</c>, <c>Undefined</c> and <c>Null</c>.</p>
					<p>This programming language clearly distinguishes between strings (the prototype is <c>String</c>) and individual characters (the prototype is <c>Char</c>), as well as integers (<c>Integer</c>) and floating-point numbers (<c>Real</c>). These types have a different set of methods and operators, but if necessary, a type can be converted to another:</p>
					<c><![CDATA[
						var c = 'a'; // prototype of c is Char
						var s = String.valueof(c); // conversion to String]]>
					</c>
					<p>All other structures, for example, functions, threads, arrays, etc have own prototypes (<c>Function</c>, <c>Thread</c>, <c>Array</c>).</p>
				</h>
			</s>
			<s name="Scope">
				<h name="JavaScript">
					<p>There are two types of scopes: global and local. Variables defined inside a function are in the local scope. Variables defined inside of a block statement will remain in the scope they were already in. ECMAScript 6 introduced the <c>let</c> keyword. Contrary to the <c>var</c> keyword, the <c>let</c> keyword supports the declaration of local scope inside block statements.</p>
					<c><![CDATA[
						var func = function()
						{
							var v = 0;
							// do something...
							if (true)
							{
								let v = 1; // local declaration
							}
						};]]>
					</c>
					<p>If you re-declare a JavaScript variable in the same block, it will not lose its value.</p>
				</h>
				<h name="Goat">
					<p>There is no global scope. You can re-declare variable with the same name in inner block statement, it will be used only in this block and its inner blocks.</p>
					<c><![CDATA[
						var func = $()
						{
							var v = 0;
							if (true)
							{
								var v = 1;
								print(v); // output: "1"
							}
							print(v); // output: "0"
						};]]>
					</c>
					<p>But, if you re-declare a Goat variable in the same block, it will lose old value.</p>
				</h>
			</s>
			<s name="The 'this' keyword">
				<h name="JavaScript">
					<p>You must use the <c>this</c> keyword to refer to the field of own object:</p>
					<c><![CDATA[
						var MyClass = function()
						{
							this.x = 0;
						};
						
						MyClass.prototype.getX = function()
						{
							return this.x;
						};]]>
					</c>
				</h>
				<h name="Goat">
					<p>You can use the <c>this</c> keyword to refer to the field of own object, but you must not do it in all cases. You can skip <c>this</c> keyword in the methods. But in some cases, <c>this</c> keyword cannot be avoided, for example, if you already have a local variable or an argument with that name, but you want to explicit read or write the property of the object, or, you can add new properties to own object (which are not yet there):</p>
					<c><![CDATA[
						var MyClass = 
						{
							init : $()
							{
								this.x = 0; // with 'this'
							},
							
							getX : $()
							{
								return x; // without 'this'
							}
						};]]>
					</c>
				</h>
			</s>
			<s name="Operators">
				<p>The Goat language has no comparison operators <c>===</c> (equal value and equal type) and <c>!==</c> (not equal value or not equal type). Operators <c>==</c> and <c>!=</c> works in most cases as <c>===</c> and <c>!==</c> operators in JavaScript.</p>
				<p>The Goat language has not <c>typeof</c> and <c>instanceof</c> operators. Use <c>instanceof</c> method instead:</p>
				<c>print(13.instanceof(Integer)); // output: "true"</c>
				<p>The Goat language provides  several new operators:</p>
				<l>
					<i><c>-&gt;</c> that means inheritance;</i>
					<i><c>#</c> for write protecting (after that, an object cannot be changed);</i>
					<i><c>?.</c>as null conditional operator.</i>
				</l>
			</s>
			<s name="Operators overloading">
				<h name="JavaScript">
					<p>Doesn't support.</p>
				</h>
				<h name="Goat">
					<p>You can use the operator as method name:</p>
					<c><![CDATA[
						var Vector =
						{
							init : $(x, y)
							{
								this.x = x; this.y = y
							},
							
							toString : $()
							{
								return "X: " + x + ", Y: " + y;
							},
							
							"+" : $(vec)
							{
								return new Vector(x + vec.x, y + vec.y);
							},
							
							"*" : $(val)
							{
								return new Vector(x * val, y * val);
							}
						};

						var v1 = new Vector(100, 200);
						var v2 = new Vector(200, 400);

						println((v1 + v2).toString()); // output: "X: 300, Y: 600"
						println((v1 * 5).toString()); // output: "X: 500, Y: 1000";]]>
					</c>
				</h>
			</s>
			<s name="Multithreading">
				<h name="JavaScript">
					<p>Doesn't support. There are some workarounds, say web workers, and, of course, functions <c>setTimeout()</c> and <c>setInterval()</c>.</p>
				</h>
				<h name="Goat">
					<p>There is <c>thread</c> keyword. It possible to declare any function as a separate thread.</p>
					<c><![CDATA[
						var t0 = thread()
						{
							while(true)
							{
								print('A');
							}
						};

						var t1 = thread()
						{
							while(true)
							{
								print('B');
							}
						};

						t0.run();
						t1.run();

						// Output: "ABABABABABABAB...."]]>
					</c>
				</h>
			</s>
			<s name="The 'new' keyword and constructors">
				<h name="JavaScript">
					<p>Constructors are like regular functions, but we use them with the <c>new</c> keyword. If you inherit your object and the parent has a constructor, you need to call parent constructor to perform initialization logic.</p>
					<c><![CDATA[
						var A = function()
						{
							// init something...
						};

						var B = function()
						{
							A.apply(this);
							// init something else...
						};
						B.prototype = new A();]]>
					</c>
				</h>
				<h name="Goat">
					<p>There is special method <c>init()</c>. If method defined, interpreter call it. If method also defined in base object, interpreter call it first (the order in which constructors are called is determined by the inheritance topology).</p>
					<c><![CDATA[
						var A = 
						{
							init : $()
							{
								// init something...
							}
						};

						var B = A -> 
						{
							init : $()
							{
								// init something else...
							}
						};

						var obj = new B(); /* both init method will be called,
											  first from A, second from B */]]>
					</c>
				</h>
			</s>
			<s name="Inheritance">
				<h name="JavaScript">
					<c><![CDATA[
						var A = function()
						{
							this.x = 0;
						};

						var B = function()
						{
							A.apply(this);
							this.y = 1;
						};
						B.prototype = new A();

						var C = function()
						{
							B.apply(this);
							this.z = 2;
						};
						C.prototype = new B();]]>
					</c>
					<p>Nearly all objects in JavaScript are instances of <c>Object</c>, a typical object inherits properties (including methods) from <c>Object.prototype</c>.</p>
				</h>
				<h name="Goat">
					<p>The syntax is much simpler. Use operator <c>-&gt;</c>:</p>
					<c><![CDATA[
						var A =
						{
							x : 0
						};

						var B = A ->
						{
							y : 1
						};

						var C = B ->
						{
							z : 2
						};]]>
					</c>
					<p>Goat language has also has class (prototype) named <c>Object</c>, is the root of the class hierarchy. Any object has prototype; if it created from literal (for example, strings), or it created by <c>new</c> keyword, or if prototype(s) is explicitly specified when creating an object:</p>
					<c><![CDATA[
						var A = { }; // the prototype of 'A' is 'Object' 
						var S = "hello"; // the prototype of 'S' is 'String'
						var B = new A(); // the prototype of 'B' is 'A'
						var C = B->{ }; // the prototype of 'C' is 'B']]>
					</c>
				</h>
			</s>
			<s name="Multiple inheritance">
				<h name="JavaScript">
					<p>Is not supported. You can use some tricks (say mixins) but it is not true multiple inheritance.</p>
				</h>
				<h name="Goat">
					<p>Why not.</p>
					<c><![CDATA[
						var A =
						{
							x : 0
						};

						var B =
						{
							y : 1
						};

						var C = [A, B] ->
						{
							z : 2
						};]]>
					</c>
					<p>The prototype traversal order for multiple inheritance is determined by the topological sorting of the prototype tree.</p>
				</h>
			</s>
			<s name="Syntactic sugar">
				<s name="Null conditional operator">
					<h name="JavaScript">
						<p>Doesn't support. Currently, it is proposal options, it will be supported later.</p>
					</h>
					<h name="Goat">
						<p>Operator <c>?.</c> is added. Operator <c>?.</c> read a property (calls a method) only if a left object is not void, otherwise returns <c>undefined:</c></p>
						<c><![CDATA[
							var value = user?.address?.street;
							]]>
						</c>
					</h>
				</s>
			</s>
		</s>
		<s name="Command line options and environment variables" anchor="Full list of command line options">
			<p>Here is the full list of command line options.</p>
			<h name="--lib">
				<p>Path (paths) to external libraries (to importable files), for example, a path to the Goat standard library. Several paths should be separated by a semicolon.</p>
				<p>Example, for Windows:</p>
				<c>goat.exe program.goat --lib=c:\goat\lib;c:\project</c>
				<p>Example, for Linux:</p>
				<c>./goat program.goat --lib=/work/goat/lib;/work/project</c>
				<p>The search for the included file is performed in the order specified in the list. In the example above, the list contains two items:</p>
				<l>
					<i>c:\goat\lib</i>
					<i>c:\project</i>
				</l>
				<p>Say the script contains the line:</p>
				<c>import &quot;xml.goat&quot;;</c>
				<p>The interpreter first tried to open the file <c>c:\goat\lib\xml.goat</c>, and if it was not found, the file <c>c:\project\xml.goat</c>.</p>
				<p>The current folder where the script was launched from has the highest priority; the search starts from it. If you need to include a file from a specific folder, specify the full path in the <c>import</c> directive:</p>
				<c>import &quot;project/xml.goat&quot;;</c>
				<p>This option can be set as an environment variable <c>GOAT_LIBRARY_PATH</c>. Example, for Windows:</p>
				<c><![CDATA[
					set GOAT_LIBRARY_PATH=c:\goat\lib;c:\project
					goat.exe program.goat
					]]>
				</c>
				<p>Example, for Linux:</p>
				<c><![CDATA[
					export GOAT_LIBRARY_PATH=/work/goat/lib;/work/project
					/work/goat program.goat
					]]>
				</c>
				<p>If both the environment variable and the command line option are set, then the command line option is preferred. This means that both lists will be used, but first, the search will be performed in the list defined in the command line.</p>
			</h>
			<h name="--language= or --lang=">
				<p>Set language for compiler output messages. Supported languages are:</p>
				<l>
					<i>english (en) - default</i>
					<i>russian (ru)</i>
				</l>
				<p>This option can be set as an environment variable <c>GOAT_LANGUAGE</c>.</p>
			</h>
			<h name="--debug and --run">
				<p>After starting, you switch to debug mode, where you can add breakpoints and execute the program line by line. This mode is described in the <link>Step-by-step debugging</link> section.</p>
				<p>Example:</p>
				<c>goat.exe program.goat --debug</c>
				<p>This option can be set as an environment variable <c>GOAT_DEBUG</c>.</p>
				<p>After starting with the <c>--debug</c> option, the interpreter immediately enters debug mode. You should add breakpoints, and then enter <c>r</c> command to run the script. However, you can pre-set breakpoints directly in the script using the <c>debug</c> statement. If you have such statements and if you don't want to enter <c>r</c> command to run the script, add <c>--run</c> option and the script will be executed after launching until the first <c>debug</c> statement:</p>
				<c>goat.exe program.goat --debug --run</c>
			</h>
			<h name="--compile">
				<p>Compile the script into bytecode, but do not execute it.</p>
				<p>Example:</p>
				<c>goat.exe program.goat --compile</c>
				<p>As a result, a binary file <c>&lt;program_name&gt;+.bin</c> (in this case: <c>program.goat.bin</c>) will be written.  The binary is compressed to save space and is unpacked at each loading. To leave the file uncompressed (speeds uploading), use option <c>--do-not-compress</c>:</p>
				<c>goat.exe program.goat --compile --do-not-compress</c>
			</h>
			<h name="--bin">
				<p>Run a previously compiled script.</p>
				<p>Example:</p>
				<c>goat.exe --bin program.goat.bin</c>
				<p>Since the compilation procedure was performed earlier, loading prepared bytecode is faster. This will reduce the overall program execution time.</p>
			</h>
			<h name="--gc">
				<p>One of the four modes of garbage collection.</p>
				<l>
					<i><c>--gc=serial</c> enable serial mode, it means that the garbage collector periodically stops all threads (but it takes low processor resources for collection and has small memory overhead);</i>
					<i><c>--gc=parallel</c> does not stop threads (but it constantly uses some processor resources and also it uses some extra memory), this mode enabled by default;</i>
					<i><c>--gc=disabled</c> completely disables garbage collection. All memory is cleared only after the script is finished;</i>
					<i><c>--gc=debug</c> used for debugging purposes for interpreter developer, it calls collector after each statement of a script and this is <b>very</b> slow.</i>
				</l>
				<p>If you don't know what "garbage collection" means, please do not use this parameter, the parallel collector is okay for most purposes.</p>
			</h>
			<h name="--heap-size=">
				<p>Limit memory used by a script. The value is specified in megabytes.</p>
				<p>Example. Limit memory usage to one megabyte:</p>
				<c>goat.exe program.goat --heap-size=1</c>
				<p>By default, the script uses all available RAM. Limiting memory can lead to a more frequent garbage collector operation and, as a result, to slower work. If there is not enough memory due to a large number of objects, the script will end with an error.</p>
			</h>
			<h name="--dump-memory-usage-report">
				<p>Write memory usage report to <c>&lt;program_name&gt;+.memory.txt</c> file.</p>
				<p>Example:</p>
				<c>goat.exe program.goat --dump-memory-usage-report</c>
				<p>A possible output (<c>program.goat.memory.txt</c>):</p>
				<c><![CDATA[
					MEMORY USAGE REPORT  

					heap size, bytes:     268435456
					peak usage, bytes:    19240301
					gc algorithm:         'serial'
					count of gc launches: 834
					total objects:        986649
					   actually created:  96828
					   reused:            889821 (90.1 %)]]>
				</c>
			</h>
			<h name="--dump-abstract-syntax-tree">
				<p>As a first step, the compiler parses the source code of the script into tokens and generates an abstract syntax tree (<url>https://en.wikipedia.org/wiki/Abstract_syntax_tree</url>). This option dumps abstract syntax tree of tokens to <c>&lt;program_name&gt;+.tokens.txt</c> file as a graph in DOT format (see <url>https://en.wikipedia.org/wiki/DOT_(graph_description_language)</url>). To visualize it, use an appropriate tool, for example, graphwiz (<url>http://graphviz.org</url>).</p>
				<p>Example. The script:</p>
				<c>println(2 + 3 * 4);</c>
				<p>Command line:</p>
				<c><![CDATA[
					goat.exe program.goat --dump-abstract-syntax-tree
					dot -Tsvg program.goat.tokens.txt -o ast.svg]]>
				</c>
				<p>Result:</p>
				<pic title="Abstract syntax tree">graph/abstract_syntax_tree.svg</pic>
			</h>
			<h name="--dump-parse-tree">
				<p>This option dumps parse tree to <c>&lt;program_name&gt;+.ptree.txt</c> file as a graph in DOT format. Parse tree (<url>https://en.wikipedia.org/wiki/Parse_tree</url> is generated from an abstract syntax tree as a second compilation step.</p>
			</h>
			<h name="--dump-assembler-code">
				<p>Write compiled bytecode to <c>&lt;program_name&gt;+.asm</c> file as list of assembler instructions for the virtual machine. Bytecode is generated from the parse tree as the last compilation step.</p>
				<p>Example. The script:</p>
				<c>println(2 + 3 * 4);</c>
				<p>Command line:</p>
				<c>goat.exe program.goat --dump-assembler-code</c>
				<p>A possible output (<c>program.goat.asm</c>):</p>
				<c><![CDATA[
					.data
					  0	println

					.code
						integer	4
						integer	3
						mul
						integer	2
						add
						load	0	; println
						call	1
						pop
						end]]>
				</c>
			</h>
		</s>
	</s>
</goat>
