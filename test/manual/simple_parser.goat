import "grammar.goat";

var grammar = new Grammar();

var DIGIT = grammar.createTag("DIGIT");
var PLUS = grammar.createTag("PLUS");
var MUL = grammar.createTag("MUL");
var BINARY = grammar.createTag("BINARY");

println(grammar);

var Digit = Grammar.Terminal -> {
    tag : DIGIT,

    init : $(value) {
        this.value = value;
    },

    toString : $() {
        return String.valueOf(value);
    }
};

var Plus = Grammar.Terminal -> {
    tag : PLUS,

    toString : $() {
        return "+";
    }
};

var Mul = Grammar.Terminal -> {
    tag : MUL,

    toString : $() {
        return "*";
    }
};

var Binary = Grammar.NonTerminal -> {
    tag : BINARY
};

var source = "1+2*3";
var sequence = grammar.createSequence();

for (var i = 0; i < source.length(); i++) {
    var token;
    switch(source[i]) {
        case '0':
            token = new Digit(0); break;
        case '1':
            token = new Digit(1); break;
        case '2':
            token = new Digit(2); break;
        case '3':
            token = new Digit(3); break;
        case '4':
            token = new Digit(4); break;
        case '5':
            token = new Digit(5); break;
        case '6':
            token = new Digit(6); break;
        case '7':
            token = new Digit(7); break;
        case '8':
            token = new Digit(8); break;
        case '9':
            token = new Digit(9); break;
        case '+':
            token = new Plus(); break;
        case '*':
            token = new Mul(); break;
    }
    sequence.push(token);
}

/*
var repl = new Digit(9);

var j = sequence.iterator();
j.next();
j.next();
j = j.read();
var k = sequence.iterator();
k.next();
k.next();
k.next();
k = k.read();
j.replace_0(repl, k);
*/

for (var i = sequence.iterator(); i.valid(); i.next()) {
    println(i.read().toString());
}

var pp = DIGIT << PLUS >> DIGIT >>> Binary;
println(pp.toString());
