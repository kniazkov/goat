import "grammar.goat";


var TokenChar = Grammar.Token -> {
    init : $(char) {
        this.char = char;
    },

    toString : $() {
        return String.valueOf(char);
    }
};

var TokenBinary = Grammar.Token -> {
    init : $(left, oper, right) {
        this.left = left;
        this.oper = oper;
        this.right = right;
    },

    toString : $() {
        return "[" + left.toString() + oper.toString() + right.toString() + ']';
    }
};

var Digit = Grammar.Rule -> {
    check : $(token) {
        return token.char >= '0' && token.char <= '9';
    }
};

var OperPlusMinus = Grammar.Rule -> {
    check : $(token) {
        return token.char == '+' || token.char == '-';
    }
};

var OperMulDiv = Grammar.Rule -> {
    check : $(token) {
        return token.char == '*' || token.char == '/';
    }
};

var patterns = [
    Digit + OperPlusMinus + Digit >>
        $(tokens) { return new TokenBinary(tokens[0], tokens[1], tokens[2]); },
    Digit + OperMulDiv + Digit >> 
        $(tokens) { return new TokenBinary(tokens[0], tokens[1], tokens[2]); }
];

/*
var q = patterns[0];
q = q.rules.iterator();
while(q.valid()) {
    println(q.read().instanceOf(Grammar.Rule));
    q.next();
}
*/

var source = "2+3*4+1+1";
var sequence = new Grammar.Sequence();

for (var i = 0; i < source.length(); i++) {
    sequence.push(new TokenChar(source[i]));
}

var grammar = new Grammar(patterns);

grammar.pass(sequence);

for (var i = sequence.iterator(); i.valid(); i.next()) {
    var t = i.read();
    println(t.toString() + " " + t.matchers.count());
}
