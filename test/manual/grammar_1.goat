import "grammar.goat";

try {

var grammar = new Grammar();

var DIGIT = grammar.createTag("DIGIT");
var PLUS_MINUS = grammar.createTag("PLUS_MINUS");
var MUL = grammar.createTag("MUL");
var EXPRESSION = grammar.createTag("EXPRESSION");

var Calculator = {
    calc : $() {
        return new Exception.NotImplemented();
    }
};

var Digit = [Grammar.Terminal, Calculator] -> {
    tag : DIGIT,

    init : $(value) {
        this.value = value;
    },

    buils : $() {
        return String.valueOf(value);
    },
    
    calc : $() {
        return value;
    },

    buildXML : $(elem) {
        elem.attrib.value = value;
    }
};

var Plus = Grammar.Terminal -> {
    tag : PLUS_MINUS,

    calcUnary : $(right) {
        return right.calc();
    },

    calcBinary : $(left, right) {
        return left.calc() + right.calc();
    }
};

var Minus = Grammar.Terminal -> {
    tag : PLUS_MINUS,

    calcUnary : $(right) {
        var v = right.calc();
        v = -v;
        return v;
    },

    calcBinary : $(left, right) {
        return left.calc() - right.calc();
    }
};

var Mul = Grammar.Terminal -> {
    tag : MUL,

    calcBinary : $(left, right) {
        return left.calc() * right.calc();
    }
};

var Unary = [Grammar.NonTerminal, Calculator] -> {
    tag : EXPRESSION,

    construct : $() {
        this.right = base.right[0];
        this.oper = base.center;
    },

    calc : $() {
        return oper.calcUnary(right);
    },

    buildXML : $(elem) {
        elem.attrib.type = "unary";
        elem.attrib.oper = oper.tag.name;
    }
};

var Binary = [Grammar.NonTerminal, Calculator] -> {
    tag : EXPRESSION,

    construct : $() {
        this.left = base.left[0];
        this.right = base.right[0];
        this.oper = base.center;
    },

    calc : $() {
        return oper.calcBinary(left, right);
    },

    buildXML : $(elem) {
        elem.attrib.type = "binary";
        elem.attrib.oper = oper.tag.name;
    }
};

var source = "-1+2*3+4*5*1";
var sequence = grammar.createSequence();

for (var i = 0; i < source.length(); i++) {
    var token;
    switch(source[i]) {
        case '0':
            token = new Digit(0); break;
        case '1':
            token = new Digit(1); break;
        case '2':
            token = new Digit(2); break;
        case '3':
            token = new Digit(3); break;
        case '4':
            token = new Digit(4); break;
        case '5':
            token = new Digit(5); break;
        case '6':
            token = new Digit(6); break;
        case '7':
            token = new Digit(7); break;
        case '8':
            token = new Digit(8); break;
        case '9':
            token = new Digit(9); break;
        case '+':
            token = new Plus(); break;
        case '-':
            token = new Minus(); break;
        case '*':
            token = new Mul(); break;
    }
    sequence.push(token);
}

grammar.add([
    Grammar.NULL || PLUS_MINUS <-- PLUS_MINUS --> DIGIT || EXPRESSION --|> Unary,
    DIGIT || EXPRESSION <-- MUL --> DIGIT || EXPRESSION --|> Binary,
    DIGIT || EXPRESSION <-- PLUS_MINUS --> DIGIT || EXPRESSION --|> Binary
]);

grammar.parse();
var xml = sequence.toXML("ROOT");
println(xml.toString("  "));

println(sequence.iterator().read().calc());

}
catch(e) {
    println(e.trace);
}