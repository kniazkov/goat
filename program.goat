import "io.goat";
import "xml.goat";

var ref = 0;

var parseSection = $(src, dst, level, prefix)
{
    var length = src.data.length();
    var i;
    
    var subsections = 0;
    for (i = 0; i < length; ++i)
    {
        var child = src.data[i];
        if (child.instanceof(Xml.Element) && (child.tag == "s" || child.tag == "section"))
            subsections++;
    }
    var content = null;
    if (subsections > 2)
    {
        content = new Xml.Element("ul");
        content.attrib.class = "content";
        dst.data.push(content);
    }

    var subsection = 0;
    for (i = 0; i < length; ++i)
    {
        var child = src.data[i];
        if (!child.instanceof(Xml.Element))
            continue;
        switch(child.tag)
        {
            case "s":
            case "section":
            {
                if (content)
                {
                    var anchor = new Xml.Element("a", ' ');
                    anchor.attrib.name = "ref_" + ref;
                    dst.data.push(anchor);
                    var link = new Xml.Element("a", child.attrib.name);
                    link.attrib.href = "#ref_" + ref;
                    content.data.push(new Xml.Element("li", link));
                    ref++;
                }
                subsection++;
                var prefix2 = prefix + subsection + '.';
                var header = new Xml.Element("div", level < 4 ? prefix2 + ' ' + child.attrib.name : child.attrib.name);
                header.attrib.class = "header";
                header.attrib.style = "font-size: " + levelToFontSize(level) + ';';
                dst.data.push(header);
                var container = new Xml.Element("div");
                container.attrib.class = "section";
                parseSection(child, container, level + 1, prefix2);
                if (container.data.length() > 0)
                    dst.data.push(container);
                break;
            }
            case "p":
            case "paragraph":
            {
                var container = new Xml.Element("div");
                container.attrib.class = "para";
                dst.data.push(container);
                parseParagraph(child, container);
                break;
            }
            case "c":
            case "code":
            {
                if (child.data.length() == 1 && child.data[0].instanceof(String))
                {
                    var container = new Xml.Element("div");
                    container.attrib.class = "code";
                    dst.data.push(container);
                    parseCode(child.data[0], container);
                    break;
                }
            }
        }
    }
};

var levelToFontSize = $(level)
{
    switch(level)
    {
        case 0:
            return "xx-large";
        case 1:
            return "x-large";
        case 2:
            return "large";
        default:
            return "medium";
    }
};

var parseParagraph = $(src, dst)
{
    var length = src.data.length();
    var i;
    for (i = 0; i < length; ++i)
    {
        var child = src.data[i];
        if (child.instanceof(String))
        {
            dst.data.push(child);
        }
        else if (child.instanceof(Xml.Element))
        {
            switch(child.tag)
            {
                case "b":
                case "bold":
                {
                    var span = new Xml.Element("b");
                    dst.data.push(span);
                    parseParagraph(child, span);
                    break;
                }
                case "c":
                case "code":
                {
                    var span = new Xml.Element("code");
                    span.attrib.class = "inline";
                    dst.data.push(span);
                    parseParagraph(child, span);
                    break;
                }
                case "url":
                {
                    if (child.data.length() == 1 && child.data[0].instanceof(String))
                    {
                        var link = new Xml.Element("a", child.data[0]);
                        link.attrib.href = child.data[0];
                        dst.data.push(link);
                        break;
                    }
                }
            }
        }
    }
};

var parseCode = $(value, dst)
{
    var b = new StringBuilder();
    for (var c in value)
    {
        switch(c)
        {
            case '\t':
                b << "  "; break;
            case '\r': break;
            default: b << c;
        }
    }
    value = b.data();
    var lines = value.split('\n');
    var li = lines.length();
    if (li > 0)
    {
        var i,
            offset = null,
            line,
            first;
        for (i = 0; i < li; ++i)
        {
            line = lines[i];
            var j,
                lj = line.length();
            for (j = 0; j < lj; ++j)
            {
                if (line[j] != ' ')
                {
                    offset = j;
                    first = i;
                    break;
                }
            }
            if (offset != null)
                break;
        }
        if (offset != null)
        {
            for (i = first; i < li; ++i)
            {
                if (i != first)
                    dst.data.push(new Xml.Element("br"));
                line = lines[i].substr(offset);
                var b = new StringBuilder();
                var j,
                    lj = line.length();
                for (j = 0; j < lj; j++)
                {
                    var c = line[j];
                    if (c == ' ')
                        b << "&nbsp;";
                    else
                        break;
                }
                var nbsp = b.data();
                nbsp.noEscape = true;
                dst.data.push(nbsp);
                dst.data.push(line.substr(j));
            }
        }
    }
};

var source = load("docs/reference.xml");
if (!source)
{
    println("Can not open source XML");
    exit(-1);
}

var xml = Xml.parse(source.decode("utf8"));

var html = new Xml.Element("html");

var head = new Xml.Element("head");
html.data.push(head);

var title = new Xml.Element("title", "The Goat Programming Language Reference");
head.data.push(title);

var style = new Xml.Element("style");
head.data.push(style);
style.data.push("b { font-family: serif; }");
style.data.push("a { color: darkblue; text-decoration: none; }");
style.data.push(".content { list-style-type: circle; margin-bottom: 0; }");
style.data.push(".section { padding-left: 10pt; }");
style.data.push(".header { font-weight: bold; padding-top: 15pt; }");
style.data.push(".para { padding-top: 10pt; }");
style.data.push(".code { font-family: sans-serif; padding-top: 10pt; }");
style.data.push(".inline { font-family: sans-serif; background-color: lightgray; padding-left: 2pt; padding-right: 2pt; }");

var body = new Xml.Element("body");
html.data.push(body);

var content = new Xml.Element("div", "Table of contents");
content.attrib.class = "header";
content.attrib.style = "font-size: " + levelToFontSize(0) + ';';
body.data.push(content);

parseSection(xml, body, 0, "");

println(html.toString("  "));
