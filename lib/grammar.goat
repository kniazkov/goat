/*

Copyright (C) 2017, 2018 Ivan Kniazkov

This file is part of standard library for programming language
codenamed "Goat" ("Goat standard library").

Goat standard library is free software: you can redistribute it and/or
modify it under the terms of the GNU General Public License as published
by the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Goat standard library is distributed in the hope that it will be
useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with Goat standard library.  If not, see <http://www.gnu.org/licenses/>.

*/

import "assert.goat";
import "list.goat";
import "xml.goat";

var Grammar = {
    init : $() {
        this.tags = [];
        this.graph = [];
        this.pl = [];
    },

    createTag : $(name) {
        var id = tags.length();
        var tag = new Grammar.Tag(id, name);
        tags.push(tag);
        graph.push(new Grammar.List_1());
        return tag;
    },

    createSequence : $() {
        return new Grammar.Sequence(this);
    },

    add : $(object) {
        if (object.instanceOf(Grammar.Pattern))
            pl.push(object);
        else if (object.instanceOf(Array)) {
            for (var i = 0; i < object.length(); i++) {
                var pattern = object[i];
                if (pattern.instanceOf(Grammar.Pattern))
                    pl.push(pattern);
            }
        }
    },

    parse : $() {
        for (var i = 0; i < pl.length(); i++) {
            var pattern = pl[i];
            var list = graph[pattern.tag.id];
            var token = list.first;
            while (token != null) {
                var next = token.r1.next;
                pattern.convolute(this, token);
                token = next;
            }
        }
    },
};

Grammar.Exception = Exception-> {
    toString : $() {
        throw new Exception.NotImplemented();
    }
};

Grammar.Tag = {
    init : $(id, name) {
        this.id = id;
        this.name = name;
    },

    toString : $() {
        return name;
    },

    toRule : $() {
        if (!this.rule) {
            this.rule = new Grammar.RuleTag(this);
        }
        return this.rule;
    },

    "<--" : $(next) {
        if (next.instanceOf(Grammar.Tag)) {
            var pattern = new Grammar.Pattern(next);
            var rule = this.toRule();
            pattern.left.pushf(rule);
            return pattern;
        }
    },

    "-->" : $(next) {
        var pattern = new Grammar.Pattern(this);
        var rule = next.toRule();
        pattern.right.push(rule);
        return pattern;
    },

    "|" : $(right) {
        return new Grammar.RuleOr(this.toRule(), right.toRule());
    }
};

Grammar.Rule = {
    check : $(token) {
        throw new Exception.NotImplemented();
    },

    toString : $() {
        throw new Exception.NotImplemented();
    },

    toRule : $() {
        return this;
    },

    "<--" : $(next) {
        if (next.instanceOf(Grammar.Tag)) {
            var pattern = new Grammar.Pattern(next);
            var rule = this.toRule();
            pattern.left.pushf(rule);
            return pattern;
        }
    },

    "|" : $(right) {
        return new Grammar.RuleOr(this, right.toRule());
    }
};

Grammar.RuleTag = Grammar.Rule -> {
    init : $(tag) {
        this.tag = tag;
    },

    check : $(token) {
        if (token == null)
            return false;
        return token.tag == tag;
    },

    toString : $() {
        return tag.name;
    }
};

Grammar.RuleOr = Grammar.Rule -> {
    init : $(left, right) {
        this.left = left;
        this.right = right;
    },

    check : $(token) {
        return left.check(token) || right.check(token);
    },

    toString : $() {
        return left.toString() + " | " + right.toString();
    }
};

Grammar.NULL = Grammar.Rule -> {
    check : $(token) {
        return token == null;
    },

    toString : $() {
        return "NULL";
    }
};

Grammar.Pattern = {
    init : $(tag) {
        if (!tag.instanceOf(Grammar.Tag))
            throw new Exception.IllegalArgument();
        this.tag = tag;
        this.left = new List();
        this.right = new List();
        this.proto = null;
    },

    toString : $() {
        var b = new StringBuilder();
        for (var i = left.reverseIterator(); i.valid(); i.next()) {
            b << i.read().toString();
            b << " <-- ";
        }
        b << tag.toString();
        for (var i = right.forwardIterator(); i.valid(); i.next()) {
            b << " --> ";
            b << i.read().toString();
        }
        return b.toString();
    },

    "<--" : $(next) {
        if (next.instanceOf(Grammar.Tag)) {
            left.pushf(tag.toRule());
            tag = next;
            return this;
        }
    },

    "-->" : $(next) {
        var rule = next.toRule();
        right.push(rule);
        return this;
    },

    "--|>" : $(proto) {
        if (!proto.instanceOf(Grammar.NonTerminal))
            throw new Exception.IllegalArgument();
        this.proto = proto;
        return this;
    },

    convolute : $(grammar, token) {
        assert(token.tag == tag);
        var begin = token,
            end = token,
            cursor,
            i;
        var result = new this.proto();
        result.base.center = token;
        
        cursor = token;
        for (i = left.iterator(); i.valid(); i.next()) {
            if (cursor != null)
                cursor = cursor.r0.prev;
            if (cursor != null)
                begin = cursor;
            var rule = i.read();
            if (!rule.check(cursor))
                return null;
            result.base.left.push(cursor);
        }

        cursor = token;
        for (i = right.iterator(); i.valid(); i.next()) {
            if (cursor != null)
                cursor = end.r0.next;
            if (cursor != null)
                end = cursor;
            var rule = i.read();
            if (!rule.check(cursor))
                return null;
            result.base.right.push(cursor);
        }

        result.construct();
        
        var node = begin;
        while (node != end) {
            node.remove_1();
            node = node.r0.next;
        }
        end.remove_1();

        begin.replace_0(result, end);
        
        var list_1 = grammar.graph[result.tag.id];
        list_1.push(result);
        
        return result;
    }
};

Grammar.Token = {
    tag : null,

    init : $() {
        this.r0 = {
            list : null,
            prev : null,
            next : null
        };
        this.r1 = {
            list : null,
            prev : null,
            next : null
        };
    },

    toXML : $() {
        var elem = new XML.Element(tag.name);
        this.buildXML(elem);
        return elem;
    },

    buildXML : $(elem) {
        // do nothing. Can be redefined in child classes 
    },

    replace_0 : $(repl, end) {
        if (!end)
            r0.list.replace(repl, this, this);
        else
            r0.list.replace(repl, this, end);
    },

    remove_1 : $() {
        r1.list.remove(this);
    }
};

Grammar.Terminal = Grammar.Token -> {

};

Grammar.NonTerminal = Grammar.Token -> {
    init : $() {
        this.base = {
            center : null,
            left : [],
            right : []
        };
    },

    toXML : $() {
        var elem = new XML.Element(tag.name);
        for (var i = base.left.length() - 1; i >= 0; i--) {
            var t = base.left[i];
            elem.content.push(t != null ? t.toXML() : new XML.Element("NULL"));
        }
        elem.content.push(base.center.toXML());
        for (var i = 0; i < base.right.length(); i++) {
            var t = base.right[i];
            elem.content.push(t != null ? t.toXML() : new XML.Element("NULL"));
        }
        this.buildXML(elem);
        return elem;
    },

    construct : $() {
        // do nothing. Can be redefined in child classes
    }
};

Grammar.List_0 = Iterable -> {
    init : $() {
        this.first = null;
        this.last = null;
    },

    push : $(token) {
        var ref = token.r0;
        assert(ref.list == null);
        
        ref.list = this;
        ref.prev = last;

        if (last != null) {
            last.r0.next = token;
        }
        else {
            first = token;
        }
        last = token;
    },

    replace : $(repl, begin, end) {
        var r_repl = repl.r0;
        assert(r_repl.list == null);

        var r_begin = begin.r0;
        assert(r_begin.list == this);

        var r_end = end.r0;
        assert(r_end.list == this);
        
        if (r_begin.prev != null) {
            r_begin.prev.r0.next = repl;
        }
        else {
            first = repl;
        }
        r_repl.prev = r_begin.prev;

        if (r_end.next != null) {
            r_end.next.r0.prev = repl;
        }
        else {
            last = repl;
        }
        r_repl.next = r_end.next;
        r_repl.list = this;
    },

    iterator : $() {
        return new Grammar.List_0.Iterator(first);
    },

    Iterator : Iterator -> {
        init : $(token) {
            this.token = token;
        },

        valid : $() {
            return token != null;
        },

        next : $() {
            if (!token)
                throw new Exception.InvalidOperation();
            token = token.r0.next;
        },

        read : $() {
            return token;
        }
    }
};

Grammar.List_1 = {
    init : $() {
        this.first = null;
        this.last = null;
    },

    push : $(token) {
        var ref = token.r1;
        assert(ref.list == null);
        
        ref.list = this;
        ref.prev = last;

        if (last != null) {
            last.r1.next = token;
        }
        else {
            first = token;
        }
        last = token;
    },

    remove : $(token) {
        var ref = token.r1;
        assert(ref.list == this);
        
        if (ref.prev != null) {
            ref.prev.r1.next = ref.next;
        }
        else {
            first = ref.next;
        }

        if (ref.next != null) {
            ref.next.r1.prev = ref.prev;
        }
        else {
            last = ref.prev;
        }
    }
};

Grammar.Sequence = {
    init : $(grammar) {
        this.grammar = grammar;
        this.list = new Grammar.List_0();
    },

    push : $(token) {
        list.push(token);
        var list_1 = grammar.graph[token.tag.id];
        list_1.push(token);
    },

    iterator : $() {
        return list.iterator();
    },

    toXML : $(tag) {
        var elem = new XML.Element(tag);
        for (var i = list.iterator(); i.valid(); i.next()) {
            elem.content.push(i.read().toXML());
        }
        return elem;
    }
};
