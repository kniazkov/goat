/*

Copyright (C) 2017, 2018 Ivan Kniazkov

This file is part of standard library for programming language
codenamed "Goat" ("Goat standard library").

Goat standard library is free software: you can redistribute it and/or
modify it under the terms of the GNU General Public License as published
by the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Goat standard library is distributed in the hope that it will be
useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with Goat standard library.  If not, see <http://www.gnu.org/licenses/>.

*/

import "list.goat";

var Grammar = {
    init : $(patterns) {
        this.patterns = patterns;
    },

    pass : $(sequence) {
        var changes = 0;
        var checklist = new List();
        for (var i = sequence.iterator(); i.valid(); i.next()) {
            var token = i.read();

            //  check all matchers from the checklist 
            var j = checklist.iterator();
            while (j.valid()) {
                var matcher = j.read();
                var result = matcher.match(token);
                println("> " + result);
                if (result) {
                    //  matched, go to next rule of the matcher
                    if (matcher.next())
                        j.next();
                    else {
                        j.remove();
                    }
                }
                else {
                    //  not matched, remove the matcher from the first token
                    matcher.begin.matchers.removeFirst(matcher);
                    j.remove();
                }
            }

            //  check the first rule from each pattern
            token.matchers.clear();
            for (var k = 0; k < patterns.length(); k++) {
                var pattern = patterns[k];
                //  get the first rule from the pattern and check the token
                var rule = pattern.rules.peekf();
                var result = rule.check(token);
                println("0 " + result);
                if (result) {
                    /*  if the rule is applicable then create a matcher
                        and add it to the token and to the checklist (if needed) */
                    var matcher = new Grammar.Matcher(pattern, token);
                    token.matchers.push(matcher);
                    if (matcher.next())
                        checklist.push(matcher);
                }
            }
        }

        // remove all remaining matchers from the checklist
        for (var j = checklist.iterator(); j.valid(); j.next()) {
            var matcher = j.read();
            matcher.begin.matchers.removeFirst(matcher);
        }
        return changes;
    }
};

Grammar.Token = {
    init : $() {
        this.matchers = new List();
    }
};

Grammar.Sequence = List -> {

};

Grammar.Rule = {
    init : $() {
        this.owner = null;
    },

    check : $(token) {
        return false;
    },

    createPattern : $() {
        var pt = new Grammar.Pattern();
        pt.push(this);
        return pt;
    },

    "+" : $(rule) {
        var pattern = new Grammar.Pattern();
        pattern.rules.push(this);
        pattern.rules.push(rule);
        return pattern;
    },

    ">>" : $(callback) {
        var pattern = new Grammar.Pattern();
        pattern.rules.push(this);
        pattern.callback = callback;
        return pattern;
     }
};

Grammar.Pattern = {
    init : $() {
        this.rules = new List();
        this.callback = null;
    },

    "+" : $(rule) {
        this.rules.push(rule);
        return this;
    },

    ">>" : $(callback) {
        this.callback = callback;
        return this;
    }
};

Grammar.Matcher = {
    init : $(pattern, token) {
        this.pattern = pattern;
        this.begin = token;
        this.iter = pattern.rules.iterator();
    },

    next : $() {
        iter.next();
        return iter.valid();
    },

    match : $(token) {
        if (!iter.valid())
            return false;
        var rule = iter.read();
        return rule.check(token);
    }
};
