/*

Copyright (C) 2017, 2018 Ivan Kniazkov

This file is part of standard library for programming language
codenamed "Goat" ("Goat standard library").

Goat standard library is free software: you can redistribute it and/or
modify it under the terms of the GNU General Public License as published
by the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Goat standard library is distributed in the hope that it will be
useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with Goat standard library.  If not, see <http://www.gnu.org/licenses/>.

*/

import "assert.goat";
import "list.goat";

var Grammar = {
    init : $() {
        this.tags = [];
        this.graph = [];
    },

    createTag : $(name) {
        var id = tags.length();
        var tag = new Grammar.Tag(id, name);
        tags.push(tag);
        graph.push(new Grammar.List_1());
        return tag;
    },

    createSequence : $() {
        return new Grammar.Sequence(this);
    }
};

Grammar.Exception = Exception-> {
    toString : $() {
        throw new Exception.NotImplemented();
    }
};

Grammar.Tag = {
    init : $(id, name) {
        this.id = id;
        this.name = name;
    },

    toString : $() {
        return name;
    },

    toRule : $() {
        if (!this.rule) {
            this.rule = new Grammar.RuleTag(this);
        }
        return this.rule;
    },

    "-->" : $(next) {
        var pattern = new Grammar.Pattern(this);
        var rule = next.toRule();
        pattern.right.push(rule);
        return pattern;
    },

    "<--" : $(next) {
        if (next.instanceOf(Grammar.Tag)) {
            var pattern = new Grammar.Pattern(next);
            var rule = this.toRule();
            pattern.left.pushf(rule);
            return pattern;
        }
    }
};

Grammar.Rule = {
    check : $(token) {
        throw new Exception.NotImplemented();
    },

    toString : $() {
        throw new Exception.NotImplemented();
    },

    toRule : $() {
        return this;
    }
};

Grammar.RuleTag = {
    init : $(tag) {
        this.tag = tag;
    },

    check : $(token) {
        return token.tag == tag;
    },

    toString : $() {
        return tag.name;
    }
};

Grammar.Pattern = {
    init : $(tag) {
        if (!tag.instanceOf(Grammar.Tag))
            throw new Exception.IllegalArgument();
        this.tag = tag;
        this.left = new List();
        this.right = new List();
        this.proto = null;
    },

    toString : $() {
        var b = new StringBuilder();
        for (var i = left.iterator(); i.valid(); i.next()) {
            b << i.read().toString();
            b << " <-- ";
        }
        b << tag.toString();
        for (var i = right.iterator(); i.valid(); i.next()) {
            b << " --> ";
            b << i.read().toString();
        }
        return b.toString();
    },

    "-->" : $(next) {
        var rule = next.toRule();
        right.push(rule);
        return this;
    },

    "--|>" : $(proto) {
        if (!proto.instanceOf(Grammar.NonTerminal))
            throw new Exception.IllegalArgument();
        this.proto = proto;
        return this;
    }
};

Grammar.Token = {
    tag : null,

    init : $() {
        this.r0 = {
            list : null,
            prev : null,
            next : null
        };
        this.r1 = {
            list : null,
            prev : null,
            next : null
        };
    },

    toString : $() {
        return tag.name;
    },

    replace_0 : $(repl, end) {
        if (!end)
            r0.list.replace(repl, this, this);
        else
            r0.list.replace(repl, this, end);
    },

    remove_1 : $() {
        r1.list.remove(this);
    }
};

Grammar.Terminal = Grammar.Token -> {

};

Grammar.NonTerminal = Grammar.Token -> {
    init : $() {
        this.base = {
            center : null,
            left : [],
            right : []
        };
    },

    toString : $() {
        var b = new StringBuilder();
        b << "(";
        for (var i = base.left.length() - 1; i >= 0; i--) {
            var t = base.left[i];
            b << ' ' << t.toString();
        }
        b << ' ' << base.center.toString();
        for (i = 0; i < base.right.lenght(); i++) {
            var t = base.right[i];
            b << ' ' << t.toString();
        }
        b << " )";
    },

    construct : $() {

    }
};

Grammar.List_0 = Iterable -> {
    init : $() {
        this.first = null;
        this.last = null;
    },

    push : $(token) {
        var ref = token.r0;
        assert(ref.list == null);
        
        ref.list = this;
        ref.prev = last;

        if (last != null) {
            last.r0.next = token;
        }
        else {
            first = token;
        }
        last = token;
    },

    replace : $(repl, begin, end) {
        var r_repl = repl.r0;
        assert(r_repl.list == null);

        var r_begin = begin.r0;
        assert(r_begin.list == this);

        var r_end = end.r0;
        assert(r_end.list == this);
        
        if (r_begin.prev != null) {
            r_begin.prev.r0.next = repl;
        }
        else {
            first = repl;
        }
        r_repl.prev = r_begin.prev;

        if (r_end.next != null) {
            r_end.next.r0.prev = repl;
        }
        else {
            last = repl;
        }
        r_repl.next = r_end.next;
    },

    iterator : $() {
        return new Grammar.List_0.Iterator(first);
    },

    Iterator : Iterator -> {
        init : $(token) {
            this.token = token;
        },

        valid : $() {
            return token != null;
        },

        next : $() {
            if (!token)
                throw new Exception.InvalidOperation();
            token = token.r0.next;
        },

        read : $() {
            return token;
        }
    }
};

Grammar.List_1 = {
    init : $() {
        this.first = null;
        this.last = null;
    },

    push : $(token) {
        var ref = token.r1;
        assert(ref.list == null);
        
        ref.list = this;
        ref.prev = last;

        if (last != null) {
            last.r1.next = token;
        }
        else {
            first = token;
        }
        last = token;
    },

    remove : $(token) {
        var ref = token.r1;
        assert(ref.list == this);
        
        if (ref.prev != null) {
            ref.prev.r1.next = ref.next;
        }
        else {
            first = ref.next;
        }

        if (ref.next != null) {
            ref.next.r1.prev = ref.prev;
        }
        else {
            last = ref.prev;
        }
    }
};

Grammar.Sequence = {
    init : $(grammar) {
        this.grammar = grammar;
        this.list = new Grammar.List_0();
    },

    push : $(token) {
        list.push(token);
        var list_1 = grammar.graph[token.tag.id];
        list_1.push(token);
    },

    iterator : $() {
        return list.iterator();
    }
};
